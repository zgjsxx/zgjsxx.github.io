<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo常用命令</title>
    <url>/2023/01/12/Hexo-common-used-command/</url>
    <content><![CDATA[<!--  # Hexo常用命令 -->
<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo<i class="fas fa-external-link-alt"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation<i class="fas fa-external-link-alt"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting<i class="fas fa-external-link-alt"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub<i class="fas fa-external-link-alt"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="create-draft"><a href="#create-draft" class="headerlink" title="create draft"></a>create draft</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new draft <span class="string">&quot;My draft&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Hexo-show-draft"><a href="#Hexo-show-draft" class="headerlink" title="Hexo show draft"></a>Hexo show draft</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server --draft</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>关机时，如何控制systemd服务的关闭顺序?</title>
    <url>/2023/01/11/how-to-control-stop-flow-in-systemd/</url>
    <content><![CDATA[<!-- # 关机时，如何控制systemd服务的关闭顺序?-->

<p>在工作中，我们通常遇到的问题是，如何控制systemd服务的启动顺序，同志们第一反应就会是使用Before&#x3D;或者After&#x3D;去进行控制。 问题来了，如果服务启动时没有顺序要求，但是关闭时有顺序要求， 该如何操作？</p>
<p>通过查找如下相关文档， 我查到了这样一段话：</p>
<p><a class="link"   href="https://www.freedesktop.org/software/systemd/man/systemd.unit.html" >https://www.freedesktop.org/software/systemd/man/systemd.unit.html<i class="fas fa-external-link-alt"></i></a></p>
<blockquote>
<p>When two units with an ordering dependency between them are shut down, the inverse of the start-up order is applied. I.e. if a unit is configured with After&#x3D; on another unit, the former is stopped before the latter if both are shut down.</p>
</blockquote>
<p>上面这段话的意思是，如果使用After&#x3D;或者Before&#x3D;规定了进程的启动顺序， 那么关闭时的顺序与启动时的顺序将是相反的。</p>
<p>比如有A、B、C三个服务， 启动时的顺序时A-&gt;B-&gt;C, 那么服务的关闭顺序将是C-&gt;B-&gt;A。 事实是这样的吗？ 下面通过一个小实验进行验证。</p>
<h1 id="验证systemd的关闭顺序"><a href="#验证systemd的关闭顺序" class="headerlink" title="验证systemd的关闭顺序"></a>验证systemd的关闭顺序</h1><p>这里我们准备三个服务，服务在启动时候会向文件中写入相应的启动和关闭日志，通过日志我们来判断服务的启动和关闭顺序。</p>
<p>首先是test1.sh， 该文件接受start&#x2F;stop两个命令行参数， 启动时写入日志start1， 关闭时写入日志stop1。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">start)</span><br><span class="line">echo &quot;start1&quot; &gt;&gt; /home/test/test.log</span><br><span class="line">;;</span><br><span class="line">stop)</span><br><span class="line">echo &quot;stop1&quot; &gt;&gt; /home/test/test.log</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p>下面是test1服务的systemd的service文件test1.service，这里我们只需要脚本执行一次，因此使用的Type是oneshot类型，并且指定RemainAfterExit&#x3D;yes，意思是该脚本只会执行一次，并且退出后， 不会意味着服务是inacive状态， 将会显示服务是active(exited)状态。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=mytest:while date service</span><br><span class="line">After=network.target sshd.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=oneshot</span><br><span class="line">ExecStart= /home/test/test1.sh start</span><br><span class="line">ExecStop= /home/test/test1.sh stop</span><br><span class="line">RemainAfterExit=yes</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>test2.sh与test1.sh类似，只是打印的日志内容不同。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">start)</span><br><span class="line">echo &quot;start2&quot; &gt;&gt; /home/test/test.log</span><br><span class="line">;;</span><br><span class="line">stop)</span><br><span class="line">echo &quot;stop2&quot; &gt;&gt; /home/test/test.log</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p>test2.service同test1.service， 不同的是我在After中增加了test1.service， 这就意味着test2晚于test1启动。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=mytest:while date service</span><br><span class="line">After=network.target sshd.service test1.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=oneshot</span><br><span class="line">ExecStart= /home/test/test2.sh start</span><br><span class="line">ExecStop= /home/test/test2.sh stop</span><br><span class="line">RemainAfterExit=yes</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>test3.sh同test1.sh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">start)</span><br><span class="line">echo &quot;start3&quot; &gt;&gt; /home/test/test.log</span><br><span class="line">;;</span><br><span class="line">stop)</span><br><span class="line">echo &quot;stop3&quot; &gt;&gt; /home/test/test.log</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p>test3.service同test1.service，不同的是我在After中增加了test2.service， 这就意味着test3晚于test2启动。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=mytest:while date service</span><br><span class="line">After=network.target sshd.service test2.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=oneshot</span><br><span class="line">ExecStart= /home/test/test3.sh start</span><br><span class="line">ExecStop= /home/test/test3.sh stop</span><br><span class="line">RemainAfterExit=yes</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>通过下面的命令将三个服务分别加入到systemd的目录中，并且启动它们并设为开机启动。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp test1.service /usr/lib/systemd/system/</span><br><span class="line">cp test2.service /usr/lib/systemd/system/</span><br><span class="line">cp test3.service /usr/lib/systemd/system/</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable test1</span><br><span class="line">systemctl enable test2</span><br><span class="line">systemctl enable test3</span><br><span class="line">systemctl start test1</span><br><span class="line">systemctl start test2</span><br><span class="line">systemctl start test3</span><br></pre></td></tr></table></figure>

<p>此时，test.log文件已经打印出了刚刚手动执行启动命令产生的日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost test]# cat test.log</span><br><span class="line">start1</span><br><span class="line">start2</span><br><span class="line">start3</span><br></pre></td></tr></table></figure>

<p>通过上述的步骤，我们构建出了三个服务，这三个服务的启动顺序是test1-&gt;test2-&gt;test3， 那么根据我们的推测， 关闭顺序应该是test3-&gt;test2-&gt;test1，是否如此呢？</p>
<p>下面就是到了最终验证的时刻！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>

<p>等待一小会后，我们打印出test.log</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost test]# cat test.log</span><br><span class="line">start1</span><br><span class="line">start2</span><br><span class="line">start3</span><br><span class="line">stop3</span><br><span class="line">stop2</span><br><span class="line">stop1</span><br><span class="line">start1</span><br><span class="line">start2</span><br><span class="line">start3</span><br></pre></td></tr></table></figure>

<p>可以看到停止时依次打印出了stop3，stop2，stop1。这与我们的猜想以及文档中的说明是一致的。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>systemd通过After和Before可以指定服务的启动顺序， 在系统关闭时，服务的关闭顺序和启动顺序是相反的， 先启动的后关闭，后启动的先关闭。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Fork之前创建的互斥锁，Fork之后是否可以保护临界区？</title>
    <url>/2023/01/12/mutex-with-fork/</url>
    <content><![CDATA[<!-- # Fork之前创建了互斥锁，Fork之后是否可以保护临界区？-->
<p>这是一道某数通公司的面试题。</p>
<p>这个问题按照我的理解意思是，在fork之前创建一把互斥锁，在fork之后，如果子进程使用该锁lock住一段临界区，那么父进程是否需要等待子进程unlock该锁才可以进入临界区?</p>
<p>反之也一样，如果父进程使用该锁lock住一段临界区，那么子进程是否需要等待父进程unlock该锁才可以进入临界区?</p>
<p>经过一番思索，我认为该问题需要分为两个情况进行讨论， 即该互斥锁是<strong>线程锁</strong>还是<strong>进程锁</strong>两种场景进行讨论。</p>
<p>首先我们讨论线程锁。</p>
<h1 id="fork之前创建线程锁"><a href="#fork之前创建线程锁" class="headerlink" title="fork之前创建线程锁"></a>fork之前创建线程锁</h1><p>这里我们使用pthread_mutex_t创建了一个互斥锁mutex。该mutex不设置任何其他的属性。我们在fork之后让父进程和子进程执行临界区的代码，进入临界区和离开临界区分别lock和unlock，临界区代码的功能就是去打印一些”start to work”的日志。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(std::string name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s start to work, index = %d\n&quot;</span>, name.<span class="built_in">c_str</span>(), i);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    </span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>( pid == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;child&quot;</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;parent&quot;</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行之前，我们先定性分析一下，父进程在其地址空间中创建了一把互斥锁进而调用了fork函数，我们知道fork函数拥有copy-on-wrtie机制，当子进程或者父进程对锁进行lock时，父子进程的内存空间分离，也就是说父子进程的锁的作用范围就被限制在了各自的进程空间中，互不干扰。 所以理论上将父子进程在进入临界区时使用的是各自内存空间中的互斥锁， 应该是互不影响的，不能控制父子进程进入临界区。</p>
<p>那么是不是如此呢？我们执行一下。</p>
<p>执行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost mutex]# ./a.out</span><br><span class="line">parent start to work, index = 0</span><br><span class="line">child start to work, index = 0</span><br><span class="line">parent start to work, index = 1</span><br><span class="line">child start to work, index = 1</span><br><span class="line">parent start to work, index = 2</span><br><span class="line">child start to work, index = 2</span><br><span class="line">parent start to work, index = 3</span><br><span class="line">child start to work, index = 3</span><br><span class="line">parent start to work, index = 4</span><br><span class="line">child start to work, index = 4</span><br><span class="line">parent start to work, index = 5</span><br><span class="line">child start to work, index = 5</span><br><span class="line">parent start to work, index = 6</span><br><span class="line">child start to work, index = 6</span><br><span class="line">parent start to work, index = 7</span><br><span class="line">child start to work, index = 7</span><br><span class="line">parent start to work, index = 8</span><br><span class="line">child start to work, index = 8</span><br><span class="line">parent start to work, index = 9</span><br><span class="line">child start to work, index = 9</span><br></pre></td></tr></table></figure>
<p>我们看到父子进程的日志交替输出， 并没有出现父进程的日志整体先于子进程的日志， 或者子进程的日志整体先于父进程的日志的现象。通过该实验证明了我们之前的定性分析是正确的。接下来我们来讨论进程锁。</p>
<h1 id="fork之前创建进程锁"><a href="#fork之前创建进程锁" class="headerlink" title="fork之前创建进程锁"></a>fork之前创建进程锁</h1><p>和线程锁代码类似， 我们也创建了一把互斥锁。稍有区别的是，该锁使用mmap创建并附加了MAP_SHARED属性，这样做导致了该锁创建在了该进程的共享内存空间中。除此以外，该互斥锁还拥有一个属性PTHREAD_PROCESS_SHARED， 这意味着该锁是跨越进程的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(std::string name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s start to work, index = %d\n&quot;</span>, name.<span class="built_in">c_str</span>(), i);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// 使用mmap 创建一把共享锁</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span>* mutex = (<span class="type">pthread_mutex_t</span>*)<span class="built_in">mmap</span>(<span class="literal">NULL</span>,<span class="built_in">sizeof</span>(<span class="type">pthread_mutex_t</span>),PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANON,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(mutex, <span class="number">0</span> ,<span class="built_in">sizeof</span>(<span class="type">pthread_mutex_t</span>));</span><br><span class="line">    <span class="type">pthread_mutexattr_t</span> mutexattr;</span><br><span class="line">    <span class="built_in">pthread_mutexattr_init</span>(&amp;mutexattr);</span><br><span class="line">    <span class="comment">// 修改属性为进程间共享</span></span><br><span class="line">    <span class="built_in">pthread_mutexattr_setpshared</span>(&amp;mutexattr, PTHREAD_PROCESS_SHARED);</span><br><span class="line">    <span class="comment">// 初始化一把 mutex 锁, 该所拥有进程间共享的特性</span></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(mutex,&amp;mutexattr);</span><br><span class="line">    </span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>( pid == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(mutex);</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;child&quot;</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(mutex);</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;parent&quot;</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(mutex);</span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutexattr_destroy</span>(&amp;mutexattr);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(mutex);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在执行之前，我们先定性分析， 由于该锁是创建在共享内存空间中，因此子进程和父进程的mutex是存放在同一块物理内存上的， 也就是同一个对象。 所以这个场景下，执行结果就会出现同步效果。 也就是子进程先打印或者父进程先打印的结果。</p>
<p>执行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost mutex]# ./a.out</span><br><span class="line">parent start to work, index = 0</span><br><span class="line">parent start to work, index = 1</span><br><span class="line">parent start to work, index = 2</span><br><span class="line">parent start to work, index = 3</span><br><span class="line">parent start to work, index = 4</span><br><span class="line">parent start to work, index = 5</span><br><span class="line">parent start to work, index = 6</span><br><span class="line">parent start to work, index = 7</span><br><span class="line">parent start to work, index = 8</span><br><span class="line">parent start to work, index = 9</span><br><span class="line">child start to work, index = 0</span><br><span class="line">child start to work, index = 1</span><br><span class="line">child start to work, index = 2</span><br><span class="line">child start to work, index = 3</span><br><span class="line">child start to work, index = 4</span><br><span class="line">child start to work, index = 5</span><br><span class="line">child start to work, index = 6</span><br><span class="line">child start to work, index = 7</span><br><span class="line">child start to work, index = 8</span><br><span class="line">child start to work, index = 9</span><br></pre></td></tr></table></figure>
<p>执行结果是父进程先执行完然后子进程再执行，这就说明这个时候进程锁就起到了同步的作用， 控制了子进程和父进程进入临界区的顺序。</p>
<h1 id="设置了PTHREAD-PROCESS-SHARED属性，-在fork之后就一定可以控制执行顺序吗？"><a href="#设置了PTHREAD-PROCESS-SHARED属性，-在fork之后就一定可以控制执行顺序吗？" class="headerlink" title="设置了PTHREAD_PROCESS_SHARED属性， 在fork之后就一定可以控制执行顺序吗？"></a>设置了PTHREAD_PROCESS_SHARED属性， 在fork之后就一定可以控制执行顺序吗？</h1><p>我们看下面的例子， 该锁直接创建在父进程的栈中，并设置PTHREAD_PROCESS_SHARED属性， 那么可以起到控制父子进程进入临界区吗？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(std::string name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s start to work, index = %d\n&quot;</span>, name.<span class="built_in">c_str</span>(), i);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// 使用mmap 创建一把共享锁</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="type">pthread_mutexattr_t</span> mutexattr;</span><br><span class="line">    <span class="built_in">pthread_mutexattr_init</span>(&amp;mutexattr);</span><br><span class="line">    <span class="comment">// 修改属性为进程间共享</span></span><br><span class="line">    <span class="built_in">pthread_mutexattr_setpshared</span>(&amp;mutexattr, PTHREAD_PROCESS_SHARED);</span><br><span class="line">    <span class="comment">// 初始化一把 mutex 锁, 该所拥有进程间共享的特性</span></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex,&amp;mutexattr);</span><br><span class="line">    </span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>( pid == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;child&quot;</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;parent&quot;</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutexattr_destroy</span>(&amp;mutexattr);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost mutex]# ./a.out</span><br><span class="line">parent start to work, index = 0</span><br><span class="line">child start to work, index = 0</span><br><span class="line">parent start to work, index = 1</span><br><span class="line">child start to work, index = 1</span><br><span class="line">parent start to work, index = 2</span><br><span class="line">child start to work, index = 2</span><br><span class="line">parent start to work, index = 3</span><br><span class="line">child start to work, index = 3</span><br><span class="line">parent start to work, index = 4</span><br><span class="line">child start to work, index = 4</span><br><span class="line">parent start to work, index = 5</span><br><span class="line">child start to work, index = 5</span><br><span class="line">parent start to work, index = 6</span><br><span class="line">child start to work, index = 6</span><br><span class="line">parent start to work, index = 7</span><br><span class="line">child start to work, index = 7</span><br><span class="line">parent start to work, index = 8</span><br><span class="line">child start to work, index = 8</span><br><span class="line">parent start to work, index = 9</span><br><span class="line">child start to work, index = 9</span><br></pre></td></tr></table></figure>
<p>此时发现子进程和父进程交替进入了临界区， 该锁没有起到同步作用。 与实验二对比， 实验二中互斥锁创建在父进程的共享内存中， 并设置有PTHREAD_PROCESS_SHARED属性， 因此父子进程操作的是同一把锁。而在实验三中，互斥锁创建在父进程的栈中， 由于<strong>写时复制</strong>， 父子进程实际操作的是各自内存空间的锁，因此没有同步作用。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>如果在fork之前创建的互斥锁具有PTHREAD_PROCESS_SHARED属性，并且该锁创建在父进程的共享内存中， 也就是说如果该互斥锁是一把<strong>进程锁</strong>，那么其对父子进程具有保护临界区的作用。 如果在fork之前创建的互斥锁没有该属性， 也就是说如果该锁是一把<strong>线程锁</strong>， 那么其没有对父子进程没有保护临界区的作用。</p>
<p>除此以外，如果一把锁要成为进程锁，需要两个条件， 一是该锁需要创建在共享内存中， 二是该锁需要有PTHREAD_PROCESS_SHARED属性。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
</search>
