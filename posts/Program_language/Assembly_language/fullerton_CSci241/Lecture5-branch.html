<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.60" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://mister-hope.github.io/posts/Program_language/Assembly_language/fullerton_CSci241/Lecture5-branch.html"><meta property="og:site_name" content="Code Building"><meta property="og:title" content="第五讲：分支、条件、循环、函数"><meta property="og:description" content="第五讲：分支、条件、循环、函数 算术运算 add dest, src ; dest += src sub dest, src ; dest -= src"><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2024-03-04T08:55:36.000Z"><meta property="article:modified_time" content="2024-03-04T08:55:36.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"第五讲：分支、条件、循环、函数","image":[""],"dateModified":"2024-03-04T08:55:36.000Z","author":[]}</script><title>第五讲：分支、条件、循环、函数 | Code Building</title><meta name="description" content="第五讲：分支、条件、循环、函数 算术运算 add dest, src ; dest += src sub dest, src ; dest -= src">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/assets/style-3dfb99ab.css" as="style"><link rel="stylesheet" href="/assets/style-3dfb99ab.css">
    <link rel="modulepreload" href="/assets/app-ce69e733.js"><link rel="modulepreload" href="/assets/framework-9a29aaa0.js"><link rel="modulepreload" href="/assets/Lecture5-branch.html-986f032e.js"><link rel="modulepreload" href="/assets/Lecture5-branch.html-d4038b57.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container no-sidebar has-toc"><!--[--><header class="navbar" id="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><a href="/" class="brand"><img class="logo" src="/logo.svg" alt="Code Building"><!----><span class="site-name hide-in-pad">Code Building</span></a><!--[--><!----><!--]--></div><div class="navbar-center"><!--[--><!----><!--]--><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/" class="nav-link" aria-label="程序员小x"><span class="font-icon icon iconfont icon-home" style=""></span>程序员小x<!----></a></div><div class="nav-item hide-in-mobile"><a href="/demo/" class="nav-link" aria-label="演示"><span class="font-icon icon iconfont icon-discover" style=""></span>演示<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="博文"><span class="title"><span class="font-icon icon iconfont icon-edit" style=""></span>博文</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/posts/network" class="nav-link" aria-label="计算机网络"><span class="font-icon icon iconfont icon-edit" style=""></span>计算机网络<!----></a></li><li class="dropdown-item"><a href="/posts/Program_language/cpp" class="nav-link" aria-label="c++"><span class="font-icon icon iconfont icon-edit" style=""></span>c++<!----></a></li><li class="dropdown-item"><a href="/posts/design-pattern" class="nav-link" aria-label="设计模式"><span class="font-icon icon iconfont icon-edit" style=""></span>设计模式<!----></a></li><li class="dropdown-item"><a href="/posts/tool" class="nav-link" aria-label="工具"><span class="font-icon icon iconfont icon-edit" style=""></span>工具<!----></a></li><li class="dropdown-item"><a href="/posts/Linux/compile" class="nav-link" aria-label="编译原理"><span class="font-icon icon iconfont icon-edit" style=""></span>编译原理<!----></a></li><li class="dropdown-item"><a href="/posts/Linux/kernel/Linux-0.11" class="nav-link" aria-label="Linux-0.11详解"><span class="font-icon icon iconfont icon-edit" style=""></span>Linux-0.11详解<!----></a></li><li class="dropdown-item"><a href="/posts/Linux/application-dev" class="nav-link" aria-label="Linux应用层开发"><span class="font-icon icon iconfont icon-edit" style=""></span>Linux应用层开发<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a href="https://meiriyiwen.com/" rel="noopener noreferrer" target="_blank" aria-label="每日一文" class="nav-link"><span class="font-icon icon iconfont icon-note" style=""></span>每日一文<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="nav-item hide-in-mobile"><a href="/posts/about/about.html" class="nav-link" aria-label="关于作者"><span class="font-icon icon iconfont icon-about" style=""></span>关于作者<!----></a></div></nav><!--[--><!----><!--]--></div><div class="navbar-right"><!--[--><!----><!--]--><!----><div class="nav-item"><a class="repo-link" href="https://github.com/vuepress-theme-hope/vuepress-theme-hope" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!--[--><button class="search-pro-button" role="search" aria-label="搜索"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg></button><!--]--><!--[--><!----><!--]--><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar" id="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->第五讲：分支、条件、循环、函数</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://zgjsxx.github.io" target="_blank" rel="noopener noreferrer">程序员小x</a></span><span property="author" content="程序员小x"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2024-02-26T05:11:56.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 23 分钟</span><meta property="timeRequired" content="PT23M"></span><span class="page-category-info" aria-label="分类🌈" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><span class="page-category-item category5 clickable" role="navigation">汇编语言</span><meta property="articleSection" content="汇编语言"></span><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容<button class="print-button" title="print"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Program_language/Assembly_language/fullerton_CSci241/Lecture5-branch.html#算术运算" class="router-link-active router-link-exact-active toc-link level2">算术运算</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Program_language/Assembly_language/fullerton_CSci241/Lecture5-branch.html#标记" class="router-link-active router-link-exact-active toc-link level2">标记</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Program_language/Assembly_language/fullerton_CSci241/Lecture5-branch.html#递增和递减" class="router-link-active router-link-exact-active toc-link level2">递增和递减</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Program_language/Assembly_language/fullerton_CSci241/Lecture5-branch.html#大于-64-位的加法-减法" class="router-link-active router-link-exact-active toc-link level2">大于 64 位的加法/减法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Program_language/Assembly_language/fullerton_CSci241/Lecture5-branch.html#乘法和除法" class="router-link-active router-link-exact-active toc-link level2">乘法和除法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Program_language/Assembly_language/fullerton_CSci241/Lecture5-branch.html#函数-分支-和-条件指令" class="router-link-active router-link-exact-active toc-link level2">函数 分支 和 条件指令</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Program_language/Assembly_language/fullerton_CSci241/Lecture5-branch.html#汇编语言程序的结构" class="router-link-active router-link-exact-active toc-link level2">汇编语言程序的结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Program_language/Assembly_language/fullerton_CSci241/Lecture5-branch.html#分支" class="router-link-active router-link-exact-active toc-link level2">分支</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Program_language/Assembly_language/fullerton_CSci241/Lecture5-branch.html#标签" class="router-link-active router-link-exact-active toc-link level3">标签</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Program_language/Assembly_language/fullerton_CSci241/Lecture5-branch.html#跳转" class="router-link-active router-link-exact-active toc-link level2">跳转</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Program_language/Assembly_language/fullerton_CSci241/Lecture5-branch.html#比较" class="router-link-active router-link-exact-active toc-link level2">比较</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Program_language/Assembly_language/fullerton_CSci241/Lecture5-branch.html#条件" class="router-link-active router-link-exact-active toc-link level3">条件</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Program_language/Assembly_language/fullerton_CSci241/Lecture5-branch.html#内存与内存的比较" class="router-link-active router-link-exact-active toc-link level3">内存与内存的比较</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Program_language/Assembly_language/fullerton_CSci241/Lecture5-branch.html#test指令" class="router-link-active router-link-exact-active toc-link level2">test指令</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Program_language/Assembly_language/fullerton_CSci241/Lecture5-branch.html#其他指令" class="router-link-active router-link-exact-active toc-link level2">其他指令</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Program_language/Assembly_language/fullerton_CSci241/Lecture5-branch.html#条件分支的指令" class="router-link-active router-link-exact-active toc-link level2">条件分支的指令</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Program_language/Assembly_language/fullerton_CSci241/Lecture5-branch.html#跳转目标" class="router-link-active router-link-exact-active toc-link level2">跳转目标</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Program_language/Assembly_language/fullerton_CSci241/Lecture5-branch.html#条件跳转到计算目标" class="router-link-active router-link-exact-active toc-link level2">条件跳转到计算目标</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Program_language/Assembly_language/fullerton_CSci241/Lecture5-branch.html#复合条件" class="router-link-active router-link-exact-active toc-link level2">复合条件</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Program_language/Assembly_language/fullerton_CSci241/Lecture5-branch.html#转换-c-c-结构" class="router-link-active router-link-exact-active toc-link level2">转换 C/C++ 结构</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Program_language/Assembly_language/fullerton_CSci241/Lecture5-branch.html#if-else-链" class="router-link-active router-link-exact-active toc-link level3">if-else 链</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Program_language/Assembly_language/fullerton_CSci241/Lecture5-branch.html#嵌套的-if-else" class="router-link-active router-link-exact-active toc-link level2">嵌套的 if-else</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Program_language/Assembly_language/fullerton_CSci241/Lecture5-branch.html#do-while循环" class="router-link-active router-link-exact-active toc-link level2">do-while循环</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Program_language/Assembly_language/fullerton_CSci241/Lecture5-branch.html#while-循环" class="router-link-active router-link-exact-active toc-link level2">while 循环</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Program_language/Assembly_language/fullerton_CSci241/Lecture5-branch.html#break和continue" class="router-link-active router-link-exact-active toc-link level2">break和continue</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Program_language/Assembly_language/fullerton_CSci241/Lecture5-branch.html#附录" class="router-link-active router-link-exact-active toc-link level2">附录</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/posts/Program_language/Assembly_language/fullerton_CSci241/Lecture5-branch.html#课程资源" class="router-link-active router-link-exact-active toc-link level3">课程资源</a></li><!----><!--]--></ul><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h1 id="第五讲-分支、条件、循环、函数" tabindex="-1"><a class="header-anchor" href="#第五讲-分支、条件、循环、函数" aria-hidden="true">#</a> 第五讲：分支、条件、循环、函数</h1><h2 id="算术运算" tabindex="-1"><a class="header-anchor" href="#算术运算" aria-hidden="true">#</a> 算术运算</h2><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>add dest, src       ; dest += src
sub dest, src       ; dest -= src
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>add</code>和<code>sub</code>在两个相同大小的操作数之间执行加法和减法。在内部，<code>sub</code> 也是使用加法实现，只是将第二个操作数执行取反再加1的操作。</p><h2 id="标记" tabindex="-1"><a class="header-anchor" href="#标记" aria-hidden="true">#</a> 标记</h2><p><code>add</code>和<code>sub</code> 会设置/取消设置 OF、SF、ZF、AF、CF 和 PF 标志：</p><ul><li>对于有符号运算，OF 标志指示发生了上溢/下溢。如果结果的符号位不正确，则设置该位，因为正确的结果对于目标来说太大/太小而无法保存。例如，有符号 127+127 将产生溢出。 （无符号 127+127 = 254 仍然可以容纳在无符号字节中，因此不会设置进位标志。） 结果的正确符号很容易确定：如果两个输入均为正，则结果应为正；如果两者均为负数，则结果应为负数。如果一个为正，另一个为负，那么结果的正确符号就更难确定，但在这种情况下事实证明这并不重要。正值和负值相加不可能溢出。减法的处理方式类似，只是第二个操作数的符号被翻转（即，a - b 被视为 a + (-b)）。 如果输入无符号，则 OF 标志仍会设置/取消设置，但其值毫无意义。</li><li>对于无符号运算，CF 标志表示末尾&quot;剩余&quot;了额外的进位/借位。这表明操作结果太大/太小而无法容纳目的地。例如，255+127 对于一个字节来说太大，并且会设置进位标志。它不会设置溢出标志，因为 255 无符号 = -1 有符号，而 127-1 = 126 适合有符号字节。 请注意，在无符号减法 a - b 之后，如果设置了进位标志(CF)，则表示 b &gt; a。</li><li>如果结果为 0（全零位），则设置 ZF 标志。</li><li>SF 标志设置为符号位的副本（对于有符号运算，如果结果为负则设置）。对于无符号运算，它只是结果高位的副本。</li><li>如果结果的低字节中设置的(=1)位的数量是奇数，则PF标志被设置。奇偶校验标志是历史产物，使用不多，部分原因是它不给出整个结果的奇偶校验，只给出它的最低字节。</li><li>我们将忽略 AF 标志，因为它仅在 BCD 算术上下文中有意义。</li></ul><p>请注意，所有标志都会在所有操作中设置/清除，但某些标志仅对有符号/无符号操作有意义。加/减指令不知道您是否正在执行有符号或无符号的操作，因此您需要确保检查正在执行的操作类型的正确标志。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code> <span class="token number">111</span>  <span class="token number">11</span>
   <span class="token number">10110011</span>   <span class="token operator">=</span> <span class="token number">179</span> <span class="token punctuation">(</span>unsigned<span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token parameter variable">-77</span> <span class="token punctuation">(</span>signed<span class="token punctuation">)</span>
 + 01100110   <span class="token operator">=</span> <span class="token number">102</span> <span class="token punctuation">(</span>unsigned<span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token number">102</span> <span class="token punctuation">(</span>signed<span class="token punctuation">)</span>
────────────
<span class="token number">1</span>  00011001   <span class="token operator">=</span>  <span class="token number">25</span> <span class="token punctuation">(</span>unsigned<span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token number">25</span>  <span class="token punctuation">(</span>signed<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>解释为有符号值时，一个输入为负，另一个输入为正，因此结果的符号保证是正确的。<code>OF= 0</code>。</li><li>解释为无符号，加法产生一个额外的进位，<code>CF = 1</code>。</li><li>结果不为 0，因此 ZF = 0。</li><li>结果中低字节为1的位数为奇数，因此 PF = 1</li><li>高位未置位（结果为正），因此 SF = 0。</li></ul><h2 id="递增和递减" tabindex="-1"><a class="header-anchor" href="#递增和递减" aria-hidden="true">#</a> 递增和递减</h2><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>inc dest    ; 类似于C/C++中的++dest
dec dest    ; 类似于C/C++中的--dest
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>inc</code> 和 <code>dec</code> 递增/递减其单个操作数，该操作数可以是寄存器或内存位置。 <code>inc</code> 和 <code>dec</code> 不会像 <code>add r, 1</code> 或 <code>sub r, 1</code> 指令那样修改进位标志。标志 OF、SF、ZF、AF 和 PF 按预期设置/清除。当用于有符号值时，行为仍然是正确的（增加负值使其更接近 0，减少负值使其更负）。</p><h2 id="大于-64-位的加法-减法" tabindex="-1"><a class="header-anchor" href="#大于-64-位的加法-减法" aria-hidden="true">#</a> 大于 64 位的加法/减法</h2><p>我们拥有的最大寄存器是 64 位 (qword)。如果我们想对 128 位操作数（表示为 <code>rdx:rax</code>）执行加法/减法怎么办？让我们考虑一下，如果我们本机可以执行的唯一加法是字节大小的，那么我们将如何执行字大小的加法：</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>     111111←   1111
   00101101 11001101
 + 00010010 10101011 
─────────────────────
   01000000 01111000  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>添加低字节会产生一个额外的进位 (CF = 1)，然后我们用它来开始添加高字节。我们实际上需要两种加法：</p><ul><li><p>低字节加法，不以进位开头（忽略CF）</p></li><li><p>高字节加法，使用CF开始加法。</p></li></ul><p>这就是我们执行大于qword加法的方式，还有另一种加法操作，add-with-carry，<code>adc</code>它使用进位标志CF的状态作为第一位加法的输入。</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>adc dest, src       ; dest = dest + src + CF
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>对于减法，有 sbb，subtract-with-borrow。</p><p>因此，要将双 qword rdx:rax 添加到 rcx:rbx，我们会这样做</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>add rax, rbx 
adc rdx, rcx
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>减法的类似物是 sbb，即借位减法。</p><p>试了下<a href="https://godbolt.org/z/xvreb39Kf" target="_blank" rel="noopener noreferrer">128bit加法<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>，对应的汇编中的确使用了<code>adc</code>指令进行128bit的加法。</p><h2 id="乘法和除法" tabindex="-1"><a class="header-anchor" href="#乘法和除法" aria-hidden="true">#</a> 乘法和除法</h2><p>乘法和除法比加法/减法更复杂。我们稍后将更详细地介绍它们，但现在：</p><ul><li>两个 n 位值相乘的结果最多可达 2n 位。因此，当将两个 qword 值相乘时，我们需要在某个地方存储双四字结果。</li><li>除法有相反的问题，我们可能想要将双 qword 值除以 qword 除数。</li><li>有符号乘法与无符号乘法不同，除法也类似。每个都使用不同的指令。</li><li>如您所料，乘法指令以双操作数形式 (dest *= src) 存在，但也以单操作数形式存在，其中 rax 寄存器隐式用作操作的目标，甚至是三操作数形式，相当于dest = src * 立即数。除法指令仅采用单个操作数，并且始终将其结果存储到 rax 和 rdx 的组合中。</li></ul><p>为了存储双 qword（128 位）结果，我们使用 rax 和 rdx 的组合：rax 存储低 qword，而 rdx 存储高 qword。我们将此组合写为 rdx:rax。 （使用类似的符号，我们可以说 ax = ah:al。）较小的乘法不需要此扩展。</p><p>无符号/有符号乘法指令分别为 <code>mul</code> 和 <code>imul</code></p><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td><code>mul rm</code></td><td>rdx:rax *= rm, unsigned</td></tr><tr><td>imul rm</td><td>rdx:rax *= rm, signed</td></tr><tr><td>imul r, rm</td><td>r *= rm, signed</td></tr><tr><td>imul r, rm, imm</td><td>r = rm * imm, signed</td></tr></tbody></table><p>如果结果的符号不正确，则 CF 和 OF 标志会一起设置/清除。如果乘法结果不适合目标，则结果将被截断（丢弃高位）。其他标志中的值未定义。</p><p>除法只有一个操作数形式，其中操作数包含除数；目的地（也是股息）位于 rdx:rax 中。 div/idiv 的结果既是 rax 中的向下舍入结果，也是 rdx 中的余数（即模或 %）。与 C++ 不同，在 C++ 中，我们用 / 表示整数除法，用 % 表示整数模，而在汇编中，一条指令就给出了两个结果。</p><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>div rm</td><td>rax = rdx:rax / rm and rdx = rdx:rax % rm, unsigned</td></tr><tr><td>idiv rm</td><td>rax = rdx:rax / rm and rdx = rdx:rax % rm, signed</td></tr></tbody></table><p>除法溢出不是通过设置进位标志来指示的，而是通过除法错误异常 #DE 来指示的，该异常作为信号 SIGFPE 发送到我们的进程</p><p>目前，这会立即使我们的程序崩溃，但稍后我们将看到如何编写信号处理程序以更优雅的方式处理它。 （当然，我们也可以通过在执行除法之前检查操作数来避免溢出。）</p><h2 id="函数-分支-和-条件指令" tabindex="-1"><a class="header-anchor" href="#函数-分支-和-条件指令" aria-hidden="true">#</a> 函数 分支 和 条件指令</h2><ul><li>分支（也称为跳转、goto 语句等）跳转到程序中的新位置</li><li>比较比较两个操作数，然后适当地设置标志寄存器。只有一条比较指令，它执行所有可能的比较（等于、小于、等于零等）</li><li>条件分支通常执行分支或继续执行下一条指令，具体取决于其中一个标志的状态（之前通过比较操作设置）。</li><li>条件移动是否执行移动取决于标志之一的状态。</li></ul><p>函数调用和返回只是操作堆栈的分支的特殊形式。</p><h2 id="汇编语言程序的结构" tabindex="-1"><a class="header-anchor" href="#汇编语言程序的结构" aria-hidden="true">#</a> 汇编语言程序的结构</h2><p>我们说过，汇编语言与 C/C++ 等语言的区别在于，汇编语言中的每一条“语句”（指令）都对应于一个 CPU 操作。相比之下，在C/C++中，单个语句在编译期间可能会生成许多操作。这意味着汇编不能像 C/C++ 那样有“条件语句”或“循环语句”；在 C/C++ 中，这些是复合语句，即其中包含其他语句的语句。这必然意味着 if-else 或 while 循环会生成多个 CPU 操作。因此，在汇编语言中，循环和条件的工作方式非常不同。</p><p>归根结底，汇编语言程序只是一系列指令。不同函数之间，或者循环或 if-else 的&quot;主体&quot;与编写它的函数的其余部分之间没有真正的划分。该程序只是一大堆指令，因此我们有责任对其强加一些结构。通常的编程语言结构——函数、条件、循环——是我们必须自己构建的东西。</p><p>汇编语言程序中的每条指令都有一个地址，即程序最终运行时它在内存中的最终位置。添加标签告诉汇编器这个地址（标签后面的指令的地址）很重要，重要到需要保存并命名。因此，当我们写:</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>_start:
  ...
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>_start</code> 的&quot;值&quot;是紧随其后的第一条指令的地址。对于本地标签（名称以 . 开头的标签）也是如此。</p><p>汇编语言程序中的正常控制流程很简单：每条指令都按从第一个到最后一个的顺序执行。 CPU 始终知道程序中“下一条”指令：它是紧接在该指令之后的指令。</p><p>汇编语言支持的唯一一种其他控制流是跳转到某个地址（由 CPU 通过更改指令指针寄存器 rip 的值来实现），而不是按照从头到尾的顺序运行指令。我们所有现有的流程控制结构（if-else、switch-case、while、do-while）都必须转换为这种原始概念，即在程序中向前跳过某些指令，或在程序中向后跳过，以便程序中的某些地址多次送入 CPU 执行指令。</p><h2 id="分支" tabindex="-1"><a class="header-anchor" href="#分支" aria-hidden="true">#</a> 分支</h2><p>分支通过跳转到新位置来工作。因为指令指针寄存器指向后面的寄存器，所以这不仅仅是改变rip的问题。它涉及将CPU重定向到新地址并将地址后的指令立即加载到rip中。幸运的是，这一切都是在幕后完成的。我们只提供跳转到的地址，通常以地址的形式。</p><h3 id="标签" tabindex="-1"><a class="header-anchor" href="#标签" aria-hidden="true">#</a> 标签</h3><p>跳转的目标必须是标签。标签由标识符后跟冒号组成：</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>Target:
    ...
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>本地标签是名称以句号开头的标签。本地标签的全名是本地标签名称中最新添加的非本地标签。例如:</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>my_function:
  ...
  .begin_loop:    ; Full name: my_function.begin_loop
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这允许我们拥有具有相同“名称”的多个标签，只要它们位于不同的函数/代码块中。</p><p>标签只是一个地址，即下一条指令的地址（或数据，如果在 .data 部分中使用）。</p><h2 id="跳转" tabindex="-1"><a class="header-anchor" href="#跳转" aria-hidden="true">#</a> 跳转</h2><p>要跳转到一个标签，请使用 <code>jmp</code> 指令：</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>jmp target
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>请注意，标签的值只是它在程序中的地址。因此，可以在寄存器中存储标签、跳转到寄存器等。</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>mov rax, Target 
jmp rax
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这有时称为<strong>计算跳转</strong>。例如，我们可以将一组标签存储在数组中（在 <code>.data</code> 部分），然后使用数组索引来确定要跳转到哪个标签。稍后将使用该技术来实现 <code>switch-case</code> 结构。</p><h2 id="比较" tabindex="-1"><a class="header-anchor" href="#比较" aria-hidden="true">#</a> 比较</h2><p>有两个比较指令，其中 cmp 是第一个也是最直接的；它需要两个操作数，并且两个操作数的大小必须相同。第一个操作数不能是立即数，但第二个操作数可以是。其中一个操作数可以位于内存中，但不能同时位于内存中。</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>cmp op1, op2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>比较指令在内部执行 op1 - op2 减法，丢弃结果，但相应地更新标志寄存器。例如，如果 op1 - op2 == 0，则零标志 ZF 将被设置；但如果 op1 - op2 == 0 则 op1 == op2，因此置零标志告诉我们原始操作数是相等的。类似地，如果 op1 &gt; op2，减法会设置进位标志。</p><h3 id="条件" tabindex="-1"><a class="header-anchor" href="#条件" aria-hidden="true">#</a> 条件</h3><p>可以使用标志的各种组合来确定 <code>sub a, b</code> 的两个操作数之间的关系：</p><ul><li><p>如果 <code>a == b</code> 则结果将为 0，这将设置 ZF = 1。因此我们可以通过查看零标志来检测相等性。 （ZF == 1 的条件代码是 e 或 z。）</p></li><li><p>如果 <code>a != b</code>, 那么结果将是非零的，因此 ZF == 0。（条件代码：<code>ne</code> 或 <code>nz</code>。）</p></li><li><p>如果 <code>a &gt; b</code>, 无符号， 那么结果是非零的, 并且不需要额外的进位/借位，因此 ZF == 0 且 CF == 0。</p></li><li><p>如果 <code>a &gt;= b</code>, 无符号，那么不需要额外的进位/借位（结果可能为零也可能不是），因此 CF == 0。（条件代码：ae, nc）</p></li><li><p>如果 <code>a &lt; b</code>，无符号，那么这只是 a &gt;= b 的否定，因此 CF == 1（需要额外借位）。 （条件代码：b、c）</p></li><li><p>如果，a &lt;= b，无符号，是 a &gt; b 的否定，因此 ZF == 1 或 CF == 1。（条件代码：be）</p></li><li><p>如果 <code>a &gt; b</code>，有符号，那么事情就更有趣了：我们知道结果不会为 0，因此 ZF == 0，但结果的其余部分取决于溢出标志和符号标志：</p><ul><li>如果a和b具有相同的符号，则<code>OF == 0</code>（不可能溢出）。如果 a &gt; b 且两者均为正，则结果将为正 (SF == 0)。如果两者均为负数，则结果也将为正数（例如，-2 &gt; -10、-2 - -10 = +8）。所以在这种情况下我们有 SF == OF。</li><li>如果 a 和 b 的符号不同，则可能发生溢出。如果 a &gt; -b 那么我们正在做 a - -b = a + b：</li></ul><ul><li>如果a + b没有溢出，则符号为正，所以SF == OF == 0</li><li>如果 a + b 确实溢出，则符号为负，但 OF == 1，所以我们有 OF == SF == 1</li></ul><p>不管怎样，我们再次得到 SF == OF。 因此，a &gt; b 有符号的最终条件是 ZF == 0 且 SF == OF。 （条件代码：g）</p></li><li><p>如果 a &gt;= b，有符号，那么我们只需忽略零标志：SF == OF。 （条件代码：ge）</p></li><li><p>a &lt; b 是 a &gt;= b 的否定，因此 SF != OF。 （条件代码：l）</p></li><li><p>a &lt;= b 是 a &gt; b 的否定，因此 ZF == 1 或 SF != OF。 （条件代码：le）</p></li></ul><p>这些条件代码中的每一个都将在稍后的条件跳转指令中使用。对于有符号比较，我们通常使用术语“小于”和“大于”；对于无符号比较，我们说“低于”和“高于”。</p><h3 id="内存与内存的比较" tabindex="-1"><a class="header-anchor" href="#内存与内存的比较" aria-hidden="true">#</a> 内存与内存的比较</h3><p><code>cmp</code> 指令无法比较内存中的两个操作数。 但是<code>cmps*</code> 系列指令可以比较内存中的两个操作数，第一个操作数位于 <code>[rsi]</code>，第二个操作数位于 <code>[rdi]</code>。</p><p><code>cmps*</code>的指令如下所示：</p><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td><code>cmpsb</code></td><td>比较 <code>byte [rsi]</code>和 <code>byte [rdi]</code></td></tr><tr><td><code>cmpsw</code></td><td>比较 <code>word [rsi]</code>和 <code>word [rdi]</code></td></tr><tr><td><code>cmpsd</code></td><td>比较 <code>dword [rsi]</code>和 <code>dword [rdi]</code></td></tr><tr><td><code>cmpsq</code></td><td>比较 <code>qword [rsi]</code>和 <code>qword [rdi]</code></td></tr></tbody></table><p><code>cmps*</code> 指令不带任何操作数；他们总是使用 <code>rsi</code> 和 <code>rdi</code>。</p><h2 id="test指令" tabindex="-1"><a class="header-anchor" href="#test指令" aria-hidden="true">#</a> <code>test</code>指令</h2><p><code>cmp</code> 指令的指令是 <code>test</code>。<code>cmp</code> 执行减法并更新与 <code>sub</code> 相同的标志，而 <code>test</code> 执行二进制 AND 并仅更新 SF、ZF 和 PF 标志。CF 和 OF 标志被清除。这意味着测试不能用于确定依赖于这些标志的任何条件（排序比较，例如大于、小于、高于、低于）或相等。因为它使用 AND 而不是减法，所以<code>test</code>的用途更加有限：</p><ul><li>如果寄存器等于0：</li></ul><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code> test reg, reg
 jz target          ; or je target, jump if ZF == 1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果一个数和自身相与，结果还是自身。因此结果等于0的唯一可能是 <code>reg = 0</code>。 <code>JE</code>和<code>JZ</code>仅在ZF == 1时跳跃。</p><ul><li><code>test reg, reg </code>还可用于确定寄存器的符号：如果 SF == 1 则 reg 为负数。因此，我们可以做：</li></ul><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>test reg, reg
js target
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果 reg &lt; 0，则跳转到目标。（如果 reg 无符号，则在设置高位时将跳转。）</p><ul><li><p>类似地，如果 reg &lt;= 0，测试 reg、reg 和 jle 将跳转，尽管要弄清楚为什么这样做需要做一些工作：</p><ul><li>如果 ZF == 1 或 SF != OF，则 jle 跳转</li><li>测试总是设置 OF = 0，所以这实际上是 ZF == 1 或 SF == 1</li><li>ZF == 1 是上面用于 reg == 0 的条件</li><li>SF == 1 是上面用于 reg &lt; 0 的条件</li><li>所以 ZF == 1 或 SF == 1 相当于 reg &lt;= 0 当然，只有当 reg 是有符号值时这才有意义</li></ul></li><li><p>test reg, 00000010b 可用于测试寄存器中是否设置了特定位（或位组合）。如果 AND 的结果为 0，则该位未被设置，且 ZF == 1；如果该位被设置，则 ZF == 0。所以我们可以这样做</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>test reg, 00000010b
jnz target              ; jump if bit 2 is set
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这可能是<code>test</code>的最主要的用途。</p></li></ul><p>test 的操作数受到一些限制：</p><ul><li><p>第二个操作数必须是寄存器或立即数，而不是内存位置。</p></li><li><p>第一个操作数可以是寄存器或内存</p></li><li><p>两者尺寸必须相同</p></li></ul><p>测试指令不会修改两个操作数；仅更改标志寄存器</p><h2 id="其他指令" tabindex="-1"><a class="header-anchor" href="#其他指令" aria-hidden="true">#</a> 其他指令</h2><p>请记住，许多其他指令都会设置标志寄存器。</p><h2 id="条件分支的指令" tabindex="-1"><a class="header-anchor" href="#条件分支的指令" aria-hidden="true">#</a> 条件分支的指令</h2><p>条件分支指令检查标志寄存器并跳转到目标或不跳转到目标。这些通常称为 jcc，其中 cc 是条件代码：</p><p>|操作|描述|标志位的状态| |<code>je</code>|当<code>op1 == op2</code>时跳转| <code>ZF == 1</code>| |<code>jne</code>|当<code>op1 != op2</code>时跳转| <code>ZF == 0</code>| |<code>jl</code>|当<code>op1 &lt; op2</code>时跳转， 针对有符号的数据比较|<code>SF != OF</code>| |<code>jle</code>|当<code>op1 &lt;= op2</code>时跳转， 针对有符号的数据比较|<code>ZF ==1 or SF != OF</code>| |<code>jg</code>|当<code>op1 &gt; op2</code>时进行跳转， 针对有符号的数据比较|<code>ZF == 0 &amp;&amp; SF ==OF</code>| |<code>jge</code>|当<code>op1 &gt;= op2</code>时进行跳转， 针对有符号的数据比较|<code>SF ==OF</code>| |<code>jb</code>|当<code>op1 &lt; op2</code>时进行跳转， 针对无符号的数据比较|<code>CF == 1</code>| |<code>jbe</code>|当<code>op1 &lt;= op2</code>时进行跳转， 针对无符号的数据比较|<code>CF == 1 or ZF == 1</code>| |<code>ja</code>|当<code>op1 &gt; op2</code>时进行跳转， 针对无符号的数据比较|<code>CF ==0 &amp;&amp; ZF == 0</code>| |<code>jae</code>|当<code>op1 &gt;= op2</code>时进行跳转， 针对无符号的数据比较|<code>CF == 0</code>|</p><p>对于无符号数据的比较，&quot;a&quot;是&quot;above&quot;的缩写， &quot;b&quot;是&quot;below&quot;的缩写。 对于有符号的比较， &quot;g&quot;是&quot;greater&quot;的缩写， &quot;l&quot;是&quot;less&quot;的缩写。&quot;e&quot;是&quot;equal&quot;的缩写。</p><p>对于那些因 C/C++ 没有否定比较（!&lt;, !&gt;=）而烦恼的人，会很高兴知道汇编将 <code>jnl</code>（不小于）作为 <code>jge</code> 的同义词。</p><p>下面是一些上述符号的同义词</p><p>|操作|描述| |<code>jna</code>|当<code>op1 &lt;= op2</code>时进行跳转， 针对无符号的数据比较| |<code>jnae</code>|当<code>op1 &lt; op2</code>时进行跳转， 针对无符号的数据比较| |<code>jnb</code>|当<code>op1 &gt;= op2</code>时进行跳转， 针对无符号的数据比较| |<code>jnbe</code>|当<code>op1 &gt; op2</code>时进行跳转， 针对无符号的数据比较| |<code>jng</code>|当<code>op1 &lt;= op2</code>时进行跳转， 针对有符号的数据比较| |<code>jnge</code>|当<code>op1 &lt; op2</code>时进行跳转， 针对有符号的数据比较| |<code>jnl</code>|当<code>op1 &gt;= op2</code>时进行跳转， 针对有符号的数据比较| |<code>jnle</code>|当<code>op1 &gt; op2</code>时进行跳转， 针对有符号的数据比较|</p><p>这些只是上述指令的别名（例如，<code>jna</code> 是 <code>jbe</code> 的别名）。</p><p>有一组跳转通过检查 <code>rcx</code> 寄存器来模拟循环操作：</p><table><thead><tr><th>操作</th><th>描述</th></tr></thead><tbody><tr><td>jcxz</td><td>Jump if cx == 0</td></tr><tr><td>jecxz</td><td>Jump if ecx == 0</td></tr><tr><td>jrcxz</td><td>Jump if rcx == 0</td></tr></tbody></table><p>请注意，如果 rcx 等于 0，则这些跳转，而如果 rcx 不等于 0，则循环跳转。</p><p>最后，有一组直接引用标志名称的半冗余条件</p><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>jc</td><td>Jump if CF == 1</td></tr><tr><td>jnc</td><td>Jump if CF == 0</td></tr><tr><td>jz</td><td>Jump if ZF == 1</td></tr><tr><td>jnz</td><td>Jump if ZF == 0</td></tr><tr><td>jo</td><td>Jump if OF == 1</td></tr><tr><td>jno</td><td>Jump if OF == 0</td></tr><tr><td>js</td><td>Jump if SF == 1</td></tr><tr><td>jns</td><td>Jump if SF == 0</td></tr><tr><td>jz</td><td>Jump if ZF == 1</td></tr><tr><td>jnz</td><td>Jump if ZF == 0</td></tr><tr><td>jp</td><td>Jump if PF == 1</td></tr><tr><td>jpo</td><td>Jump if PF == 1 (jump if parity odd)</td></tr><tr><td>jpe</td><td>Jump if PF == 0 (jump if parity even)</td></tr></tbody></table><h2 id="跳转目标" tabindex="-1"><a class="header-anchor" href="#跳转目标" aria-hidden="true">#</a> 跳转目标</h2><p>普通的<code>jmp</code>指令可以跳转到任意地址。条件跳转存储的是跳转目标距离当前指令的偏移量。偏移量是有符号 8 位或 32 位数值。在汇编语言中，我们编写一个标签，汇编器会计算相应的偏移量，写入指令中。</p><h2 id="条件跳转到计算目标" tabindex="-1"><a class="header-anchor" href="#条件跳转到计算目标" aria-hidden="true">#</a> 条件跳转到计算目标</h2><p>通过无条件跳转，可以很容易地跳转到寄存器定义的目标：</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>target:
...
mov rax, target
jmp rax
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为rax寄存器的值就是要跳转到的地址。由于条件跳转不使用绝对地址，而是使用当前地址的偏移量，因此计算条件跳转需要更多技巧。</p><p>最简单的方法是使条件跳转到固定目标，其中目标是到计算地址的普通跳转:</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>jcc my_jmp_target

  ⋮

my_jmp_target:  jmp rax
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此方法比理想慢一些，因为它涉及两次跳跃。更快的方法是计算最终的 jcc 指令和各个跳转目标之间的距离，然后将这些距离存储到某个寄存器中。由于这些距离在组装时是固定的，因此在运行时计算它们的效率很低。一般的策略是给条件跳转指令本身加上标签，这样我们就可以访问它的地址：</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>target1:

  ⋮
                mov rax, computed_jump - target1  ; Pick target to jump to
computed_jump:  jcc rax                           ; Jump 

  ⋮

target2:
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>mov</code> 当然是条件结构的一部分，它要么：</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>mov rax, computed_jump - target1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>或者</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>mov rax, computed_jump - target2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>取决于某些条件。我们还可以存储一个compated_jump - target1、compated_jump - target2等偏移量的数组，然后对其进行索引.</p><h2 id="复合条件" tabindex="-1"><a class="header-anchor" href="#复合条件" aria-hidden="true">#</a> 复合条件</h2><p>我们如何检查复合条件，例如 <code>rbx &gt;= 10 和 rbx &lt; 100</code>，并在复合条件为真时执行跳转？</p><ul><li>一种方法是执行多步跳转<div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>cmp rbx, 10
jge .step1
jmp .else

.rax_ge_0:
cmp rbx, 100
jnge .else

    ; rbx &gt;= 0 and rbx &lt; 100

.else:

    ; condition failed.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>除最后一个条件外，每个条件都需要自己的 cmp 和条件跳转。 （因为 cmp 在进行比较之前重置标志，所以您无法“组合”多个比较。）</p><p>这实际上相当于转换</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code> <span class="token keyword">if</span><span class="token punctuation">(</span>rbx <span class="token operator">&gt;=</span> <span class="token number">10</span> <span class="token operator">and</span> rbx <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
 <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>into</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code> <span class="token keyword">if</span><span class="token punctuation">(</span>rbx <span class="token operator">&gt;=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">if</span><span class="token punctuation">(</span>rbx <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>set** 检查特定条件标志（或标志组合）并将（字节）寄存器/内存设置为 1 或 0。然后可以使用正常和/或/非按位操作以及 z、nz 条件将它们组合起来可用于检查假/真。例如。，</li></ul><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code> cmp rbx, 10
 setge al
 cmp rbx, 100
 setl  ah
 and al, ah      ; Sets the zero flag if al &amp;&amp; ah == 0
 jz .outside

    ; Inside

 .outside:
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>set** 支持与条件跳转相同的一组条件代码</p><p>A range check like the above example actually has a simple version using subtraction:</p><p>sub rbx, 10 cmp rbx, 100 - 10 jae .outside ; Inside the range</p><p>.outside: ; Outside the range This works because if rbx &lt; 10 the subtraction will wrap around to a value, so values &lt; 10 and values &gt;= 100 will jump to .outside. This works assuming that rbx is unsigned.</p><p>Optimizing jumps Conditional jumps are expensive! (Unconditional jumps are more expensive than normal sequential control flow, but not as expensive as conditional jumps.) The processor does not know what instruction will be taken until it has examined the flags register, which means many of the optimizations it performs have to be delayed. The best way to optimize jumps is to minimize their usage: try to keep as much of your control flow sequential as possible. Beyond that, try to</p><p>Keep conditional jumps short, within +-127 bytes</p><p>Try to arrange conditional jumps so that the condition is usually false or usually true, not frequently alternating. The processor will try to do branch prediction, storing the choices made by a small number of jumps, but this functions best if conditional jumps are mostly consistent in their choices (i.e., if the “prediction” is correct most of the time).</p><p>For example, in a loop, the loop condition is true most of the time, and false only at the very end. The processor will learn this behavior and “guess” that the loop will repeat, so that most loop jumps will be fast. Only the final jump, out of the loop, will be slow, as that’s where the prediction fails.</p><p>Avoid conditional branches completely by using conditional moves (see below) or the setcc instruction.</p><p>SETcc and bool → int conversion Sometimes, in C/C++ we rely on the implicit conversion from bool → int to avoid writing an if/else. E.g., to count the number of negative values in an array we could do:</p><p>int c = 0; for(int* p = arr; p &lt; arr + size) c += (*p &lt; 0); This works because bool true converts to 1 (thus becoming c += 1) and false converts to 0 (becoming c += 0). This code is actually faster than the equivalent code:</p><p>int c = 0; for(int* p = arr; p &lt; arr + size) if(*p &gt; 0) ++c; because evaluating a conditional branch is slower for the CPU. To implement the above version, we can use the SETcc instruction, which sets a given (byte) register to 1 if the condition code cc is satisfied, or 0 if it is not. E.g., to increment rax only when rbx &gt; 0 we could do</p><p>mov rcx, 0</p><p>cmp rbx, 0 seta cl ; Set cl = 1 if rbx &gt; 0 add rax, rcx</p><h2 id="转换-c-c-结构" tabindex="-1"><a class="header-anchor" href="#转换-c-c-结构" aria-hidden="true">#</a> 转换 C/C++ 结构</h2><h3 id="if-else-链" tabindex="-1"><a class="header-anchor" href="#if-else-链" aria-hidden="true">#</a> if-else 链</h3><p>经典的 C/C++ <code>if-else</code> 结构如下所示：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">if</span><span class="token punctuation">(</span>condition1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// body1</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>condition2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// body2</span>
<span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// else body</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在汇编中没有直接<code>if-else</code>的语句。我们需要使用<strong>比较</strong>，<strong>条件跳转</strong>和<strong>无条件跳转</strong>来构建。</p><ul><li>每一个<code>if</code>语句都需要<code>cmp</code>或者<code>test</code>指令（如果if表达式比较复杂，不是简单的数值比较，那么可能需要多个<code>cmp</code>或者<code>test</code>）。如果条件为假则进行条件跳转。跳转目标是链中的下一个 if。</li><li>每个 if 的主体在最后的 else 结束后以无条件跳转到标签结束。</li><li>else 的主体不需要跳转，因为它直接跳转到下面的代码。</li></ul><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>cmp ...
jncc .elseif1 
  ; body 1

  jmp end_else

.elseif1:
cmp ...
jncc .elseif2
  ; body2

  jmp end_else

... ; other else-if comparisons and bodies

.else: 

  ; else body

.end_else:

...
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然，您应该尝试使用更具描述性的标签名称！</p><h2 id="嵌套的-if-else" tabindex="-1"><a class="header-anchor" href="#嵌套的-if-else" aria-hidden="true">#</a> 嵌套的 <code>if-else</code></h2><p>嵌套的 if-else，例如:</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">if</span><span class="token punctuation">(</span>rax <span class="token operator">==</span> rbx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>rbx <span class="token operator">&lt;</span> rcx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述的代码可以翻译成下面的汇编代码:</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>cmp rax, rbx      ; Or whatever you need for the outer condition
jne .end          ; Note: jump if NOT equal
cmp rbx, rcx      
jge .end

...               ; Actual body 

.end
...               ; Rest of program
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们依次测试每个条件，如果不满足条件，则跳转到嵌套 <code>if</code> 主体之后的标签。</p><h2 id="do-while循环" tabindex="-1"><a class="header-anchor" href="#do-while循环" aria-hidden="true">#</a> <code>do-while</code>循环</h2><p>在之前，我们已经学习过使用<code>loop</code>指令实现 <code>do-while</code> 循环的方式，只要您使用 <code>rcx</code> 作为循环变量，在循环中进行递减，当 <code>rcx == 0</code> 时循环结束。</p><p>通过条件跳转，我们可以构建一个更通用的 <code>do-while</code> 循环,在循坏开始时需要设置一个标签， 在循环结束时测试循环条件。</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>.do                 ; do {

  ...               ;   Loop body

  cmp rax, rbx      
  je .do            ; } while(rax == rbx);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="while-循环" tabindex="-1"><a class="header-anchor" href="#while-循环" aria-hidden="true">#</a> <code>while</code> 循环</h2><p>实现 while 循环需要在循环开始时测试循环条件，如果失败则可能跳到循环末尾。</p><p>因此，我们需要在循环的开头和循环的结尾都有一个标签。(循环开头的标签用于满足循环条件时进入循环， 循环结尾的标签用于循环条件不成立时跳出循环):</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>.while:         ; while(rax != rbx) {
  cmp rax, rbx
  je .end_whle

  ...           ;   Loop body

  jmp .while
.end_while:     ; }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>for</code> 循环只是一种特殊的 <code>while</code> 循环，例如</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">for</span><span class="token punctuation">(</span>rax <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> rax <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token operator">++</span>rax<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将会编译为：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>  xor rax, rax      ; rax = 0
.for:     
  cmp rax, 100
  jge .end_for

  ...               ; Loop body

  inc rax
  jmp .for
.end_for:
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="break和continue" tabindex="-1"><a class="header-anchor" href="#break和continue" aria-hidden="true">#</a> <code>break</code>和<code>continue</code></h2><p><code>break</code> 等价于跳转到循环结束后的位置。 <code>continue</code> 等价于跳转到循环开头的位置。常见的模式是:</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>if(condition)
  break; // Or continue
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这可以通过条件跳转到循环结尾/开头来完成；无需模拟整个 <code>if</code> 结构。</p><h2 id="附录" tabindex="-1"><a class="header-anchor" href="#附录" aria-hidden="true">#</a> 附录</h2><h3 id="课程资源" tabindex="-1"><a class="header-anchor" href="#课程资源" aria-hidden="true">#</a> 课程资源</h3><p>原文链接：<a href="https://staffwww.fullcoll.edu/aclifton/cs241/lecture-branching-comparisons.html" target="_blank" rel="noopener noreferrer">https://staffwww.fullcoll.edu/aclifton/cs241/lecture-branching-comparisons.html<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/vuepress-theme-hope/vuepress-theme-hope/edit/main/docs/posts/Program_language/Assembly_language/fullerton_CSci241/Lecture5-branch.md" rel="noopener noreferrer" target="_blank" aria-label="Edit this page on GitHub" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->Edit this page on GitHub<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: 119160524@qq.com">zgjsxx</span><!--]--><!--]--></div></div></footer><!----><div class="giscus-wrapper input-top" style="display:block;"><div style="text-align:center">Loading...</div></div><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer">Code Building</div><div class="copyright">Copyright © 2024 程序员小x</div></footer></div><!--]--><!----><!----><!--]--></div>
    <script type="module" src="/assets/app-ce69e733.js" defer></script>
  </body>
</html>
