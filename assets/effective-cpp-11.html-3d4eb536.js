import{_ as n,V as s,W as a,a0 as e}from"./framework-9a29aaa0.js";const p={},t=e(`<h1 id="effective-c-11-operator-处理自我赋值" tabindex="-1"><a class="header-anchor" href="#effective-c-11-operator-处理自我赋值" aria-hidden="true">#</a> effective c++ 11 operator= 处理自我赋值</h1><p>我们知道复制构造函数和赋值运算符的区别是赋值构造函数用于创建一个新的对象，而赋值运算符用于给一个已经存在的对象重新赋值。</p><p>因此赋值运算符就可能存在把自己赋值给自己的情况，本节就是专门讨论这个场景的。</p><h2 id="分析" tabindex="-1"><a class="header-anchor" href="#分析" aria-hidden="true">#</a> 分析</h2><p>本文介绍了三种办法来处理这个问题，其实作者后续不仅仅讨论了自我赋值的问题，还讨论了赋值运算符的<strong>异常安全问题</strong>。</p><p>第一种方法比较简单，既然operator=可能存在自我赋值的场景，那么我们便在进入赋值运算符的函数内部首先做一个&quot;证同测试&quot;。如果是同一个对象，就直接返回。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>Widget<span class="token operator">&amp;</span> Widget<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>

	<span class="token comment">// Identity test.</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>rhs <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">delete</span> pb<span class="token punctuation">;</span>
	pb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Bitmap</span><span class="token punctuation">(</span><span class="token operator">*</span>rhs<span class="token punctuation">.</span>pb<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第二种方法其实并不是在讨论&quot;证同测试&quot;的方法。而是在讨论异常安全性。 个人认为Scott Mayer的书有这样的特点，它不像是一本教科书，而是像一本杂谈。 可能聊到某个话题的时候，可能也和另一个话题有关系，就也会谈一谈。</p><p>我们注意方法一中剩下拷贝的代码。如果<code>new Bitmap</code>出现异常，那么原来对象的pb指向的对象就已经被删除了。这是不能忍受的。后面在item-29中专门讨论异常安全性的时候会提到，异常安全性就类似于数据库的&quot;回滚&quot;机制，当操作失败时，需要恢复到执行之前的样子。显然上面的代码在这方面是有问题的。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>	<span class="token keyword">delete</span> pb<span class="token punctuation">;</span>
	pb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Bitmap</span><span class="token punctuation">(</span><span class="token operator">*</span>rhs<span class="token punctuation">.</span>pb<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>修改方法也很简单，即使先将原来的pb指针保存起来。只有当new成功了之后，再将原来的指针指向的对象删除。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>Widget<span class="token operator">&amp;</span> Widget<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	Bitmap<span class="token operator">*</span> pOrig <span class="token operator">=</span> pb<span class="token punctuation">;</span>
	pb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Bitmap</span><span class="token punctuation">(</span><span class="token operator">*</span>rhs<span class="token punctuation">.</span>pb<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">delete</span> pOrig<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第三种方法其实也是在讨论异常安全性，只不过在代码上更加简洁，其使用了copy-and-swap的思想。首先将Widget对象拷贝给对象temp，接着将temp和当前的对象进行交换。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>Widget<span class="token operator">&amp;</span> Widget<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">// Copy constructor: make copy of rhs data.</span>
	Widget <span class="token function">temp</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">swap</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Widget<span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><ul><li>确保当对象自我赋值时operator=有良好行为。其中技术包括比较&quot;来源对象&quot;和&quot;目标对象&quot;的地址、精心周到的语句顺序，以及copy-and-swap。</li><li>确定任何函数做过操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。</li></ul>`,16),o=[t];function c(i,l){return s(),a("div",null,o)}const u=n(p,[["render",c],["__file","effective-cpp-11.html.vue"]]);export{u as default};
