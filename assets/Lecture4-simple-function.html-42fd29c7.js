const e=JSON.parse('{"key":"v-ffc0fe0c","path":"/posts/Program_language/Assembly_language/fullerton_CSci241/Lecture4-simple-function.html","title":"","lang":"zh-CN","frontmatter":{"description":"简单的函数 正如我们稍后将看到的，从汇编调用 C 函数，或者使我们的汇编函数可从 C/C++ 调用，需要一些额外的步骤来正确设置堆栈。然而，只要我们纯粹停留在\\"汇编领域\\"，我们就不需要担心额外的复杂性；我们基本上可以让函数按照我们喜欢的方式工作。唯一的要求是我们能够从函数返回并回到原来的位置。 处理函数的两条指令是call和ret。两者都在内部使用堆栈： call 接受一个地址（.text 部分中的标签）并执行两个步骤：将 rip（指令指针）压入堆栈，然后跳转到给定的地址。请记住，rip 指向要执行的下一条指令，因此压入堆栈的值实际上是函数的返回地址，即函数返回时应恢复执行的地址。 ret 弹出栈顶元素并跳转到该元素。 rip 自动更新为以下指令。","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/Program_language/Assembly_language/fullerton_CSci241/Lecture4-simple-function.html"}],["meta",{"property":"og:site_name","content":"Code Building"}],["meta",{"property":"og:description","content":"简单的函数 正如我们稍后将看到的，从汇编调用 C 函数，或者使我们的汇编函数可从 C/C++ 调用，需要一些额外的步骤来正确设置堆栈。然而，只要我们纯粹停留在\\"汇编领域\\"，我们就不需要担心额外的复杂性；我们基本上可以让函数按照我们喜欢的方式工作。唯一的要求是我们能够从函数返回并回到原来的位置。 处理函数的两条指令是call和ret。两者都在内部使用堆栈： call 接受一个地址（.text 部分中的标签）并执行两个步骤：将 rip（指令指针）压入堆栈，然后跳转到给定的地址。请记住，rip 指向要执行的下一条指令，因此压入堆栈的值实际上是函数的返回地址，即函数返回时应恢复执行的地址。 ret 弹出栈顶元素并跳转到该元素。 rip 自动更新为以下指令。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-27T06:02:34.000Z"}],["meta",{"property":"article:modified_time","content":"2024-02-27T06:02:34.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-02-27T06:02:34.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"简单的函数","slug":"简单的函数","link":"#简单的函数","children":[{"level":3,"title":"函数指针","slug":"函数指针","link":"#函数指针","children":[]}]},{"level":2,"title":"附录","slug":"附录","link":"#附录","children":[]}],"git":{"createdTime":1709013754000,"updatedTime":1709013754000,"contributors":[{"name":"zgjsxx","email":"119160524@qq.com","commits":1}]},"readingTime":{"minutes":2.6,"words":779},"filePathRelative":"posts/Program_language/Assembly_language/fullerton_CSci241/Lecture4-simple-function.md","localizedDate":"2024年2月27日","excerpt":"<h2> 简单的函数</h2>\\n<p>正如我们稍后将看到的，从汇编调用 C 函数，或者使我们的汇编函数可从 C/C++ 调用，需要一些额外的步骤来正确设置堆栈。然而，只要我们纯粹停留在\\"汇编领域\\"，我们就不需要担心额外的复杂性；我们基本上可以让函数按照我们喜欢的方式工作。唯一的要求是我们能够从函数返回并回到原来的位置。</p>\\n<p>处理函数的两条指令是call和ret。两者都在内部使用堆栈：</p>\\n<ul>\\n<li>\\n<p>call 接受一个地址（.text 部分中的标签）并执行两个步骤：将 rip（指令指针）压入堆栈，然后跳转到给定的地址。请记住，rip 指向要执行的下一条指令，因此压入堆栈的值实际上是函数的返回地址，即函数返回时应恢复执行的地址。</p>\\n</li>\\n<li>\\n<p>ret 弹出栈顶元素并跳转到该元素。 rip 自动更新为以下指令。</p>\\n</li>\\n</ul>","autoDesc":true}');export{e as data};
