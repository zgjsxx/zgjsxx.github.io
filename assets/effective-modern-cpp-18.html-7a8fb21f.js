const e=JSON.parse('{"key":"v-694ee73e","path":"/posts/Program_language/cpp/effective-modern-cpp/effective-modern-cpp-18.html","title":"","lang":"zh-CN","frontmatter":{"category":["C++"],"tag":["effective modern c++读书笔记"],"description":"总而言之，C++11对于特殊成员函数处理的规则如下： 默认构造函数：和C++98规则相同，仅当类不存在用户声明的构造函数时才自动生成。 析构函数：基本上和C++98相同；稍微不同的是现在析构函数默认noexcept，和C++98一样，仅当基类析构为虚函数，派生类的析构函数才是虚的。 复制构造函数：和C++98运行时行为一样：按成员进行非静态数据成员的复制构造。仅当类中不包含用户声明的复制构造时才生成。如果该类声明了移动操作，则复制构造函数将被删除。当已经存在复制赋值运算符或析构函数时，仍然生成复制构造函数已经成为了被废弃的行为。","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/Program_language/cpp/effective-modern-cpp/effective-modern-cpp-18.html"}],["meta",{"property":"og:site_name","content":"Code Building"}],["meta",{"property":"og:description","content":"总而言之，C++11对于特殊成员函数处理的规则如下： 默认构造函数：和C++98规则相同，仅当类不存在用户声明的构造函数时才自动生成。 析构函数：基本上和C++98相同；稍微不同的是现在析构函数默认noexcept，和C++98一样，仅当基类析构为虚函数，派生类的析构函数才是虚的。 复制构造函数：和C++98运行时行为一样：按成员进行非静态数据成员的复制构造。仅当类中不包含用户声明的复制构造时才生成。如果该类声明了移动操作，则复制构造函数将被删除。当已经存在复制赋值运算符或析构函数时，仍然生成复制构造函数已经成为了被废弃的行为。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-09-06T08:48:05.000Z"}],["meta",{"property":"article:tag","content":"effective modern c++读书笔记"}],["meta",{"property":"article:modified_time","content":"2023-09-06T08:48:05.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-09-06T08:48:05.000Z\\",\\"author\\":[]}"]]},"headers":[],"git":{"createdTime":1693990085000,"updatedTime":1693990085000,"contributors":[{"name":"zgjsxx","email":"119160524@qq.com","commits":1}]},"readingTime":{"minutes":1.37,"words":411},"filePathRelative":"posts/Program_language/cpp/effective-modern-cpp/effective-modern-cpp-18.md","localizedDate":"2023年9月6日","excerpt":"<p>总而言之，C++11对于特殊成员函数处理的规则如下：</p>\\n<ul>\\n<li>\\n<p>默认构造函数：和C++98规则相同，仅当类不存在用户声明的构造函数时才自动生成。</p>\\n</li>\\n<li>\\n<p>析构函数：基本上和C++98相同；稍微不同的是现在析构函数默认noexcept，和C++98一样，仅当基类析构为虚函数，派生类的析构函数才是虚的。</p>\\n</li>\\n<li>\\n<p>复制构造函数：和C++98运行时行为一样：按成员进行非静态数据成员的复制构造。仅当类中不包含用户声明的复制构造时才生成。如果该类声明了移动操作，则复制构造函数将被删除。当已经存在复制赋值运算符或析构函数时，仍然生成复制构造函数已经成为了被废弃的行为。</p>\\n</li>\\n</ul>","autoDesc":true}');export{e as data};
