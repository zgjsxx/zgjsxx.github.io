const t=JSON.parse('{"key":"v-d7de0cbe","path":"/posts/Program_language/cpp/effective-cpp/effective-cpp-03.html","title":"effective c++ 03 尽可能使用const","lang":"zh-CN","frontmatter":{"category":["C++"],"tag":["C++","effective c++读书笔记"],"description":"effective c++ 03 尽可能使用const 在本节中，作者建议我们要尽可能使用const， 这样可以尽可能在编译期暴露一些问题。 分析 在可以使用const的地方尽量使用const，可以避免很多错误 const可被用在下面的场景： 任何作用域的对象 函数参数 函数返回值类型 成员函数本体 如果在const函数内部需要修改成员变量， 则需要使用mutable 编译器通常是bitwise constness，即const成员函数内不能修改任何一个bit。然而现实中，有时候我们需要logical constness,即一个const成员函数可以修改它所处理的对象内的某些bits。 这个时候就需要使用mutable。","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/Program_language/cpp/effective-cpp/effective-cpp-03.html"}],["meta",{"property":"og:site_name","content":"Code Building"}],["meta",{"property":"og:title","content":"effective c++ 03 尽可能使用const"}],["meta",{"property":"og:description","content":"effective c++ 03 尽可能使用const 在本节中，作者建议我们要尽可能使用const， 这样可以尽可能在编译期暴露一些问题。 分析 在可以使用const的地方尽量使用const，可以避免很多错误 const可被用在下面的场景： 任何作用域的对象 函数参数 函数返回值类型 成员函数本体 如果在const函数内部需要修改成员变量， 则需要使用mutable 编译器通常是bitwise constness，即const成员函数内不能修改任何一个bit。然而现实中，有时候我们需要logical constness,即一个const成员函数可以修改它所处理的对象内的某些bits。 这个时候就需要使用mutable。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-05-21T02:56:53.000Z"}],["meta",{"property":"article:tag","content":"C++"}],["meta",{"property":"article:tag","content":"effective c++读书笔记"}],["meta",{"property":"article:modified_time","content":"2023-05-21T02:56:53.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"effective c++ 03 尽可能使用const\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-05-21T02:56:53.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"分析","slug":"分析","link":"#分析","children":[{"level":3,"title":"在可以使用const的地方尽量使用const，可以避免很多错误","slug":"在可以使用const的地方尽量使用const-可以避免很多错误","link":"#在可以使用const的地方尽量使用const-可以避免很多错误","children":[]},{"level":3,"title":"如果在const函数内部需要修改成员变量， 则需要使用mutable","slug":"如果在const函数内部需要修改成员变量-则需要使用mutable","link":"#如果在const函数内部需要修改成员变量-则需要使用mutable","children":[]},{"level":3,"title":"当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复","slug":"当const和non-const成员函数有着实质等价的实现时-令non-const版本调用const版本可避免代码重复","link":"#当const和non-const成员函数有着实质等价的实现时-令non-const版本调用const版本可避免代码重复","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1683788312000,"updatedTime":1684637813000,"contributors":[{"name":"zgjsxx","email":"119160524@qq.com","commits":4}]},"readingTime":{"minutes":2.08,"words":625},"filePathRelative":"posts/Program_language/cpp/effective-cpp/effective-cpp-03.md","localizedDate":"2023年5月11日","excerpt":"<h1> effective c++ 03 尽可能使用const</h1>\\n<p>在本节中，作者建议我们要尽可能使用const， 这样可以尽可能在编译期暴露一些问题。</p>\\n<h2> 分析</h2>\\n<h3> 在可以使用const的地方尽量使用const，可以避免很多错误</h3>\\n<p>const可被用在下面的场景：</p>\\n<ul>\\n<li>任何作用域的对象</li>\\n<li>函数参数</li>\\n<li>函数返回值类型</li>\\n<li>成员函数本体</li>\\n</ul>\\n<h3> 如果在const函数内部需要修改成员变量， 则需要使用mutable</h3>\\n<p>编译器通常是bitwise constness，即const成员函数内不能修改任何一个bit。然而现实中，有时候我们需要logical constness,即一个const成员函数可以修改它所处理的对象内的某些bits。 这个时候就需要使用mutable。</p>","autoDesc":true}');export{t as data};
