import{_ as t,V as p,W as c,X as n,Y as a,$ as e,a0 as o,F as i}from"./framework-9a29aaa0.js";const l={},u=o(`<h1 id="原子变量的底层实现原理" tabindex="-1"><a class="header-anchor" href="#原子变量的底层实现原理" aria-hidden="true">#</a> 原子变量的底层实现原理</h1><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> value  <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">__sync_fetch_and_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>value<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-s line-numbers-mode" data-ext="s"><pre class="language-s"><code>        .file   &quot;test2.cpp&quot;
        .text
        .globl  main
        .type   main, @function
main:
.LFB0:
        .cfi_startproc
        pushq   %rbp
        .cfi_def_cfa_offset 16
        .cfi_offset 6, -16
        movq    %rsp, %rbp
        .cfi_def_cfa_register 6
        movl    $0, -4(%rbp)
        lock addl       $1, -4(%rbp)
        movl    $0, %eax
        popq    %rbp
        .cfi_def_cfa 7, 8
        ret
        .cfi_endproc
.LFE0:
        .size   main, .-main
        .ident  &quot;GCC: (GNU) 11.3.1 20221121 (Red Hat 11.3.1-4)&quot;
        .section        .note.GNU-stack,&quot;&quot;,@progbits

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//n++</span>
type <span class="token function">__sync_fetch_and_add</span> <span class="token punctuation">(</span>type <span class="token operator">*</span>ptr<span class="token punctuation">,</span> type value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//m + n</span>
type <span class="token function">__sync_fetch_and_sub</span> <span class="token punctuation">(</span>type <span class="token operator">*</span>ptr<span class="token punctuation">,</span> type value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//m - n</span>
type <span class="token function">__sync_fetch_and_or</span> <span class="token punctuation">(</span>type <span class="token operator">*</span>ptr<span class="token punctuation">,</span> type value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//m | n</span>
type <span class="token function">__sync_fetch_and_and</span> <span class="token punctuation">(</span>type <span class="token operator">*</span>ptr<span class="token punctuation">,</span> type value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//m &amp; n</span>
type <span class="token function">__sync_fetch_and_xor</span> <span class="token punctuation">(</span>type <span class="token operator">*</span>ptr<span class="token punctuation">,</span> type value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//m ^ n</span>
type <span class="token function">__sync_fetch_and_nand</span> <span class="token punctuation">(</span>type <span class="token operator">*</span>ptr<span class="token punctuation">,</span> type value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//(!m)&amp; n</span>

<span class="token comment">//++n</span>
type <span class="token function">__sync_add_and_fetch</span> <span class="token punctuation">(</span>type <span class="token operator">*</span>ptr<span class="token punctuation">,</span> type value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//m + n</span>
type <span class="token function">__sync_sub_and_fetch</span> <span class="token punctuation">(</span>type <span class="token operator">*</span>ptr<span class="token punctuation">,</span> type value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//m - n</span>
type <span class="token function">__sync_or_and_fetch</span> <span class="token punctuation">(</span>type <span class="token operator">*</span>ptr<span class="token punctuation">,</span> type value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//m | n</span>
type <span class="token function">__sync_and_and_fetch</span> <span class="token punctuation">(</span>type <span class="token operator">*</span>ptr<span class="token punctuation">,</span> type value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//m &amp; n</span>
type <span class="token function">__sync_xor_and_fetch</span> <span class="token punctuation">(</span>type <span class="token operator">*</span>ptr<span class="token punctuation">,</span> type value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//m ^ n</span>
type <span class="token function">__sync_nand_and_fetch</span> <span class="token punctuation">(</span>type <span class="token operator">*</span>ptr<span class="token punctuation">,</span> type value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//(!m)&amp; n</span>

<span class="token comment">//CAS类</span>
<span class="token function">bool__sync_bool_compare_and_swap</span><span class="token punctuation">(</span>type<span class="token operator">*</span> ptr<span class="token punctuation">,</span> type oldval<span class="token punctuation">,</span> type newval<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
type <span class="token function">__sync_val_compare_and_swap</span><span class="token punctuation">(</span>type<span class="token operator">*</span> ptr<span class="token punctuation">,</span> type oldval<span class="token punctuation">,</span> type newval<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/*
对应的伪代码
{if (*ptr == oldval) { *ptr = newval; returntrue; } else { returnfalse; }}
{if (*ptr == oldval) { *ptr = newval; }returnoldval; }
*/</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="lock指令" tabindex="-1"><a class="header-anchor" href="#lock指令" aria-hidden="true">#</a> Lock指令</h2><blockquote><p>User level locks involve utilizing the atomic instructions of processor to atomically update a memory space. The atomic instructions involve utilizing a lock prefix on the instruction and having the destination operand assigned to a memory address. The following instructions can run atomically with a lock prefix on current Intel processors: ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, and XCHG. EnterCriticalSection utilizes atomic instructions to attempt to get a user-land lock before jumping into the kernel. On most instructions a lock prefix must be explicitly used except for the xchg instruction where the lock prefix is implied if the instruction involves a memory address.</p></blockquote><blockquote><p>In the days of Intel 486 processors, the lock prefix used to assert a lock on the bus along with a large hit in performance. Starting with the Intel Pentium Pro architecture, the bus lock is transformed into a cache lock. A lock will still be asserted on the bus in the most modern architectures if the lock resides in uncacheable memory or if the lock extends beyond a cache line boundary splitting cache lines.</p></blockquote><blockquote><p>Both of these scenarios are unlikely, so most lock prefixes will be transformed into a cache lock which is much less expensive.</p></blockquote><h2 id="锁总线" tabindex="-1"><a class="header-anchor" href="#锁总线" aria-hidden="true">#</a> 锁总线</h2><h2 id="锁cache" tabindex="-1"><a class="header-anchor" href="#锁cache" aria-hidden="true">#</a> 锁cache</h2><h2 id="参考文章" tabindex="-1"><a class="header-anchor" href="#参考文章" aria-hidden="true">#</a> 参考文章</h2>`,11),r={href:"https://www.cnblogs.com/cnblogs-wangzhipeng/p/12549179.html",target:"_blank",rel:"noopener noreferrer"},d={href:"https://stackoverflow.com/questions/14758088/how-are-atomic-operations-implemented-at-a-hardware-level",target:"_blank",rel:"noopener noreferrer"};function m(k,v){const s=i("ExternalLinkIcon");return p(),c("div",null,[u,n("p",null,[n("a",r,[a("https://www.cnblogs.com/cnblogs-wangzhipeng/p/12549179.html"),e(s)])]),n("p",null,[n("a",d,[a("https://stackoverflow.com/questions/14758088/how-are-atomic-operations-implemented-at-a-hardware-level"),e(s)])])])}const h=t(l,[["render",m],["__file","atomic-principle.html.vue"]]);export{h as default};
