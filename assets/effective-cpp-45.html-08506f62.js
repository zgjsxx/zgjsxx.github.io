import{_ as s,V as a,W as n,a0 as p}from"./framework-9a29aaa0.js";const e={},t=p(`<h1 id="effective-c-45-运用成员函数模板接受所有兼容类型" tabindex="-1"><a class="header-anchor" href="#effective-c-45-运用成员函数模板接受所有兼容类型" aria-hidden="true">#</a> effective c++ 45 运用成员函数模板接受所有兼容类型</h1><p>Item 13提到智能指针可用来自动释放堆中的内存，STL中的迭代器也是一种智能指针，它甚至支持链表元素指针的++操作。 这些高级特性是普通指针所没有的。本文以智能指针为例，介绍成员函数模板的使用：</p><ul><li>成员函数模板可以使得函数可以接受所有兼容的类型。</li><li>如果你用成员函数模板声明了拷贝构造函数和赋值运算符，仍然需要手动编写普通拷贝构造函数和拷贝运算符。</li></ul><p><strong>隐式类型转换</strong></p><p>智能指针虽然比普通指针提供了更多有用的特性，但也存在一些问题，比如我们有一个类的层级：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Top</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Middle</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Top</span></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Bottom</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Middle</span></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>普通指针可以做到派生类指针隐式转换为基类指针：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>Top <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token keyword">new</span> Bottom<span class="token punctuation">;</span>
<span class="token keyword">const</span> Top <span class="token operator">*</span>p2 <span class="token operator">=</span> p1<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>但如果是智能指针，比如我们实现了SmartPtr，我们则需要让下面代码经过编译：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>SmartPtr<span class="token operator">&lt;</span>Top<span class="token operator">&gt;</span> p1 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">SmartPtr</span><span class="token generic class-name"><span class="token operator">&lt;</span>Bottom<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> Bottom<span class="token punctuation">)</span><span class="token punctuation">;</span>
SmartPtr<span class="token operator">&lt;</span><span class="token keyword">const</span> Top<span class="token operator">&gt;</span> p2 <span class="token operator">=</span> p1<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>同一模板的不同实例之间是没有继承关系的，在编译器看来<code>AutoPtr&lt;Top&gt;</code>和<code>AutoPtr&lt;Bottom&gt;</code>是完全不同的两个类。 所以上述代码直接编译是有问题的。</p><p><strong>重载构造函数</strong></p><p>为了支持用<code>SmartPtr&lt;Bottom&gt;</code>初始化<code>SmartPtr&lt;Top&gt;</code>，我们需要重载SmartPtr的构造函数。 原则上讲，有多少类的层级我们就需要写多少个重载函数。因为类的层级是会扩展的，因此需要重载的函数数目是无穷的。 这时便可以引入成员函数模板了：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">SmartPtr</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
    <span class="token function">SmartPtr</span><span class="token punctuation">(</span><span class="token keyword">const</span> SmartPtr<span class="token operator">&lt;</span>U<span class="token operator">&gt;</span><span class="token operator">&amp;</span> other<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意该构造函数没有声明为explicit，是为了与普通指针拥有同样的使用风格。子类的普通指针可以通过隐式类型转换变成基类指针。</p><p>接受同一模板的其他实例的构造函数被称为通用构造函数（generalized copy constructor）。</p><p><strong>兼容类型检查</strong></p><p>事实上，通用构造函数提供了更多的功能。他可以把一个<code>SmartPtr&lt;Top&gt;</code>隐式转换为<code>SmartPtr&lt;Bottom&gt;</code>，把一个<code>SmartPtr&lt;int&gt;</code>转换为<code>SmartPtr&lt;double&gt;</code>。 但普通指针是不允许这些隐式转换的。因此我们需要把它们禁用掉。注意一下通用构造函数的实现方式便可以解决这个问题：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">SmartPtr</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
    <span class="token function">SmartPtr</span><span class="token punctuation">(</span><span class="token keyword">const</span> SmartPtr<span class="token operator">&lt;</span>U<span class="token operator">&gt;</span><span class="token operator">&amp;</span> other<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">ptr</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    T<span class="token operator">*</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span> <span class="token keyword">return</span> ptr<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    T <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<code>ptr(other.get())</code>时编译器会进行类型的兼容性检查，只有当U可以隐式转换为T时，<code>SmartPtr&lt;U&gt;</code>才可以隐式转换为<code>SmartPtr&lt;T&gt;</code>。 这样就避免了不兼容指针的隐式转换。</p><p>其他使用方式</p><p>除了隐式类型转换，成员函数模板还有别的用途，例如赋值运算符。下面是shared_ptr的部分源码：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> 
<span class="token keyword">class</span> <span class="token class-name">shared_ptr</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Y</span><span class="token operator">&gt;</span>
        <span class="token keyword">explicit</span> <span class="token function">shared_ptr</span><span class="token punctuation">(</span>Y <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Y</span><span class="token operator">&gt;</span>
        shared_ptr<span class="token operator">&lt;</span>shared_ptr<span class="token operator">&lt;</span>Y<span class="token operator">&gt;</span> <span class="token keyword">const</span><span class="token operator">&amp;</span> r<span class="token operator">&gt;</span><span class="token punctuation">;</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Y</span><span class="token operator">&gt;</span>
        shared_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>Y<span class="token operator">&gt;</span> <span class="token keyword">const</span><span class="token operator">&amp;</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到普通指针Y*到<code>shared_ptr&lt;Y&gt;</code>声明了explicit，需要显式的类型转换；而<code>shared_ptr&lt;Y&gt;</code>之间只需要隐式转换。 使用拷贝构造函数模板存在一个问题：编译器是会生成默认的拷贝构造函数？还是会从你的模板实例化一个拷贝构造函数？ 即Y == T场景下的编译器行为。</p><p>事实上，成员函数模板不会改变C++的规则。C++规则讲：如果你没有声明拷贝构造函数，那么编译器应该生成一个。 所以Y == T时拷贝构造函数不会从成员函数模板实例化，而是会自己生成一个。</p><p>所以shared_ptr模板中还是手动声明了拷贝构造函数：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">shared_ptr</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">shared_ptr</span><span class="token punctuation">(</span>shared_ptr <span class="token keyword">const</span><span class="token operator">&amp;</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Y</span><span class="token operator">&gt;</span>
        <span class="token function">shared_ptr</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>Y<span class="token operator">&gt;</span> <span class="token keyword">const</span><span class="token operator">&amp;</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>

    shared_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>shared_ptr <span class="token keyword">const</span><span class="token operator">&amp;</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Y</span><span class="token operator">&gt;</span>
        shared_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>Y<span class="token operator">&gt;</span> <span class="token keyword">const</span><span class="token operator">&amp;</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><ul><li>请使用成员函数模板生成可接受所有兼容类型的函数。</li><li>如果你声明member templates用于&quot;泛化copy构造&quot;或&quot;泛化assignment操作&quot;，你还是需要声明正常的copy构造函数和copy assignment操作符。</li></ul>`,29),o=[t];function c(l,r){return a(),n("div",null,o)}const k=s(e,[["render",c],["__file","effective-cpp-45.html.vue"]]);export{k as default};
