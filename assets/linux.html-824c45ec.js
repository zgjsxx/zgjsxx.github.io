import{_ as l,V as e,W as o,a0 as i}from"./framework-9a29aaa0.js";const c={},r=i('<h1 id="linux" tabindex="-1"><a class="header-anchor" href="#linux" aria-hidden="true">#</a> Linux</h1><h2 id="介绍几个gcc的优化参数" tabindex="-1"><a class="header-anchor" href="#介绍几个gcc的优化参数" aria-hidden="true">#</a> 介绍几个GCC的优化参数</h2><p>以下是一些常用的GCC优化参数：</p><ul><li>-O0禁用所有优化，编译速度最快，但代码运行速度最慢。</li><li>-O1启用基本优化，编译速度适中，代码运行速度适度提升。</li><li>-O3启用所有可用优化，编译速度最慢，代码运行速度最快。</li><li>-Os优化代码大小，编译速度较快，代码运行速度略微提升。</li><li>-0g优化调试体验，编译速度适中，代码运行速度略微提升。</li></ul><p>其他常见优化参数：</p><ul><li>-march=指定目标体系架构，例如<code>-march=native</code>使用当前机器的最佳指令集</li><li>-mtune=指定目标处理器，例如<code>-mtune=corei7</code>使用针对Corei7处理器的优化。</li><li>-format-frame-pointer省略帧指针，减少代码大小，但可能影响测试。</li><li>-finline-functions内联函数，减少函数调用开销</li><li>-fno-builtin禁用内建函数，例如memcpy、strlen等。</li></ul><p><code>-march</code>和<code>-mtune</code>的区别：</p><ul><li><p>如果您使用 <code>-march</code>，那么 GCC 将可以自由生成在指定 CPU 上运行的指令，但（通常）不能在架构系列中的早期 CPU 上运行。</p></li><li><p>如果您只使用 <code>-mtune</code>，那么编译器将生成适用于其中任何一个的代码，但会优先考虑在您指定的特定 CPU 上运行速度最快的指令序列。例如为该 CPU 适当地设置循环展开启发式。</p></li></ul><p>一般来说，这两个参数会这样使用，使得代码在旧版本的CPU上能够运行，同时在当前CPU上运行可以得到优化:</p><ul><li><code>-march=&lt;您想要运行的最老的 CPU&gt;</code></li><li><code>-mtune=generic</code></li></ul><h2 id="在shell中-使用source执行一个脚本和不使用source执行一个脚本有什么区别" tabindex="-1"><a class="header-anchor" href="#在shell中-使用source执行一个脚本和不使用source执行一个脚本有什么区别" aria-hidden="true">#</a> 在shell中，使用source执行一个脚本和不使用source执行一个脚本有什么区别？</h2><p>在shell中，使用<code>source</code>命令执行一个脚本会导致该脚本在当前<code>shell</code>环境中执行。这意味着脚本中的变量、函数以及其他定义会影响当前的<code>shell</code>会话。</p><p>如果不使用<code>source</code>命令，而是简单地执行脚本，则会启动一个新的子<code>shell</code>来执行该脚本。在子<code>shell</code>中执行的所有更改（例如定义的变量、函数等）都不会影响父<code>shell</code>或当前的<code>shell</code>会话。这意味着在不使用<code>source</code>命令的情况下，脚本中的更改只会在子<code>shell</code>中生效，执行完脚本后不会影响到当前<code>shell</code>的环境。</p><p>简而言之，<code>source</code>命令用于在当前shell环境中执行脚本，而不使用<code>source</code>则会在一个新的子<code>shell</code>中执行脚本。</p><h2 id="cpu-飙升该如何排查" tabindex="-1"><a class="header-anchor" href="#cpu-飙升该如何排查" aria-hidden="true">#</a> CPU 飙升该如何排查？</h2><p>CPU飙升是一个常见的性能问题，排查方法主要依赖于系统监控工具。以下是一些常见的排查步骤:</p><ul><li>1.<strong>监控系统指标</strong>：使用系统监控工具 (如<code>top</code>，<code>htop</code>，<code>perf</code>等)监控CPU使用率、进程占用CPU时间、系统负载等指标，初步判断CPU飙升的原因。</li><li>2.<strong>定位高负载进程</strong>： 确定哪个进程或线程占用了大部分CPU资源，并分析该进程的功能和代码，判断是否为正常运行导致CPU飙升。</li><li>3.<strong>分析代码</strong>: 仔细检查高负载进程的代码，寻找可能导致CPU占用率高的原因，例如 <ul><li>1.死循环或者递归调用</li><li>2.繁重计算操作</li><li>3.系统调用频繁</li></ul></li><li>4.检查系统资源： 检查系统资源是否充足，例如内存、磁盘空间、网络带宽等。资源不足也会导致CPU负载过高。</li><li>5.排查硬件问题：检查硬件是否出现故障，例如CPU过热、主板故障等。</li><li>6.使用性能分析工具：使用性能分析工具(如<code>perf</code>，<code>valgrind</code>等)对代码进行分析，定位性能瓶颈，并针对性地优化代码。</li><li>7.优化代码。根据性能分析结果，优化代码，降低CPU占用率。例如： <ul><li>1.使用更高效地算法和数据结构</li><li>2.减少不必要地计算操作</li><li>3.优化系统调用</li><li>4.使用缓存技术</li><li>5.并发处理任务</li></ul></li><li>8.调整系统配置：调整系统配置，例如限制进程地CPU占用率、调整内核参数等。</li></ul><h2 id="令牌桶算法和漏筒算法的区别是什么" tabindex="-1"><a class="header-anchor" href="#令牌桶算法和漏筒算法的区别是什么" aria-hidden="true">#</a> 令牌桶算法和漏筒算法的区别是什么？</h2><p>令牌桶算法（Token Bucket Algorithm）和漏桶算法（Leaky Bucket Algorithm）是两种常用的流量控制算法，用于管理网络流量或系统资源。虽然它们都用于控制流量，避免过载，但其实现和行为有显著不同。以下是它们的主要区别：</p><ul><li>1.基本原理</li></ul><p>令牌桶算法（Token Bucket Algorithm）：</p><p><strong>原理</strong>：系统有一个桶，桶中不断有令牌（或许可证）被添加。每个令牌代表一个允许的操作。请求必须获取一个令牌才能处理。桶有最大容量，一旦桶满，额外的令牌会被丢弃。令牌以一定速率生成，这允许系统在短时间内处理更多的请求，但总流量仍在控制之下。</p><p><strong>特点</strong>：允许突发流量，适用于处理有一定突发性流量的情况。</p><p>漏桶算法（Leaky Bucket Algorithm）：</p><p><strong>原理</strong>：系统有一个桶，桶内的水（或数据）以恒定速率从底部流出。请求（或数据）被加入桶中，如果桶满了，新的请求会被丢弃。桶的漏水速率决定了流量的平滑程度。</p><p><strong>特点</strong>：输出流量是平稳的，不允许流量的突发，适用于需要流量平稳的场景。</p><ul><li>2.处理流量的方式</li></ul><p>令牌桶算法：</p><p><strong>突发流量</strong>：允许在短时间内有较大的突发流量，前提是令牌的总数量在桶中足够。</p><p><strong>平滑输出</strong>：通过控制令牌的生成速率来平滑输出流量，但允许瞬时的流量峰值。</p><p>漏桶算法：</p><p><strong>突发流量</strong>：不允许突发流量，所有请求必须按照恒定的速率输出。</p><p><strong>平滑输出</strong>：自然地平滑输出流量，通过恒定的流出速率来控制数据流。</p><ul><li>3.算法实现</li><li></li></ul><p>令牌桶算法：</p><p><strong>令牌生成</strong>：令牌以固定速率生成并放入桶中。</p><p><strong>令牌消耗</strong>：请求从桶中取令牌，每个请求消耗一个或多个令牌。桶有最大容量，超过容量的令牌会被丢弃。</p><p><strong>控制</strong>：控制令牌的生成速率，允许系统在允许的范围内处理突发流量。</p><p>漏桶算法：</p><p><strong>数据添加</strong>：请求数据加入桶中。</p><p><strong>数据流出</strong>：数据以恒定速率从桶中流出。如果桶满了，新的数据会被丢弃。</p><p><strong>控制</strong>：通过固定的流出速率来确保流量平稳输出。</p><ul><li>4.应用场景</li></ul><p>令牌桶算法：</p><ul><li>适用于需要处理一定程度的流量突发的情况，如网络流量控制、API请求限制等。</li><li>例如，允许一个用户在一段时间内可以有一定的突发请求，但总流量仍受到限制。</li></ul><p>漏桶算法：</p><ul><li>适用于需要平稳流量输出的场景，如网络带宽管理、服务器流量控制等。</li><li>例如，网络路由器中的流量管理，确保数据包以平稳的速率流出。</li></ul><p>总结</p><ul><li>令牌桶算法允许一定程度的流量突发，通过令牌控制来实现灵活的流量管理。</li><li>漏桶算法确保输出流量平稳，通过固定的输出速率控制流量，适合需要平稳流量的场景。</li><li>选择哪种算法取决于具体应用的需求和系统的要求。</li></ul>',49),d=[r];function t(s,n){return e(),o("div",null,d)}const u=l(c,[["render",t],["__file","linux.html.vue"]]);export{u as default};
