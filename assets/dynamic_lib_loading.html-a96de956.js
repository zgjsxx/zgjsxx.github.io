import{_ as l,V as t,W as p,X as s,Y as n,$ as e,a0 as i,F as o}from"./framework-9a29aaa0.js";const r={},c=i(`<h1 id="动态链接库的加载-翻译" tabindex="-1"><a class="header-anchor" href="#动态链接库的加载-翻译" aria-hidden="true">#</a> 动态链接库的加载(翻译)</h1><h2 id="什么是动态库" tabindex="-1"><a class="header-anchor" href="#什么是动态库" aria-hidden="true">#</a> 什么是动态库</h2><p>library（函数库）是一个包含代码和数据的文件。 library大多情况下是非常有用的，因为它们可以让编译过程更加的快速，因为你不必每次编译所有依赖的文件，这使得我们可以进行模块化开发。静态库可以被链接到一个已经编译好的可执行文件中或者其他库中，在编译之后，静态库中的内容就被嵌入到了可执行文件或者其他库当中。动态库则是可执行文件在<strong>运行时刻</strong>才被加载的，这意味着这样的过程将会更加的复杂。</p><h2 id="搭建demo" tabindex="-1"><a class="header-anchor" href="#搭建demo" aria-hidden="true">#</a> 搭建demo</h2><p>为了更好的探索动态链接库，我们使用一个例子贯穿整文。 我们以三个源文件开始。</p><p><strong>main.cpp</strong> 是可执行文件的入口。 这个文件中不会包含太多的内容，仅仅调用了一个random库中的方法。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;random.h&quot;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">get_random_number</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>random库只定义了一个函数，random.h的内容如下所示：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">get_random_number</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>get_random_number的实现在random.cpp文件中定义：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;random.h&quot;</span></span>

<span class="token keyword">int</span> <span class="token function">get_random_number</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="编译共享库" tabindex="-1"><a class="header-anchor" href="#编译共享库" aria-hidden="true">#</a> 编译共享库</h2><p>在创建共享库之前，首先创建.o文件，称之为对象文件。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>clang++ <span class="token parameter variable">-o</span> random.o <span class="token parameter variable">-c</span> random.cpp
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面的命令的参数含义如下：</p><ul><li>-o random.o： 定义输出文件的名字</li><li>-c： 仅仅编译，不做链接</li><li>random.cpp: 选择输入的文件名</li></ul><p>接下来将.o文件生成共享库：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>clang++ <span class="token parameter variable">-shared</span> <span class="token parameter variable">-o</span> librandom.so <span class="token parameter variable">-c</span> random.o
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,18),d=s("strong",null,"-shared",-1),u={href:"http://xn--libramdom-pm7nkw25vf6il62a6pitqoe6qgl3euun.so",target:"_blank",rel:"noopener noreferrer"},b=s("code",null,"lib<name>.so",-1),m=i(`<h2 id="编译可执行文件使用动态库" tabindex="-1"><a class="header-anchor" href="#编译可执行文件使用动态库" aria-hidden="true">#</a> 编译可执行文件使用动态库</h2><p>首先为main.cpp创建目标文件main.o</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>clang++ <span class="token parameter variable">-o</span> main.o <span class="token parameter variable">-c</span> main.cpp
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个步骤和之前创建random.o是一样的。 现在尝试创建可执行文件。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>clang++ <span class="token parameter variable">-o</span> main main.o
main.o: In <span class="token keyword">function</span> <span class="token variable"><span class="token variable">\`</span>main&#39;:
main.cpp:<span class="token punctuation">(</span>.text+0x10<span class="token punctuation">)</span>: undefined reference to <span class="token variable">\`</span></span>get_random_number<span class="token punctuation">(</span><span class="token punctuation">)</span>&#39;
clang: error: linker <span class="token builtin class-name">command</span> failed with <span class="token builtin class-name">exit</span> code <span class="token number">1</span> <span class="token punctuation">(</span>use <span class="token parameter variable">-v</span> to see invocation<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,5),v={href:"http://xn--clanglibrandom-929v567ckhc329htjgc48rp9jz54crwj.so",target:"_blank",rel:"noopener noreferrer"},k=i(`<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ clang++ <span class="token parameter variable">-o</span> main main.o <span class="token parameter variable">-lrandom</span>
/usr/bin/ld: cannot <span class="token function">find</span> <span class="token parameter variable">-lrandom</span>
clang: error: linker <span class="token builtin class-name">command</span> failed with <span class="token builtin class-name">exit</span> code <span class="token number">1</span> <span class="token punctuation">(</span>use <span class="token parameter variable">-v</span> to see invocation<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1),h={href:"http://xn--librandom-947nr4cw9ydxb2vnhk1ch31duj9a60zcnea.so",target:"_blank",rel:"noopener noreferrer"},g={href:"http://librandom.so",target:"_blank",rel:"noopener noreferrer"},f=i(`<p>上面的输出提示我们找不到random库，原因是我们没有指定共享库的路径。我们可以使用<code>-L</code>参数。 注意到这个这个参数仅仅制定了编译时共享库的路径，并不是指定了运行时的加载路径。 指定当前路径作为共享库的搜索路径，如下所示：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ clang++ <span class="token parameter variable">-o</span> main main.o <span class="token parameter variable">-lrandom</span> -L.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>太棒了，我们成功的编译出了可执行文件。</p><p>下面让我们运行它。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ ./main
./main: error <span class="token keyword">while</span> loading shared libraries: librandom.so: cannot <span class="token function">open</span> shared object file: No such <span class="token function">file</span> or directory 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这个问题是我们的依赖无法被找到。它甚至会在我们的应用程序运行一行代码之前发生，因为共享库是在可执行文件中的符号之前加载的。</p><p>由此，引出了几个问题：</p>`,7),x={href:"http://librandom.so",target:"_blank",rel:"noopener noreferrer"},_={href:"http://librandom.so",target:"_blank",rel:"noopener noreferrer"},y={href:"http://librandom.so",target:"_blank",rel:"noopener noreferrer"},E=i(`<p>为了回答这些问题，我们必须更深入地了解这些文件的结构。</p><h2 id="elf-可执行和可链接格式" tabindex="-1"><a class="header-anchor" href="#elf-可执行和可链接格式" aria-hidden="true">#</a> ELF - 可执行和可链接格式</h2><p>共享库和可执行文件格式称为ELF（可执行和可链接格式）。如果您查看维基百科文章，您会发现它一团糟，因此我们不会详细介绍所有内容。总之，ELF 文件包含：</p><ul><li>ELF头</li><li>文件数据，包含 <ul><li>程序头表(a list of segmemt headers)</li><li>节头表(a list of section headers)</li><li>上面两个表指定的数据</li></ul></li></ul><p>ELF头规定了程序头表中段的大小和数量，以及规定了节头表中节的大小和数量。每个这样的表都由固定大小的条目组成。条目中包含了头部和指定数据的指针组成。</p><p>我们可以使用readelf工具去查看elf文件的内容，例如main的内容如下所示：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ readelf <span class="token parameter variable">-h</span> main
ELF Header:
  Magic:   7f <span class="token number">45</span> 4c <span class="token number">46</span> 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              <span class="token number">2</span>&#39;s complement, little endian
  Version:                           <span class="token number">1</span> <span class="token punctuation">(</span>current<span class="token punctuation">)</span>
  OS/ABI:                            UNIX - System V
  ABI Version:                       <span class="token number">0</span>
  Type:                              EXEC <span class="token punctuation">(</span>Executable <span class="token function">file</span><span class="token punctuation">)</span>
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x4005e0
  Start of program headers:          <span class="token number">64</span> <span class="token punctuation">(</span>bytes into <span class="token function">file</span><span class="token punctuation">)</span>
  Start of section headers:          <span class="token number">4584</span> <span class="token punctuation">(</span>bytes into <span class="token function">file</span><span class="token punctuation">)</span>
  Flags:                             0x0
  Size of this header:               <span class="token number">64</span> <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>
  Size of program headers:           <span class="token number">56</span> <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>
  Number of program headers:         <span class="token number">9</span>
  Size of section headers:           <span class="token number">64</span> <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>
  Number of section headers:         <span class="token number">30</span>
  Section header string table index: <span class="token number">27</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们看到main的联系那个是EXEC，代表其是一个可执行文件。main有9个程序头表和30个节表。</p><p>接下来查看程序头表和节表。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ readelf <span class="token parameter variable">-l</span> main

Elf <span class="token function">file</span> <span class="token builtin class-name">type</span> is EXEC <span class="token punctuation">(</span>Executable <span class="token function">file</span><span class="token punctuation">)</span>
Entry point 0x4005e0
There are <span class="token number">9</span> program headers, starting at offset <span class="token number">64</span>

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  PHDR           0x0000000000000040 0x0000000000400040 0x0000000000400040
                 0x00000000000001f8 0x00000000000001f8  R E    <span class="token number">8</span>
  INTERP         0x0000000000000238 0x0000000000400238 0x0000000000400238
                 0x000000000000001c 0x000000000000001c  R      <span class="token number">1</span>
      <span class="token punctuation">[</span>Requesting program interpreter: /lib64/ld-linux-x86-64.so.2<span class="token punctuation">]</span>
  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                 0x000000000000089c 0x000000000000089c  R E    <span class="token number">200000</span>
  LOAD           0x0000000000000dd0 0x0000000000600dd0 0x0000000000600dd0
                 0x0000000000000270 0x0000000000000278  RW     <span class="token number">200000</span>
  DYNAMIC        0x0000000000000de8 0x0000000000600de8 0x0000000000600de8
                 0x0000000000000210 0x0000000000000210  RW     <span class="token number">8</span>
  NOTE           0x0000000000000254 0x0000000000400254 0x0000000000400254
                 0x0000000000000044 0x0000000000000044  R      <span class="token number">4</span>
  GNU_EH_FRAME   0x0000000000000774 0x0000000000400774 0x0000000000400774
                 0x0000000000000034 0x0000000000000034  R      <span class="token number">4</span>
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     <span class="token number">10</span>
  GNU_RELRO      0x0000000000000dd0 0x0000000000600dd0 0x0000000000600dd0
                 0x0000000000000230 0x0000000000000230  R      <span class="token number">1</span>

 Section to Segment mapping:
  Segment Sections<span class="token punctuation">..</span>.
   00     
   01     .interp 
   02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .text .fini .rodata .eh_frame_hdr .eh_frame 
   03     .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss 
   04     .dynamic 
   05     .note.ABI-tag .note.gnu.build-id 
   06     .eh_frame_hdr 
   07     
   08     .init_array .fini_array .jcr .dynamic .got 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同样，我们看到我们有9个程序标题。它们的类型是LOAD,DYNAMIC，NOTE等。我们还可以看到每个节属于哪个段。</p><p>最后我们看下节表：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ readelf <span class="token parameter variable">-S</span> main
There are <span class="token number">30</span> section headers, starting at offset 0x11e8:

Section Headers:
  <span class="token punctuation">[</span>Nr<span class="token punctuation">]</span> Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  <span class="token punctuation">[</span> <span class="token number">0</span><span class="token punctuation">]</span>                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">0</span>
  <span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">]</span> .interp           PROGBITS         0000000000400238  00000238
       000000000000001c  0000000000000000   A       <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">1</span>
  <span class="token punctuation">[</span> <span class="token number">2</span><span class="token punctuation">]</span> .note.ABI-tag     NOTE             0000000000400254  00000254
       0000000000000020  0000000000000000   A       <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">4</span>

  <span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span>

  <span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span> .dynamic          DYNAMIC          0000000000600de8  00000de8
       0000000000000210  0000000000000010  WA       <span class="token number">6</span>     <span class="token number">0</span>     <span class="token number">8</span>

  <span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span>

  <span class="token punctuation">[</span><span class="token number">28</span><span class="token punctuation">]</span> .symtab           SYMTAB           0000000000000000  00001968
       0000000000000618  0000000000000018          <span class="token number">29</span>    <span class="token number">45</span>     <span class="token number">8</span>
  <span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span> .strtab           STRTAB           0000000000000000  00001f80
       000000000000023d  0000000000000000           <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">1</span>
Key to Flags:
  W <span class="token punctuation">(</span>write<span class="token punctuation">)</span>, A <span class="token punctuation">(</span>alloc<span class="token punctuation">)</span>, X <span class="token punctuation">(</span>execute<span class="token punctuation">)</span>, M <span class="token punctuation">(</span>merge<span class="token punctuation">)</span>, S <span class="token punctuation">(</span>strings<span class="token punctuation">)</span>, l <span class="token punctuation">(</span>large<span class="token punctuation">)</span>
  I <span class="token punctuation">(</span>info<span class="token punctuation">)</span>, L <span class="token punctuation">(</span>link order<span class="token punctuation">)</span>, G <span class="token punctuation">(</span>group<span class="token punctuation">)</span>, T <span class="token punctuation">(</span>TLS<span class="token punctuation">)</span>, E <span class="token punctuation">(</span>exclude<span class="token punctuation">)</span>, x <span class="token punctuation">(</span>unknown<span class="token punctuation">)</span>
  O <span class="token punctuation">(</span>extra OS processing required<span class="token punctuation">)</span> o <span class="token punctuation">(</span>OS specific<span class="token punctuation">)</span>, p <span class="token punctuation">(</span>processor specific<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了简洁起见，我修剪了这一点。我们看到列出的 30 个部分具有不同的名称（例如 .note.ABI-tag）和类型（例如 SYMTAB</p><p>你现在可能很困惑。别担心——它不会出现在测试中。我解释这一点是因为我们对此文件的特定部分感兴趣：在其程序头表中，ELF 文件可以具有（尤其是共享库必须具有）描述 PT_DYNAMIC 类型段的段头。该段拥有一个名.dynamic 的节，其中包含了解动态依赖关系的有用信息。</p><h2 id="直接依赖" tabindex="-1"><a class="header-anchor" href="#直接依赖" aria-hidden="true">#</a> 直接依赖</h2>`,16),A={href:"http://librandom.so",target:"_blank",rel:"noopener noreferrer"},w=i(`<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ readelf <span class="token parameter variable">-d</span> main <span class="token operator">|</span> <span class="token function">grep</span> NEEDED
 0x0000000000000001 <span class="token punctuation">(</span>NEEDED<span class="token punctuation">)</span>             Shared library: <span class="token punctuation">[</span>librandom.so<span class="token punctuation">]</span>
 0x0000000000000001 <span class="token punctuation">(</span>NEEDED<span class="token punctuation">)</span>             Shared library: <span class="token punctuation">[</span>libstdc++.so.6<span class="token punctuation">]</span>
 0x0000000000000001 <span class="token punctuation">(</span>NEEDED<span class="token punctuation">)</span>             Shared library: <span class="token punctuation">[</span>libm.so.6<span class="token punctuation">]</span>
 0x0000000000000001 <span class="token punctuation">(</span>NEEDED<span class="token punctuation">)</span>             Shared library: <span class="token punctuation">[</span>libgcc_s.so.1<span class="token punctuation">]</span>
 0x0000000000000001 <span class="token punctuation">(</span>NEEDED<span class="token punctuation">)</span>             Shared library: <span class="token punctuation">[</span>libc.so.6<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1),L={href:"http://librandom.so",target:"_blank",rel:"noopener noreferrer"},R=s("ul",null,[s("li",null,"libstdc++：标准 C++ 库。"),s("li",null,"libm：包含基本数学函数的库。"),s("li",null,"libgcc_s：GCC（GNU 编译器集合）运行时库。"),s("li",null,'libc：C 库：定义"系统调用"和其他基本设施（例如 open、malloc、printf、exit 等）的库。')],-1),I={href:"http://librandom.so",target:"_blank",rel:"noopener noreferrer"},N={href:"http://librandom.so",target:"_blank",rel:"noopener noreferrer"},$=i(`<h2 id="运行时搜索路径" tabindex="-1"><a class="header-anchor" href="#运行时搜索路径" aria-hidden="true">#</a> 运行时搜索路径</h2><p>ldd 是一个允许我们查看递归共享库依赖关系的工具。这意味着我们可以看到工件在运行时所需的所有共享库的完整列表。它还允许我们查看这些依赖项所在的位置。让我们在 main 上运行它，看看会发生什么：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ ldd main
	linux-vdso.so.1 <span class="token operator">=</span><span class="token operator">&gt;</span>  <span class="token punctuation">(</span>0x00007fff889bd000<span class="token punctuation">)</span>
	librandom.so <span class="token operator">=</span><span class="token operator">&gt;</span> not found
	libstdc++.so.6 <span class="token operator">=</span><span class="token operator">&gt;</span> /usr/lib/x86_64-linux-gnu/libstdc++.so.6 <span class="token punctuation">(</span>0x00007f07c55c5000<span class="token punctuation">)</span>
	libm.so.6 <span class="token operator">=</span><span class="token operator">&gt;</span> /lib/x86_64-linux-gnu/libm.so.6 <span class="token punctuation">(</span>0x00007f07c52bf000<span class="token punctuation">)</span>
	libgcc_s.so.1 <span class="token operator">=</span><span class="token operator">&gt;</span> /lib/x86_64-linux-gnu/libgcc_s.so.1 <span class="token punctuation">(</span>0x00007f07c50a9000<span class="token punctuation">)</span>
	libc.so.6 <span class="token operator">=</span><span class="token operator">&gt;</span> /lib/x86_64-linux-gnu/libc.so.6 <span class="token punctuation">(</span>0x00007f07c4ce4000<span class="token punctuation">)</span>
	/lib64/ld-linux-x86-64.so.2 <span class="token punctuation">(</span>0x00007f07c58c9000<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们看到librandom.so在列表中出现了，但是是未发现。我们还可以看到有两个额外的库（vdso 和 ld-linux-x86-64）。它们是间接依赖关系。更重要的是，我们看到 ldd 报告了库的位置。考虑 libstdc++。 ldd 报告其位置为 /usr/lib/x86_64-linux-gnu/libstdc++.so.6。它是怎么知道的？</p><p>我们的依赖项中的每个共享库都会按顺序在以下位置进行搜索：</p><ul><li>可执行文件的 rpath 中列出的目录。</li><li>LD_LIBRARY_PATH 环境变量中的目录，其中包含以冒号分隔的目录列表（例如，/path/to/libdir:/another/path）</li><li>可执行文件 runpath 所指定的目录。</li><li>文件 /etc/ld.so.conf 中的目录列表。该文件可以包含其他文件，但它基本上是一个目录列表 - 每行一个。</li><li>默认系统库 - 通常为 /lib 和 /usr/lib （如果使用 -z nodefaultlib 编译则跳过）。</li></ul><h2 id="修复我们的可执行文件" tabindex="-1"><a class="header-anchor" href="#修复我们的可执行文件" aria-hidden="true">#</a> 修复我们的可执行文件</h2>`,7),D={href:"http://librandom.so",target:"_blank",rel:"noopener noreferrer"},S=i(`<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token assign-left variable">LD_DEBUG</span><span class="token operator">=</span>libs ldd main
      <span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span>

      <span class="token number">3650</span>:	<span class="token function">find</span> <span class="token assign-left variable">library</span><span class="token operator">=</span>librandom.so <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> searching
      <span class="token number">3650</span>:	 search <span class="token assign-left variable">cache</span><span class="token operator">=</span>/etc/ld.so.cache
      <span class="token number">3650</span>:	 search <span class="token assign-left variable">path</span><span class="token operator">=</span>/lib/x86_64-linux-gnu/tls/x86_64:/lib/x86_64-linux-gnu/tls:/lib/x86_64-linux-gnu/x86_64:/lib/x86_64-linux-gnu:/usr/lib/x86_64-linux-gnu/tls/x86_64:/usr/lib/x86_64-linux-gnu/tls:/usr/lib/x86_64-linux-gnu/x86_64:/usr/lib/x86_64-linux-gnu:/lib/tls/x86_64:/lib/tls:/lib/x86_64:/lib:/usr/lib/tls/x86_64:/usr/lib/tls:/usr/lib/x86_64:/usr/lib		<span class="token punctuation">(</span>system search path<span class="token punctuation">)</span>
      <span class="token number">3650</span>:	  trying <span class="token assign-left variable">file</span><span class="token operator">=</span>/lib/x86_64-linux-gnu/tls/x86_64/librandom.so
      <span class="token number">3650</span>:	  trying <span class="token assign-left variable">file</span><span class="token operator">=</span>/lib/x86_64-linux-gnu/tls/librandom.so
      <span class="token number">3650</span>:	  trying <span class="token assign-left variable">file</span><span class="token operator">=</span>/lib/x86_64-linux-gnu/x86_64/librandom.so
      <span class="token number">3650</span>:	  trying <span class="token assign-left variable">file</span><span class="token operator">=</span>/lib/x86_64-linux-gnu/librandom.so
      <span class="token number">3650</span>:	  trying <span class="token assign-left variable">file</span><span class="token operator">=</span>/usr/lib/x86_64-linux-gnu/tls/x86_64/librandom.so
      <span class="token number">3650</span>:	  trying <span class="token assign-left variable">file</span><span class="token operator">=</span>/usr/lib/x86_64-linux-gnu/tls/librandom.so
      <span class="token number">3650</span>:	  trying <span class="token assign-left variable">file</span><span class="token operator">=</span>/usr/lib/x86_64-linux-gnu/x86_64/librandom.so
      <span class="token number">3650</span>:	  trying <span class="token assign-left variable">file</span><span class="token operator">=</span>/usr/lib/x86_64-linux-gnu/librandom.so
      <span class="token number">3650</span>:	  trying <span class="token assign-left variable">file</span><span class="token operator">=</span>/lib/tls/x86_64/librandom.so
      <span class="token number">3650</span>:	  trying <span class="token assign-left variable">file</span><span class="token operator">=</span>/lib/tls/librandom.so
      <span class="token number">3650</span>:	  trying <span class="token assign-left variable">file</span><span class="token operator">=</span>/lib/x86_64/librandom.so
      <span class="token number">3650</span>:	  trying <span class="token assign-left variable">file</span><span class="token operator">=</span>/lib/librandom.so
      <span class="token number">3650</span>:	  trying <span class="token assign-left variable">file</span><span class="token operator">=</span>/usr/lib/tls/x86_64/librandom.so
      <span class="token number">3650</span>:	  trying <span class="token assign-left variable">file</span><span class="token operator">=</span>/usr/lib/tls/librandom.so
      <span class="token number">3650</span>:	  trying <span class="token assign-left variable">file</span><span class="token operator">=</span>/usr/lib/x86_64/librandom.so
      <span class="token number">3650</span>:	  trying <span class="token assign-left variable">file</span><span class="token operator">=</span>/usr/lib/librandom.so

      <span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我修剪了输出，因为它非常……喋喋不休。难怪我们的共享库找不到​​——librandom.so所在的目录不在搜索路径中！解决这个问题最特别的方法是使用 LD_LIBRARY_PATH：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token assign-left variable">LD_LIBRARY_PATH</span><span class="token operator">=</span>. ./main
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>它可以工作，但不太便携。我们不想每次运行程序时都指定 lib 目录。更好的方法是将我们的依赖项放入文件中。</p><p>rpath和runpath可以帮助我们。</p><p>rpath 和 runpath 是我们的运行时搜索路径&quot;清单&quot;中最复杂的项目。可执行文件或共享库的 rpath 和 runpath 是我们之前回顾过的 .dynamic 部分中的可选条目4。它们都是要搜索的目录列表。</p><p>rpath 和 runpath 之间的唯一区别是它们的搜索顺序。具体来说，它们与 LD_LIBRARY_PATH 的关系 - rpath 在 LD_LIBRARY_PATH 之前搜索，而 runpath 在之后搜索。这意味着 rpath 不能随环境变量动态更改，而 runpath 可以。</p><p>让我们将 rpath 添加到可执行文件中，看看是否可以让它工作：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ clang++ <span class="token parameter variable">-o</span> main main.o <span class="token parameter variable">-lrandom</span> -L. -Wl,-rpath,.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>-Wl 标志将以下以逗号分隔的标志传递给链接器。在本例中，我们传递 <code>-rpath .</code>， 要设置运行路径，我们还必须传递 <code>--enable-new-dtags</code>。 让我们检查一下结果：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ readelf main <span class="token parameter variable">-d</span> <span class="token operator">|</span> <span class="token function">grep</span> path
 0x000000000000000f <span class="token punctuation">(</span>RPATH<span class="token punctuation">)</span>              Library rpath: <span class="token punctuation">[</span>.<span class="token punctuation">]</span>

$ ./main
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可执行文件运行，但这添加了 .到 rpath，即当前工作目录。这意味着它无法在不同的目录中工作：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token builtin class-name">cd</span> /tmp
$ ~/code/shared_lib_demo/main
/home/nurdok/code/shared_lib_demo/main: error <span class="token keyword">while</span> loading shared libraries: librandom.so: cannot <span class="token function">open</span> shared object file: No such <span class="token function">file</span> or directory
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们有几种方法来解决这个问题。最简单的方法是将 librandom 复制到我们搜索路径中的目录（例如 /lib）。显然，我们要做的更复杂的方法是指定相对于可执行文件的 rpath。</p><h2 id="origin" tabindex="-1"><a class="header-anchor" href="#origin" aria-hidden="true">#</a> $ORIGIN</h2><p>rpath 和 runpath 中的路径可以是绝对路径（例如，/path/to/my/libs/），相对于当前工作目录（例如，.），但它们也可以是相对于可执行文件的路径。这是通过在 rpath 定义中使用 $ORIGIN 变量来实现的：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ clang++ <span class="token parameter variable">-o</span> main main.o <span class="token parameter variable">-lrandom</span> -L. -Wl,-rpath,<span class="token string">&quot;\\<span class="token variable">$ORIGIN</span>&quot;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,17),T={href:"http://librandom.so",target:"_blank",rel:"noopener noreferrer"},B=i(`<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ ./main
$ <span class="token builtin class-name">cd</span> /tmp
$ ~/code/shared_lib_demo/main
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>让我们使用我们的工具包来确保：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ readelf main <span class="token parameter variable">-d</span> <span class="token operator">|</span> <span class="token function">grep</span> path
 0x000000000000000f <span class="token punctuation">(</span>RPATH<span class="token punctuation">)</span>              Library rpath: <span class="token punctuation">[</span><span class="token variable">$ORIGIN</span><span class="token punctuation">]</span>

$ ldd main
	linux-vdso.so.1 <span class="token operator">=</span><span class="token operator">&gt;</span>  <span class="token punctuation">(</span>0x00007ffe13dfe000<span class="token punctuation">)</span>
	librandom.so <span class="token operator">=</span><span class="token operator">&gt;</span> /home/nurdok/code/shared_lib_demo/./librandom.so <span class="token punctuation">(</span>0x00007fbd0ce06000<span class="token punctuation">)</span>
	<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="运行时搜索路径-安全性" tabindex="-1"><a class="header-anchor" href="#运行时搜索路径-安全性" aria-hidden="true">#</a> 运行时搜索路径：安全性</h2><p>如果您曾经从命令行更改过 Linux 用户密码，则可能使用过 passwd 实用程序：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">passwd</span>
Changing password <span class="token keyword">for</span> nurdok.
<span class="token punctuation">(</span>current<span class="token punctuation">)</span> UNIX password: 
Enter new UNIX password: 
Retype new UNIX password: 
passwd: password updated successfully
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>密码哈希值存储在 /etc/shadow 中，该文件受 root 保护。那么，您可能会问，您的非 root 用户如何更改该文件？</p><p>答案是 passwd 程序设置了 setuid 位，您可以使用 ls 看到：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">ls</span> <span class="token parameter variable">-l</span> <span class="token variable"><span class="token variable">\`</span><span class="token function">which</span> <span class="token function">passwd</span><span class="token variable">\`</span></span>
-rwsr-xr-x <span class="token number">1</span> root root <span class="token number">39104</span> <span class="token number">2009</span>-12-06 05:35 /usr/bin/passwd
<span class="token comment">#  ^--- This means that the &quot;setuid&quot; bit is set for user execution.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>它是 s（该行的第四个字符）。所有设置了此权限位的程序都作为该程序的所有者运行。在此示例中，用户是 root（该行的第三个单词）。</p><p>这与共享库有什么关系？”你问。我们将通过一个例子来了解。</p><p>现在，我们将在 main 旁边的 libs 目录中添加 librandom，并将 $ORIGIN/libs7 烘焙到 main 的 rpath 中：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">ls</span>
libs  main
$ <span class="token function">ls</span> libs
librandom.so
$ readelf <span class="token parameter variable">-d</span> main <span class="token operator">|</span> <span class="token function">grep</span> path
 0x000000000000000f <span class="token punctuation">(</span>RPATH<span class="token punctuation">)</span>              Library rpath: <span class="token punctuation">[</span><span class="token variable">$ORIGIN</span>/libs<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们运行 main，它会按预期工作。让我们打开主可执行文件的 setuid 位并使其以 root 身份运行</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">sudo</span> <span class="token function">chown</span> root main
$ <span class="token function">sudo</span> <span class="token function">chmod</span> a+s main
$ ./main
./main: error <span class="token keyword">while</span> loading shared libraries: librandom.so: cannot <span class="token function">open</span> shared object file: No such <span class="token function">file</span> or directory
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>好吧，rpath 不起作用。让我们尝试设置 LD_LIBRARY_PATH。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token assign-left variable">LD_LIBRARY_PATH</span><span class="token operator">=</span>./libs ./main
./main: error <span class="token keyword">while</span> loading shared libraries: librandom.so: cannot <span class="token function">open</span> shared object file: No such <span class="token function">file</span> or directory
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这里发生了什么？</p><p>出于安全原因，当使用提升的权限（例如 setuid、setgid、特殊功能等）运行可执行文件时，搜索路径列表与正常情况不同：LD_LIBRARY_PATH 被忽略，以及 rpath 或 runpath 中包含 $ 的任何路径起源。</p>`,19),O={href:"https://marc.info/?l=full-disclosure&m=128739684614072&w=2",target:"_blank",rel:"noopener noreferrer"},P=i(`<p>如果您的可执行文件需要具有提升的权限，则需要在绝对路径中指定依赖项，或将它们放置在默认位置（例如 /lib）。</p><p>这里需要注意的一个重要行为是，对于此类应用程序，ldd 当着我们的面撒谎：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>% ldd main
	linux-vdso.so.1 <span class="token operator">=</span><span class="token operator">&gt;</span>  <span class="token punctuation">(</span>0x00007ffc2afd2000<span class="token punctuation">)</span>
	librandom.so <span class="token operator">=</span><span class="token operator">&gt;</span> /home/nurdok/code/shared_lib_demo/libs/librandom.so <span class="token punctuation">(</span>0x00007f1f666ca000<span class="token punctuation">)</span>
	libstdc++.so.6 <span class="token operator">=</span><span class="token operator">&gt;</span> /usr/lib/x86_64-linux-gnu/libstdc++.so.6 <span class="token punctuation">(</span>0x00007f1f663c6000<span class="token punctuation">)</span>
	libm.so.6 <span class="token operator">=</span><span class="token operator">&gt;</span> /lib/x86_64-linux-gnu/libm.so.6 <span class="token punctuation">(</span>0x00007f1f660c0000<span class="token punctuation">)</span>
	libgcc_s.so.1 <span class="token operator">=</span><span class="token operator">&gt;</span> /lib/x86_64-linux-gnu/libgcc_s.so.1 <span class="token punctuation">(</span>0x00007f1f65eaa000<span class="token punctuation">)</span>
	libc.so.6 <span class="token operator">=</span><span class="token operator">&gt;</span> /lib/x86_64-linux-gnu/libc.so.6 <span class="token punctuation">(</span>0x00007f1f65ae5000<span class="token punctuation">)</span>
	/lib64/ld-linux-x86-64.so.2 <span class="token punctuation">(</span>0x00007f1f668cc000<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ldd 不关心 setuid，它在搜索我们的依赖项时会扩展 $ORIGIN。在调试 setuid 应用程序的依赖项时，这可能是一个相当大的陷阱。</p><h2 id="调试备忘录" tabindex="-1"><a class="header-anchor" href="#调试备忘录" aria-hidden="true">#</a> 调试备忘录</h2><p>如果您在运行可执行文件时遇到此错误：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ ./main
./main: error <span class="token keyword">while</span> loading shared libraries: librandom.so: cannot <span class="token function">open</span> shared object file: No such <span class="token function">file</span> or directory 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>您可以尝试执行以下操作：</p><ul><li>找出 <code>ldd &lt;executable&gt;</code> 缺少哪些依赖项。</li><li>如果您无法识别它们，可以通过运行 <code>readelf -d &lt;executable&gt; |grep NEEDED</code> 检查它们是否是直接依赖项。</li><li>确保依赖项确实存在。也许您忘记编译它们或将它们移动到 libs 目录？</li><li>用 <code>LD_DEBUG=libs ldd &lt;executable&gt;</code> 找出在何处搜索依赖项。</li><li>如果需要将目录添加到搜索中： <ul><li>Ad-hoc：将目录添加到 LD_LIBRARY_PATH 环境变量中。</li></ul></li><li>烘焙到文件中：通过传递 <code>-Wl,-rpath,&lt;dir&gt;</code>（对于 rpath）或 <code>-Wl,--enable-new-dtags,-rpath,&lt;dir&gt;</code> 将目录添加到可执行文件或共享库的 rpath 或 runpath （对于运行路径）。使用 $ORIGIN 作为相对于可执行文件的路径。</li><li>如果 ldd 显示没有缺少任何依赖项，请查看您的应用程序是否具有提升的权限。如果是这样，ldd可能会撒谎。请参阅上面的安全问题。</li></ul><p>如果您仍然无法弄清楚 - 您需要再次阅读整篇文章:</p><h1 id="参考文章" tabindex="-1"><a class="header-anchor" href="#参考文章" aria-hidden="true">#</a> 参考文章</h1>`,11),G={href:"https://amir.rachum.com/shared-libraries/",target:"_blank",rel:"noopener noreferrer"};function H(F,Y){const a=o("ExternalLinkIcon");return t(),p("div",null,[c,s("p",null,[d,n("指定了生成的库的类型是共享库。注意，"),s("a",u,[n("我们将共享库的名称是libramdom.so"),e(a)]),n("。这个名字并不能随意取，需要按照"),b,n("格式来命名，这个名称后续在链接的时候会用到。")]),m,s("p",null,[s("a",v,[n("我们需要告诉clang去链接librandom.so"),e(a)]),n("，使用下面的语句操作：")]),k,s("p",null,[s("a",h,[n("我们告诉编译器去使用librandom.so"),e(a)]),n("。 既然是运行时才会加载，为什么编译的时候就需要指定呢？这是因为我们需要确保共享库中包含了可执行文件所需要的所有符号。 另请注意，我们指定 random 作为库的名称，而不是 "),s("a",g,[n("librandom.so"),e(a)]),n("。还记得关于库文件命名的约定吗？这就是它的用处。")]),f,s("ul",null,[s("li",null,[n("main 如何知道它依赖于 "),s("a",x,[n("librandom.so"),e(a)]),n("？")]),s("li",null,[n("main 在哪里寻找 "),s("a",_,[n("librandom.so"),e(a)]),n(" ？")]),s("li",null,[n("我们如何告诉 main 在这个目录中查找 "),s("a",y,[n("librandom.so"),e(a)]),n(" ？")])]),E,s("p",null,[n("我们可以使用 readelf 实用程序来进一步探索可执行文件的 .dynamic 部分2。特别是，此部分包含 ELF 文件的所有动态依赖项。我们只指定 "),s("a",A,[n("librandom.so"),e(a)]),n(" 作为依赖项，因此我们希望只列出一个依赖项：")]),w,s("p",null,[n("我们可以看到我们指定的 "),s("a",L,[n("librandom.so"),e(a)]),n("，但我们还获得了四个我们没有预料到的额外依赖项。这些依赖项似乎出现在所有已编译的共享库中。这些是什么？")]),R,s("p",null,[n("好的 - 所以我们知道 main 知道它依赖于 "),s("a",I,[n("librandom.so"),e(a)]),n("。那么为什么 main 在运行时找不到 "),s("a",N,[n("librandom.so"),e(a)]),n(" 呢？")]),$,s("p",null,[n("好吧。我们验证了 "),s("a",D,[n("librandom.so"),e(a)]),n(" 是列出的依赖项，但找不到它。我们知道在哪里搜索依赖项。我们将再次使用 ldd 确保我们的目录实际上不在搜索路径上。")]),S,s("p",null,[n("请注意，我们需要转义美元符号（或使用单引号），以便我们的 shell 不会尝试扩展它。结果是 main 在每个目录中工作并正确找到 "),s("a",T,[n("librandom.so"),e(a)]),n("：")]),B,s("p",null,[n("原因是使用这些搜索路径允许利用提升权限的可执行文件以 root 身份运行。有关此漏洞的详细信息可以在此处找到("),s("a",O,[n("https://marc.info/?l=full-disclosure&m=128739684614072&w=2"),e(a)]),n(")。基本上，它允许您使提升的权限可执行文件加载您自己的库，该库将以 root（或其他用户）身份运行。以 root 身份运行您自己的代码几乎可以让您完全控制您正在使用的机器。")]),P,s("p",null,[s("a",G,[n("https://amir.rachum.com/shared-libraries/"),e(a)])])])}const q=l(r,[["render",H],["__file","dynamic_lib_loading.html.vue"]]);export{q as default};
