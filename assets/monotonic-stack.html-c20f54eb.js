const t=JSON.parse('{"key":"v-7a20e35f","path":"/posts/datastructure_algorithm/monotonic-stack.html","title":"单调栈","lang":"zh-CN","frontmatter":{"category":["data structure"],"tag":["data structure"],"description":"单调栈 单调栈 单调栈是一种栈的特殊应用，用于解决一类需要在数据序列中找到特定元素的“最近较大/较小值”的问题。它的核心思想是通过保持栈内元素的单调性（即元素从栈底到栈顶按某种顺序排列），来简化和优化这些问题的解决。 单调栈的种类 单调递增栈：栈内元素从栈底到栈顶严格递增。也就是说，新加入栈的元素一定比栈顶元素大。用于查找每个元素左侧或者右侧第一个小于它的元素。 单调递减栈：栈内元素从栈底到栈顶严格递减。也就是说，新加入栈的元素一定比栈顶元素小。用于查找每个元素左侧或者右侧第一个大于它的元素。","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/datastructure_algorithm/monotonic-stack.html"}],["meta",{"property":"og:site_name","content":"Code Building"}],["meta",{"property":"og:title","content":"单调栈"}],["meta",{"property":"og:description","content":"单调栈 单调栈 单调栈是一种栈的特殊应用，用于解决一类需要在数据序列中找到特定元素的“最近较大/较小值”的问题。它的核心思想是通过保持栈内元素的单调性（即元素从栈底到栈顶按某种顺序排列），来简化和优化这些问题的解决。 单调栈的种类 单调递增栈：栈内元素从栈底到栈顶严格递增。也就是说，新加入栈的元素一定比栈顶元素大。用于查找每个元素左侧或者右侧第一个小于它的元素。 单调递减栈：栈内元素从栈底到栈顶严格递减。也就是说，新加入栈的元素一定比栈顶元素小。用于查找每个元素左侧或者右侧第一个大于它的元素。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-26T07:34:12.000Z"}],["meta",{"property":"article:tag","content":"data structure"}],["meta",{"property":"article:modified_time","content":"2024-08-26T07:34:12.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"单调栈\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-08-26T07:34:12.000Z\\",\\"author\\":[]}"]]},"headers":[],"git":{"createdTime":1723306518000,"updatedTime":1724657652000,"contributors":[{"name":"zgjsxx","email":"119160524@qq.com","commits":2},{"name":"zgjsxx","email":"119160625@qq.com","commits":1}]},"readingTime":{"minutes":2.78,"words":833},"filePathRelative":"posts/datastructure_algorithm/monotonic-stack.md","localizedDate":"2024年8月10日","excerpt":"<ul>\\n<li><a href=\\"#%E5%8D%95%E8%B0%83%E6%A0%88\\">单调栈</a></li>\\n</ul>\\n<h1> 单调栈</h1>\\n<p>单调栈是一种栈的特殊应用，用于解决一类需要在数据序列中找到特定元素的“最近较大/较小值”的问题。它的核心思想是通过保持栈内元素的单调性（即元素从栈底到栈顶按某种顺序排列），来简化和优化这些问题的解决。</p>\\n<p>单调栈的种类</p>\\n<ul>\\n<li>单调递增栈：栈内元素从栈底到栈顶严格递增。也就是说，新加入栈的元素一定比栈顶元素大。用于查找每个元素左侧或者右侧第一个小于它的元素。</li>\\n<li>单调递减栈：栈内元素从栈底到栈顶严格递减。也就是说，新加入栈的元素一定比栈顶元素小。用于查找每个元素左侧或者右侧第一个大于它的元素。</li>\\n</ul>","autoDesc":true}');export{t as data};
