import{_ as t,V as d,W as e,a0 as h}from"./framework-9a29aaa0.js";const r={},a=h('<h1 id="modbus-tcp协议详解" tabindex="-1"><a class="header-anchor" href="#modbus-tcp协议详解" aria-hidden="true">#</a> modbus-TCP协议详解</h1><p>1996年施耐德公司推出基于以太网TCP/IP的modbus协议：modbus-TCP。</p><p>MODBUS-TCP使MODBUS-RTU协议运行于以太网，MODBUS-TCP使用TCP/IP以太网在站点间传送MODBUS报文，MODBUS-TCP结合了以太网物理网络和网络标准TCP/IP以及以MODBUS作为应用协议标准的数据表示方法。MODBUS-TCP通信报文包在以太网TCP/IP数据包中。与传统的串口方式，MODBUS-TCP插入一个标准的MODBUS报文到TCP报文中，不再带有数据校验和地址。</p><h2 id="modbus报文解析" tabindex="-1"><a class="header-anchor" href="#modbus报文解析" aria-hidden="true">#</a> MODBUS报文解析</h2><p>| MBAP Header | Function code | Data | | Header | PDU |</p><p>MBAP header包含下面几个部分：</p><ul><li>Transaction ID</li><li>Protocol ID</li><li>Length</li><li>UnitID</li></ul><table><thead><tr><th>id</th><th>名称</th><th>长度</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>Transaction ID 事务处理标识</td><td>2字节</td><td>报文的序列号，一般每次通讯加1，用于区别不同的报文</td></tr><tr><td>2</td><td>Protocol ID 协议标识</td><td>2字节</td><td>00 00 代表modbus-Tcp</td></tr><tr><td>3</td><td>Length</td><td>2字节</td><td>Unit长度 + PDU的长度</td></tr><tr><td>4</td><td>UnitID</td><td>单元标识符</td><td>1</td></tr></tbody></table><p>下面的这一串MBAP header|00 01| 00 00|00 06| 01 |， 其含义如下：</p><p>事务标识为1，协议是modbus-tcp协议，数据长度是：6，从站号是1。</p><p>需要注意的是MODBUS协议是一个<strong>大端</strong>的协议，前两个byte 00 01代表0x1 , 因此Transaction ID=1。而长度字段00 06代表0x6， 即UnitID和PDU的长度总和为6。</p><p>PDU部分相对复杂一些，主要是对一些寄存器进行读写操作。</p><p>modbus的操作对象有四种：<strong>线圈寄存器</strong>、<strong>离散输入寄存器</strong>、<strong>输入寄存器</strong>、<strong>保持寄存器</strong>。</p><table><thead><tr><th>寄存器种类</th><th>数据类型</th><th>访问类型</th><th>功能码</th></tr></thead><tbody><tr><td>线圈寄存器</td><td>bit</td><td>读写</td><td>01H 05H 0FH</td></tr><tr><td>离散输入寄存器</td><td>bit</td><td>只读</td><td>02H</td></tr><tr><td>输入寄存器</td><td>2 bytes(word)</td><td>只读</td><td>04H</td></tr><tr><td>保持寄存器</td><td>2 bytes(word)</td><td>读写</td><td>03H 06H 10H</td></tr></tbody></table><p>线圈寄存器和离散输入寄存器是以bit为单位的寄存器，只能存储开关量，线圈寄存器可读可写，而离散输入寄存器只可读。</p><p>输入寄存器和保持寄存器以为2个byte为单位的寄存器，可以存储离散的变量， 保持寄存器可读可写， 输入寄存器只读。</p><p>常用的功能码作用如下：</p><table><thead><tr><th>功能码</th><th>功能</th></tr></thead><tbody><tr><td>0x01</td><td>读单个或者多个线圈寄存器</td></tr><tr><td>0x02</td><td>读离散量输入寄存器</td></tr><tr><td>0x03</td><td>读保持寄存器</td></tr><tr><td>0x04</td><td>读输入寄存器</td></tr><tr><td>0x05</td><td>写单个线圈寄存器</td></tr><tr><td>0x06</td><td>写单个保持寄存器</td></tr><tr><td>0x10</td><td>写多个保持寄存器</td></tr><tr><td>0x0F</td><td>写多个线圈寄存器</td></tr></tbody></table><h2 id="常用功能码详解" tabindex="-1"><a class="header-anchor" href="#常用功能码详解" aria-hidden="true">#</a> 常用功能码详解</h2><h3 id="功能码0x1-读线圈寄存器" tabindex="-1"><a class="header-anchor" href="#功能码0x1-读线圈寄存器" aria-hidden="true">#</a> 功能码0x1：读线圈寄存器</h3><p>每个线圈寄存器可以存储一个bit的信息， 功能码0x01就是用于读取slave中线圈寄存器的状态，可以是<strong>单个线圈寄存器</strong>，也可以是<strong>多个连续的线圈寄存器</strong>。</p><p><strong>发送报文</strong></p><p>发送报文由下面几个部分组成，总共12字节：</p><p>MBAP header(7字节) + 功能码(1字节) + 线圈寄存器起始地址的高位（1字节） + 线圈寄存器起始地址的低位（1字节） + 线圈寄存器数量的高位（1字节） + 线圈寄存器数量的低位（1字节）</p><p>下面是一个用Modbus-Poll和Modbus-Slave测试的实际的例子，其含义是读取线圈寄存器的起始地址是0x0， 读取数量为 0x0a（十进制10）个。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/network/modbus-tcp/modbus-0x1-request.png" alt="0x1-request" tabindex="0" loading="lazy"><figcaption>0x1-request</figcaption></figure><table><thead><tr><th>MBAP header</th><th>功能码</th><th>起始地址高字节</th><th>起始地址低字节</th><th>寄存器数量的高位</th><th>寄存器数量的低位</th></tr></thead><tbody><tr><td>01 66 00 00 00 06 01</td><td>01</td><td>00</td><td>00</td><td>00</td><td>0a</td></tr></tbody></table><p>其中：</p><p>TransanctionID = 358, Length = 6。</p><p>功能码为0x1，代表读取线圈寄存器。</p><p>读取的线圈寄存器的起始地址为0。</p><p>读取的线圈寄存器的数量为0xa(十进制10)个。</p><p><strong>响应报文</strong></p><p>响应报文的长度不是固定的，长度和用户请求的数据长度有关，由下面几个部分组成：</p><p>MBAP header(7字节) + 功能码(1字节) + 线圈寄存器的值</p><p>下面是一个实际的响应报文的内容:</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/network/modbus-tcp/modbus-0x1-response.png" alt="0x1-request" tabindex="0" loading="lazy"><figcaption>0x1-request</figcaption></figure><table><thead><tr><th>MBAP header</th><th>功能码</th><th>字节数</th><th>请求的数据1</th><th>请求的数据2</th></tr></thead><tbody><tr><td>01 66 00 00 00 05 01</td><td>01</td><td>02</td><td>21</td><td>02</td></tr></tbody></table><p>返回的第一个字节21，转化为二进制为00100001， 其中bit0代表00寄存器，bit7代表07寄存器。</p><table><thead><tr><th>0x7</th><th>0x6</th><th>0x5</th><th>0x4</th><th>0x3</th><th>0x2</th><th>0x1</th><th>0x0</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr></tbody></table><p>返回的第二个字节02，转化为二进制为00000010， 其中bit0代表08寄存器，bit1代表09寄存器。</p><table><thead><tr><th>0x9</th><th>0x8</th></tr></thead><tbody><tr><td>1</td><td>0</td></tr></tbody></table><h3 id="功能码0x5-写单个线圈寄存器0x05" tabindex="-1"><a class="header-anchor" href="#功能码0x5-写单个线圈寄存器0x05" aria-hidden="true">#</a> 功能码0x5: 写单个线圈寄存器0x05：</h3><p>功能码0x5的作用是对单个线圈寄存器写值ON/OFF。</p><p><strong>发送报文</strong></p><p>发送报文由下面几个部分组成，总共12字节：</p><p>MBAP header(7字节) + 功能码(1字节) + 线圈寄存器起始地址的高位（1字节） + 线圈寄存器起始地址的低位（1字节） + 要写的值的高位（1字节） + 要写的值的低位（1字节）</p><p>将从站中的一个输出写成ON或OFF，0xFF00代表为ON,0x0000代表为OFF。</p><p>下面是一个实际的例子：</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/network/modbus-tcp/modbus-0x5-request.png" alt="0x5-request" tabindex="0" loading="lazy"><figcaption>0x5-request</figcaption></figure><table><thead><tr><th>MBAP header</th><th>功能码</th><th>起始地址高字节</th><th>起始地址低字节</th><th>写的值的高位</th><th>写的值的低位</th></tr></thead><tbody><tr><td>00 6f 00 00 00 06 01</td><td>05</td><td>00</td><td>04</td><td>ff</td><td>00</td></tr></tbody></table><p>在这个例子中，对从站01的0x4号线圈执行ON操作。</p><p><strong>响应报文</strong></p><p>可以看到，如果写单个线圈成功，返回报文的值和发送报文的值相同：</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/network/modbus-tcp/modbus-0x5-response.png" alt="0x5-request" tabindex="0" loading="lazy"><figcaption>0x5-request</figcaption></figure><h3 id="功能码0x0f-写多个线圈寄存器" tabindex="-1"><a class="header-anchor" href="#功能码0x0f-写多个线圈寄存器" aria-hidden="true">#</a> 功能码0x0F：写多个线圈寄存器</h3><p>将一个从站中的多个线圈寄存器的写为ON或OFF，数据域中置1的位请求相应输出位ON，置0的位请求响应输出为OFF。</p><p><strong>发送报文</strong></p><p>发送报文由下面几部分组成：</p><p>MBAP 功能码 + 起始地址H 起始地址L + 输出数量H 输出数量L + 字节长度 + 输出值H 输出值L</p><p>其总长度为 13 + (修改的线圈寄存器数量/8 + 1）。</p><p>下面是一个实际的例子</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/network/modbus-tcp/modbus-0xF-request.png" alt="0xF-request" tabindex="0" loading="lazy"><figcaption>0xF-request</figcaption></figure><p>按照协议进行对应的结果如下：</p><table><thead><tr><th>MBAP header</th><th>功能码</th><th>线圈寄存器起始位置</th><th>线圈寄存器的数量</th><th>字节数</th><th>第一个byte的值</th><th>第二个byte的值</th></tr></thead><tbody><tr><td>01 71 00 00 00 09 01</td><td>0f</td><td>00 00</td><td>00 0a</td><td>02</td><td>70</td><td>00</td></tr></tbody></table><p>其中第一个byte的值是0x70， 转换为二进制是01110000，其中低位bit0代表00寄存器，bit7代表07寄存器。</p><table><thead><tr><th>0x7</th><th>0x6</th><th>0x5</th><th>0x4</th><th>0x3</th><th>0x2</th><th>0x1</th><th>0x0</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>第二个byte的值是0x0， 转换为二进制是00000000，其中低位bit0代表08寄存器，bit1代表09寄存器。</p><table><thead><tr><th>0x9</th><th>0x8</th></tr></thead><tbody><tr><td>0</td><td>0</td></tr></tbody></table><p>该请求的作用起始就是将04 05 06寄存器的状态改为ON。</p><p><strong>返回报文</strong></p><p>返回的报文相对比较简单，由下面几个部分组成：</p><p>MBAP header + 功能码 + 起始地址H 起始地址L + 输出数量H 输出数量L</p><p>下面是一个实际的例子：</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/network/modbus-tcp/modbus-0xF-response.png" alt="0xF-response" tabindex="0" loading="lazy"><figcaption>0xF-response</figcaption></figure><p>按照协议对应各部分的内容如下：</p><table><thead><tr><th>MBAP header</th><th>功能码</th><th>线圈寄存器起始位置</th><th>线圈寄存器的数量</th></tr></thead><tbody><tr><td>01 71 00 00 00 06 01</td><td>0f</td><td>00 00</td><td>00 0a</td></tr></tbody></table><h3 id="功能码0x02-读离散量输入寄存器" tabindex="-1"><a class="header-anchor" href="#功能码0x02-读离散量输入寄存器" aria-hidden="true">#</a> 功能码0x02：读离散量输入寄存器</h3><p>功能码0x2和0x1是比较类似的。只是操作的离散量输入寄存器是只读的，没有写操作的接口。</p><p>每个离散量输入寄存器可以存储一个bit的信息， 功能码0x02就是用于读取slave中离散量输入寄存器的状态，可以是<strong>单个线圈寄存器</strong>，也可以是<strong>多个连续的线圈寄存器</strong>。</p><p><strong>发送报文</strong></p><p>发送报文由下面几个部分组成，总共12字节：</p><p>MBAP header(7字节) + 功能码(1字节) + 离散量输入寄存器起始地址的高位（1字节） + 离散量输入寄存器起始地址的低位（1字节） + 离散量输入寄存器数量的高位（1字节） + 离散量输入寄存器数量的低位（1字节）</p><p>下面是一个用Modbus-Poll和Modbus-Slave测试的实际的例子，其含义是读取线圈寄存器的起始地址是0x0， 读取数量为 0x0a（十进制10）个。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/network/modbus-tcp/modbus-0x2-request.png" alt="0x2-request" tabindex="0" loading="lazy"><figcaption>0x2-request</figcaption></figure><table><thead><tr><th>MBAP header</th><th>功能码</th><th>起始地址高字节</th><th>起始地址低字节</th><th>寄存器数量的高位</th><th>寄存器数量的低位</th></tr></thead><tbody><tr><td>01 b9 00 00 00 06 01</td><td>01</td><td>00</td><td>00</td><td>00</td><td>0a</td></tr></tbody></table><p>其中：</p><p>TransanctionID = 441, Length = 6。</p><p>功能码为0x1，代表读取线圈寄存器。</p><p>读取的线圈寄存器的起始地址为0。</p><p>读取的线圈寄存器的数量为0xa(十进制10)个。</p><p><strong>响应报文</strong></p><p>响应报文的长度不是固定的，长度和用户请求的数据长度有关，由下面几个部分组成：</p><p>MBAP header(7字节) + 功能码(1字节) + 离散量输入寄存器的值</p><p>下面是一个实际的响应报文的内容:</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/network/modbus-tcp/modbus-0x2-response.png" alt="0x2-request" tabindex="0" loading="lazy"><figcaption>0x2-request</figcaption></figure><table><thead><tr><th>MBAP header</th><th>功能码</th><th>字节数</th><th>请求的数据1</th><th>请求的数据2</th></tr></thead><tbody><tr><td>01 b9 00 00 00 05 01</td><td>01</td><td>02</td><td>12</td><td>02</td></tr></tbody></table><p>返回的第一个字节12，转化为二进制为00010010， 其中bit0代表00寄存器，bit7代表07寄存器。</p><table><thead><tr><th>0x7</th><th>0x6</th><th>0x5</th><th>0x4</th><th>0x3</th><th>0x2</th><th>0x1</th><th>0x0</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr></tbody></table><p>返回的第二个字节02，转化为二进制为00000010， 其中bit0代表08寄存器，bit1代表09寄存器。</p><table><thead><tr><th>0x9</th><th>0x8</th></tr></thead><tbody><tr><td>1</td><td>0</td></tr></tbody></table><h3 id="功能码0x03-读保持寄存器" tabindex="-1"><a class="header-anchor" href="#功能码0x03-读保持寄存器" aria-hidden="true">#</a> 功能码0x03：读保持寄存器</h3><p>功能码0x03用于读取保持寄存器的值，从远程设备中读保持寄存器连续块的内容。</p><p><strong>发送报文</strong></p><p>请求报文的结构如下：</p><p>MBAP header + 功能码 + 起始地址H 起始地址L + 寄存器数量H 寄存器数量L（共12字节）</p><p>下面是一个实际的例子：</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/network/modbus-tcp/modbus-0x3-request.png" alt="0x3-request" tabindex="0" loading="lazy"><figcaption>0x3-request</figcaption></figure><p>按照协议对照如下：</p><table><thead><tr><th>MBAP header</th><th>功能码</th><th>起始地址</th><th>寄存器数量</th></tr></thead><tbody><tr><td>05 f1 00 00 00 06 01</td><td>03</td><td>00 00</td><td>00 0a</td></tr></tbody></table><p><strong>响应报文</strong></p><p>响应报文的结构由下面几个部分组成：</p><p>MBAP header + 功能码 + 数据长度 + 寄存器数据</p><p>数据总长度 = 9 + 寄存器数量 × 2</p><p>下面是一个response的结构：</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/network/modbus-tcp/modbus-0x3-response.png" alt="0x3-response" tabindex="0" loading="lazy"><figcaption>0x3-response</figcaption></figure><p>从中我们可以提取出下面的对应关系：</p><table><thead><tr><th>MBAP header</th><th>功能码</th><th>字节数</th><th>第0byte值</th><th>第1byte值</th><th>第2byte值</th><th>第3byte值</th><th>第4byte值</th><th>第5byte值</th><th>第6byte值</th><th>第7byte值</th><th>第8byte值</th><th>第9byte值</th></tr></thead><tbody><tr><td>05 f1 00 00 00 17 01</td><td>03</td><td>14</td><td>01 2c</td><td>00 00</td><td>00 00</td><td>00 37</td><td>00 00</td><td>00 00</td><td>00 64</td><td>00 00</td><td>00 3c</td><td>00 00</td></tr></tbody></table><p>由上面的对应关系，我们可以提取出我们想要读取的保持寄存器的值：</p><table><thead><tr><th>第0个寄存器</th><th>第1个寄存器</th><th>第2个寄存器</th><th>第3个寄存器</th><th>第4个寄存器</th><th>第5个寄存器</th><th>第6个寄存器</th><th>第7个寄存器</th><th>第8个寄存器</th><th>第9个寄存器</th></tr></thead><tbody><tr><td>300</td><td>0</td><td>0</td><td>55</td><td>0</td><td>0</td><td>100</td><td>0</td><td>60</td><td>0</td></tr></tbody></table><h3 id="功能码0x04-读输入寄存器" tabindex="-1"><a class="header-anchor" href="#功能码0x04-读输入寄存器" aria-hidden="true">#</a> 功能码0x04：读输入寄存器</h3><p>功能码0x4用于读取输入寄存器的值，输入寄存器是只读的，因此没有功能码可以写输入寄存器。</p><p><strong>发送报文</strong></p><p>请求报文格式如下：</p><p>MBAP header + 功能码 + 起始地址H 起始地址L + 寄存器数量H 寄存器数量L（共12字节）</p><p>下面是一个实际的例子：</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/network/modbus-tcp/modbus-0x4-request.png" alt="0x4-request" tabindex="0" loading="lazy"><figcaption>0x4-request</figcaption></figure><table><thead><tr><th>MBAP header</th><th>功能码</th><th>起始地址</th><th>寄存器数量</th></tr></thead><tbody><tr><td>0b f8 00 00 00 06 01</td><td>04</td><td>00 00</td><td>00 0a</td></tr></tbody></table><p>该请求的含义是读取0-9号寄存器的值。</p><p><strong>响应报文</strong></p><p>响应报文的结构由下面几个部分组成：</p><p>MBAP header + 功能码 + 数据长度 + 寄存器数据</p><p>数据总长度 = 9 + 寄存器数量 × 2</p><p>下面是一个response的结构：</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/network/modbus-tcp/modbus-0x4-response.png" alt="0x4-response" tabindex="0" loading="lazy"><figcaption>0x4-response</figcaption></figure><p>从中我们可以提取出下面的对应关系：</p><table><thead><tr><th>MBAP header</th><th>功能码</th><th>字节数</th><th>第0byte值</th><th>第1byte值</th><th>第2byte值</th><th>第3byte值</th><th>第4byte值</th><th>第5byte值</th><th>第6byte值</th><th>第7byte值</th><th>第8byte值</th><th>第9byte值</th></tr></thead><tbody><tr><td>0b f8 00 00 00 17 01</td><td>04</td><td>14</td><td>00 00</td><td>00 00</td><td>00 c8</td><td>00 00</td><td>01 2c</td><td>00 00</td><td>00 00</td><td>00 00</td><td>00 42</td><td>00 00</td></tr></tbody></table><p>由上面的对应关系，我们可以提取出我们想要读取的保持寄存器的值：</p><table><thead><tr><th>第0个寄存器</th><th>第1个寄存器</th><th>第2个寄存器</th><th>第3个寄存器</th><th>第4个寄存器</th><th>第5个寄存器</th><th>第6个寄存器</th><th>第7个寄存器</th><th>第8个寄存器</th><th>第9个寄存器</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>200</td><td>0</td><td>300</td><td>0</td><td>0</td><td>0</td><td>66</td><td>0</td></tr></tbody></table><h3 id="功能码0x06-写单个保持寄存器" tabindex="-1"><a class="header-anchor" href="#功能码0x06-写单个保持寄存器" aria-hidden="true">#</a> 功能码0x06：写单个保持寄存器</h3><p>在一个远程设备中写一个保持寄存器。</p><p><strong>发送报文</strong></p><p>请求报文格式如下：</p><p>MBAP header + 功能码 + 寄存器地址H 寄存器地址L + 寄存器值H 寄存器值L（共12字节）</p><p>下面是一个实际的例子:</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/network/modbus-tcp/modbus-0x6-request.png" alt="0x6-request" tabindex="0" loading="lazy"><figcaption>0x6-request</figcaption></figure><table><thead><tr><th>MBAP header</th><th>功能码</th><th>保持寄存器地址</th><th>保持寄存器的值</th></tr></thead><tbody><tr><td>1F 97 00 00 00 06 01</td><td>06</td><td>00 04</td><td>00 64</td></tr></tbody></table><p>该请求的含义是向地址为0x4的寄存器写入100。</p><p><strong>响应报文</strong></p><p>响应报文如下：</p><p>MBAP header + 功能码 + 寄存器地址H 寄存器地址L + 寄存器值H 寄存器值L（共12字节）</p><p>成功响应的报文与发送报文格式相同。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/network/modbus-tcp/modbus-0x6-response.png" alt="0x6-response" tabindex="0" loading="lazy"><figcaption>0x6-response</figcaption></figure><h3 id="功能码0x10-写多个保持寄存器" tabindex="-1"><a class="header-anchor" href="#功能码0x10-写多个保持寄存器" aria-hidden="true">#</a> 功能码0x10：写多个保持寄存器</h3><p>在一个远程设备中写连续寄存器块（1~123个寄存器）</p><p><strong>发送报文</strong></p><p>请求报文格式如下：</p><p>MBAP header + 功能码 + 起始地址H 起始地址L + 寄存器数量H 寄存器数量L + 字节长度 + 寄存器值（13+寄存器数量×2）</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/network/modbus-tcp/modbus-0x10-request.png" alt="0x10-request" tabindex="0" loading="lazy"><figcaption>0x10-request</figcaption></figure><table><thead><tr><th>MBAP header</th><th>功能码</th><th>起始地址</th><th>长度</th><th>字节数</th><th>字节0数据</th><th>字节1数据</th><th>字节2数据</th><th>字节3数据</th><th>字节4数据</th><th>字节5数据</th><th>字节6数据</th><th>字节7数据</th><th>字节8数据</th><th>字节9数据</th></tr></thead><tbody><tr><td>00 26 00 00 00 1b 01</td><td>10</td><td>00 00</td><td>00 0a</td><td>14 00</td><td>00 00</td><td>00 00</td><td>00 00</td><td>00 00</td><td>00 c8</td><td>00 00</td><td>00 00</td><td>00 64</td><td>00 00</td><td>00 64</td></tr></tbody></table><p><strong>响应报文</strong></p><p>响应报文如下：</p><p>MBAP header + 功能码 + 起始地址H 起始地址L + 寄存器数量H 寄存器数量L（共12字节）</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/network/modbus-tcp/modbus-0x10-response.png" alt="0x10-response" tabindex="0" loading="lazy"><figcaption>0x10-response</figcaption></figure><table><thead><tr><th>MBAP header</th><th>功能码</th><th>起始地址</th><th>长度</th></tr></thead><tbody><tr><td>00 26 00 00 00 1b 01</td><td>10</td><td>00 00</td><td>00 0a</td></tr></tbody></table><h2 id="实用调试工具" tabindex="-1"><a class="header-anchor" href="#实用调试工具" aria-hidden="true">#</a> 实用调试工具</h2><p>在研究modbus的过程中， 大量的使用了modbus poll和 modbus slave软件，这个软件可以很好的帮助理解modbus-tcp协议。</p><p>modbus poll： modbus客户端工具(主站)</p><p>modbus slave: modbus服务端工具(从站)</p>',169),p=[a];function o(s,i){return d(),e("div",null,p)}const b=t(r,[["render",o],["__file","modbus-tcp.html.vue"]]);export{b as default};
