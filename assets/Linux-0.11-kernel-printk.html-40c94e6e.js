import{_ as n,V as s,W as a,a0 as t}from"./framework-c954d91f.js";const e={},p=t(`<h1 id="linux-0-11-kernel目录printk-c详解" tabindex="-1"><a class="header-anchor" href="#linux-0-11-kernel目录printk-c详解" aria-hidden="true">#</a> Linux-0.11 kernel目录printk.c详解</h1><h2 id="printk" tabindex="-1"><a class="header-anchor" href="#printk" aria-hidden="true">#</a> printk</h2><p>是什么导致一个运行在内核态而另一个运行用户态?</p><p>其实这两个函数几乎是相同的, 出现这种差异是因为 tty_write 函数需要使用 fs 指向的被显示的字符串, 而 fs 是专门用于存放用户态段选择符的, 因此, 在内核态时, 为了配合 tty_write函数, printk 会把 fs 修改为内核态数据段选择符 ds 中的值, 这样才能正确指向内核的数据缓冲区, 当然这个操作会先对 fs 进行压栈保存, 调用 tty_write 完毕后再出栈恢复. 总结说来, printk 与 printf 的差异是由 fs 造成的, 所以差异也是围绕对 fs 的处理。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>va_list args<span class="token punctuation">;</span>
<span class="token keyword">int</span> i<span class="token punctuation">;</span>

<span class="token function">va_start</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> fmt<span class="token punctuation">)</span><span class="token punctuation">;</span>
i<span class="token operator">=</span><span class="token function">vsprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span>fmt<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将字符串格式化到buf中</span>
<span class="token function">va_end</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">__asm__</span><span class="token punctuation">(</span><span class="token string">&quot;push %%fs\\n\\t&quot;</span><span class="token comment">//将当前的fs保存起来</span>
  <span class="token string">&quot;push %%ds\\n\\t&quot;</span><span class="token comment">//将当前的ds放入栈</span>
  <span class="token string">&quot;pop %%fs\\n\\t&quot;</span><span class="token comment">//fs = ds</span>
  <span class="token string">&quot;pushl %0\\n\\t&quot;</span><span class="token comment">//字符串长度 ax寄存器</span>
  <span class="token string">&quot;pushl $buf\\n\\t&quot;</span><span class="token comment">//将buf地址压入栈中</span>
  <span class="token string">&quot;pushl $0\\n\\t&quot;</span><span class="token comment">//将数值0压入栈中，代表显示通道</span>
  <span class="token string">&quot;call tty_write\\n\\t&quot;</span><span class="token comment">//调用tty_write tty_write(unsigned channel, char * buf, int nr)</span>
  <span class="token string">&quot;addl $8,%%esp\\n\\t&quot;</span>
  <span class="token string">&quot;popl %0\\n\\t&quot;</span><span class="token comment">//将长度发给到ax寄存器中</span>
  <span class="token string">&quot;pop %%fs&quot;</span><span class="token comment">//将fs弹出</span>
  <span class="token operator">::</span><span class="token string">&quot;r&quot;</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">:</span><span class="token string">&quot;ax&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;cx&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;dx&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> i<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,5),o=[p];function i(c,l){return s(),a("div",null,o)}const r=n(e,[["render",i],["__file","Linux-0.11-kernel-printk.html.vue"]]);export{r as default};
