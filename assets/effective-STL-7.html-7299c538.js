const e=JSON.parse('{"key":"v-17b517e7","path":"/posts/Program_language/cpp/effective-STL/effective-STL-7.html","title":"effective STL-7 当使用new的指针的容器时,记得在销毁容器前delete那些指针","lang":"zh-CN","frontmatter":{"category":["C++"],"tag":["C++","effective STL读书笔记"],"description":"effective STL-7 当使用new的指针的容器时,记得在销毁容器前delete那些指针 条款7：当使用new得指针的容器时，记得在销毁容器前delete那些指针 STL中的容器非常优秀。它们提供了前向和逆向遍历的迭代器（通过begin、end、rbegin等）；它们能告诉你所容纳的对象类型（通过value_type的typedef）；在插入和删除中，它们负责任何需要的内存管理；它们报告容纳了多少对象和最多可能容纳的数量（分别通过size和max_size）；而且当然当容器自己被销毁时会自动销毁容纳的每个对象。 给了这样聪明的容器，很多程序员不再担心用完以后的清除工作。呵呵，他们说，他们的容器会帮他们解决那个麻烦。在很多情况下，他们是对的，但当容器容纳的是指向通过new分配的对象的指针时，他们就错了。的确，当一个指针的容器被销毁时，会销毁它（那个容器）包含的每个元素，但指针的“析构函数”是无操作！它肯定不会调用delete。","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/Program_language/cpp/effective-STL/effective-STL-7.html"}],["meta",{"property":"og:site_name","content":"Code Building"}],["meta",{"property":"og:title","content":"effective STL-7 当使用new的指针的容器时,记得在销毁容器前delete那些指针"}],["meta",{"property":"og:description","content":"effective STL-7 当使用new的指针的容器时,记得在销毁容器前delete那些指针 条款7：当使用new得指针的容器时，记得在销毁容器前delete那些指针 STL中的容器非常优秀。它们提供了前向和逆向遍历的迭代器（通过begin、end、rbegin等）；它们能告诉你所容纳的对象类型（通过value_type的typedef）；在插入和删除中，它们负责任何需要的内存管理；它们报告容纳了多少对象和最多可能容纳的数量（分别通过size和max_size）；而且当然当容器自己被销毁时会自动销毁容纳的每个对象。 给了这样聪明的容器，很多程序员不再担心用完以后的清除工作。呵呵，他们说，他们的容器会帮他们解决那个麻烦。在很多情况下，他们是对的，但当容器容纳的是指向通过new分配的对象的指针时，他们就错了。的确，当一个指针的容器被销毁时，会销毁它（那个容器）包含的每个元素，但指针的“析构函数”是无操作！它肯定不会调用delete。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-05-31T02:38:48.000Z"}],["meta",{"property":"article:tag","content":"C++"}],["meta",{"property":"article:tag","content":"effective STL读书笔记"}],["meta",{"property":"article:modified_time","content":"2023-05-31T02:38:48.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"effective STL-7 当使用new的指针的容器时,记得在销毁容器前delete那些指针\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-05-31T02:38:48.000Z\\",\\"author\\":[]}"]]},"headers":[],"git":{"createdTime":1685500728000,"updatedTime":1685500728000,"contributors":[{"name":"zgjsxx","email":"119160524@qq.com","commits":1}]},"readingTime":{"minutes":6.75,"words":2024},"filePathRelative":"posts/Program_language/cpp/effective-STL/effective-STL-7.md","localizedDate":"2023年5月31日","excerpt":"<h1> effective STL-7 当使用new的指针的容器时,记得在销毁容器前delete那些指针</h1>\\n<p>条款7：当使用new得指针的容器时，记得在销毁容器前delete那些指针\\nSTL中的容器非常优秀。它们提供了前向和逆向遍历的迭代器（通过begin、end、rbegin等）；它们能告诉你所容纳的对象类型（通过value_type的typedef）；在插入和删除中，它们负责任何需要的内存管理；它们报告容纳了多少对象和最多可能容纳的数量（分别通过size和max_size）；而且当然当容器自己被销毁时会自动销毁容纳的每个对象。</p>\\n<p>给了这样聪明的容器，很多程序员不再担心用完以后的清除工作。呵呵，他们说，他们的容器会帮他们解决那个麻烦。在很多情况下，他们是对的，但当容器容纳的是指向通过new分配的对象的指针时，他们就错了。的确，当一个指针的容器被销毁时，会销毁它（那个容器）包含的每个元素，但指针的“析构函数”是无操作！它肯定不会调用delete。</p>","autoDesc":true}');export{e as data};
