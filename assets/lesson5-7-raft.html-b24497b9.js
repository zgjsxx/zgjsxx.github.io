import{_ as t,V as r,W as a,a0 as i}from"./framework-9a29aaa0.js";const l={},e=i('<ul><li><a href="#raft%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95">raft一致性算法</a><ul><li><a href="#raft%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80">raft算法基础</a></li></ul></li></ul><h1 id="raft一致性算法" tabindex="-1"><a class="header-anchor" href="#raft一致性算法" aria-hidden="true">#</a> raft一致性算法</h1><h2 id="raft算法基础" tabindex="-1"><a class="header-anchor" href="#raft算法基础" aria-hidden="true">#</a> raft算法基础</h2><p>一个 Raft 集群包含若干个服务器；通常有五个，这使得系统可以容忍两个节点发生故障。</p><p>在任何特定时间，每个服务器都处于三种状态之一：<strong>领导者</strong>（leader）、<strong>跟随者</strong>（follower）或者<strong>候选者</strong>（candidate）。</p><ul><li>在正常运行时，只有<strong>一个领导者</strong>，其他所有服务器<strong>都是跟随者</strong>。</li><li>跟随者是被动的，它们自身不发出请求，而只是响应来自领导者和候选者的请求。</li><li>领导者处理所有客户端请求， 如果客户端与一个跟随者联系，跟随者会将<strong>其重定向到领导者</strong>。</li><li>候选者是一个特殊状态，用于选举新的领导者。</li></ul><p>下图展示了这些状态及其转换：</p><figure><img src="https://github.com/zgjsxx/static-img-repo/raw/main/blog/lesson/6.824/raft-server-state.png" alt="raft服务器状态" tabindex="0" loading="lazy"><figcaption>raft服务器状态</figcaption></figure><p>下一个要介绍的概念是<strong>任期</strong>。Raft 算法将时间划分为任意长度的任期，任期用<strong>连续的整数编号</strong>。每个任期都以一次选举开始，在选举中，一个或多个候选人尝试成为领导者。如果一个候选人在选举中获胜，那么它将在该任期的剩余时间里担任领导者。在某些情况下，选举会导致选票分散。在这种情况下，该任期将结束且没有领导者；一个新的任期（伴随着新的选举）很快就会开始。Raft 算法确保在一个特定任期内最多只有一个领导者。</p><figure><img src="https://github.com/zgjsxx/static-img-repo/raw/main/blog/lesson/6.824/raft-term.png" alt="raft任期" tabindex="0" loading="lazy"><figcaption>raft任期</figcaption></figure><p>关于raft，有以下几点需要说明：</p><ul><li>每个任期的开始都是从<strong>选举</strong>开始，选举时可能有多个都试图成为leader。</li><li>某个candidate赢得选举之后，就会成为该任期内的leader。</li><li>每个节点都记录了当前的<strong>任期号</strong>（currentTerm），这个编号时随着时间单调递增。</li><li>节点通信时，会带上自己的任期号 <ul><li>如果自己的任期号小于其他节点的，要立即将自己的任期号更新为更大的任期号。</li><li>如果一个candidate或leader发现自己的任期过期了，要立即切换到follower状态。</li><li>如果一个节点收到了携带过期任期编号的请求，会拒绝这个请求。</li></ul></li></ul>',12),n=[e];function o(s,f){return r(),a("div",null,n)}const c=t(l,[["render",o],["__file","lesson5-7-raft.html.vue"]]);export{c as default};
