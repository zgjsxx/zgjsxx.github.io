import{_ as o,V as i,W as s,X as e,Y as d,$ as n,a0 as a,F as r}from"./framework-9a29aaa0.js";const l={},t=a(`<h1 id="第十七讲-z80汇编语言-任天堂游戏机和德州仪器计算器" tabindex="-1"><a class="header-anchor" href="#第十七讲-z80汇编语言-任天堂游戏机和德州仪器计算器" aria-hidden="true">#</a> 第十七讲：Z80汇编语言(任天堂游戏机和德州仪器计算器)</h1><h2 id="寄存器" tabindex="-1"><a class="header-anchor" href="#寄存器" aria-hidden="true">#</a> 寄存器</h2><p>Z80 有 8 个或 5 个通用寄存器，具体取决于您如何看待事物：</p><ul><li>寄存器 <code>A</code>、<code>F</code>、<code>B</code>、<code>C</code>、<code>D</code>、<code>E</code>、<code>H</code> 和 <code>L</code> 可以单独用作 8 位寄存器</li><li>寄存器对<code>BC</code>、<code>DE</code>和<code>HL</code>可用作16位寄存器，其中<code>B</code>是 <code>BC</code> 的高字节，而 <code>C</code> 是低字节。</li><li>有点奇怪的是，<code>A</code> 寄存器可以与标志寄存器 <code>F</code> 组合起来作为 16 位寄存器 <code>AF</code>。</li><li>寄存器 <code>IX</code> 和 <code>IY</code> 是 16 位索引寄存器，与内存操作数一起使用。 <code>HL</code> 类似地用于内存操作数。</li></ul><p>与 <code>x86</code> 一样，<code>SP</code> 寄存器指向堆栈顶部，<code>PC</code> 寄存器指向当前指令（请注意，这与 x86 的 IP 寄存器指向下一条指令不同）。<code>F</code>寄存器包含标志：符号、零、奇偶校验/溢出、满进位。<code>A</code> 和 <code>F</code> 寄存器可以通过几条指令组合成一个 16 位寄存器 <code>AF</code>。</p><p>Z80有一个中断向量寄存器I，其中包含中断向量表的地址，这个设计很有先见之明；在这个时代的Intel CPU中，中断向量的地址是固定在内存中的。</p><p>与 x86 不同，Z80 有一组影子寄存器；这是一组附加寄存器 <code>A&#39;</code>、<code>F&#39;</code>、<code>B&#39;</code>、<code>C&#39;</code>、<code>D&#39;</code>、<code>E&#39;</code>、<code>H&#39;</code> 和 <code>L&#39;</code>。</p><p>您无法直接访问这些寄存器，但可以使用一条指令交换主寄存器组和影子寄存器组。</p><p>这提供了一种简单但有限的方法来保存所有寄存器的值，然后在以后恢复它们（但是，与堆栈不同，您只能保存一组寄存器值）。</p><h2 id="指令集" tabindex="-1"><a class="header-anchor" href="#指令集" aria-hidden="true">#</a> 指令集</h2><p>大多数 Z80 汇编器使用的语法更像 AT&amp;T 语法而不是 Intel 语法。这意味着指令具有以下形式</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>   INSTRUCTION DESTINATION, SOURCE
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>内存的操作写在括号中。</p>`,13),p={href:"https://www.ticalc.org/pub/text/z80/z80_reference.txt",target:"_blank",rel:"noopener noreferrer"},u=a(`<p><code>mov</code> 已重命名为 <code>ld</code>（&quot;加载&quot;），但它可用于将值写入寄存器或内存。例如:</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>    ld  a, 5             ; Set register A = 5
    ld  b, 7             ; Set register B = 7
    add a, b             ; Set A = A + B
    ld [Output], a       ; Write A into address Output
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（一些 Z80 汇编器将内存操作数写在括号 () 中，而其他汇编器（例如我们将要使用的汇编器）则使用更熟悉的 [])。</p><p><code>add</code> 指令只能使用 <code>a</code>、<code>hl</code>、<code>ix</code> 或 <code>iy</code> 作为其目标。内存操作数可以使用立即地址，或者您可以执行类似的操作</p><div class="language-X86asm line-numbers-mode" data-ext="X86asm"><pre class="language-X86asm"><code>ld [hl], a ; Write A into the address contained in HL
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果要在内存操作数中使用立即地址加寄存器，则寄存器必须是 <code>IX</code> 或 <code>IY</code>：</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>ld [Array + ix], a   ; Write A into Array[ix]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>与 x86 一样，<code>ld</code> 的两个操作数必须具有相同的大小：均为 8 位或均为 16 位。根据需要，立即操作数将提升为 16 位。</p><p>Z80 指令的大小为 1 到 3 个字节。</p><h2 id="条件跳转" tabindex="-1"><a class="header-anchor" href="#条件跳转" aria-hidden="true">#</a> 条件跳转</h2><p>有两种条件跳转指令：</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>    jp CC, Target           ; 条件绝对跳转

    jr CC, Target           ; 条件相对跳转
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中 CC 是条件代码。两者的主要区别是<code>jp</code>更灵活（可以使用更多条件，速度更快），而<code>jr</code>更有限（条件更少，速度更慢，只能在程序内跳转±128字节）但只占用2个字节程序而不是 <code>jp</code> 的 3 个字节。</p><p>更专门的条件跳转指令是 <code>djnz</code>，类似于 x86 中的<code>loop</code>，它代表&quot;递减，如果非零则跳转&quot;</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code> djnz Target          ; Decrement B, jump to Target if B ≠ 0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="函数" tabindex="-1"><a class="header-anchor" href="#函数" aria-hidden="true">#</a> 函数</h2><p><code>call</code>与 x86 一样，用于调用函数，它压入 <code>PC+3</code>，然后跳转到函数地址。 （请记住，<code>PC</code> 包含当前指令的地址；即 <code>call</code> 指令本身。<code>call</code> 指令占用 3 个字节，因此下一条指令是 <code>PC+3</code>。）类似地，<code>ret</code> 通过弹出 <code>PC</code> 和跳向它。</p><p>与 x86 不同，Z80 有条件返回指令：</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>ret p               ; Return if positive (sign flag = 0)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可用条件有 C/NC（进位设置/未设置）、M/P（符号 = 1/0）、Z/NZ（零 = 1/0）、PE/PO（奇偶校验 = 1/2）。这些与条件跳转指令 jp CC 所使用的条件相同.</p><p><code>push</code> 和 <code>pop</code> 可用于将寄存器压入堆栈或从堆栈中弹出。只有16位寄存器可以压入/弹出，所以如果你想压入A，你必须结合标志寄存器来压入它：</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code> push af
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="块传输" tabindex="-1"><a class="header-anchor" href="#块传输" aria-hidden="true">#</a> 块传输</h2>`,23);function m(v,h){const c=r("ExternalLinkIcon");return i(),s("div",null,[t,e("p",null,[d("你可以在这里查找到完整的Z80指令集： "),e("a",p,[d("Z80指令集"),n(c)])]),u])}const g=o(l,[["render",m],["__file","Lecture17-xx.html.vue"]]);export{g as default};
