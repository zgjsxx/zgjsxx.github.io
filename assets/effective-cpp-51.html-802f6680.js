import{_ as n,V as s,W as a,a0 as e}from"./framework-9a29aaa0.js";const p={},t=e(`<h1 id="effective-c-51-编写new和delete时需固守常规" tabindex="-1"><a class="header-anchor" href="#effective-c-51-编写new和delete时需固守常规" aria-hidden="true">#</a> effective c++ 51 编写new和delete时需固守常规</h1><p>本节主要讲解了如果我们需要重载operator new/operator delete，我们需要遵守的一些套路。</p><h2 id="分析" tabindex="-1"><a class="header-anchor" href="#分析" aria-hidden="true">#</a> 分析</h2><h3 id="new-0-bytes的处理" tabindex="-1"><a class="header-anchor" href="#new-0-bytes的处理" aria-hidden="true">#</a> new 0 bytes的处理</h3><p>C++ 规定，即使客户要求 0 bytes， operator new 也得返回一个合法指针。如下面 non-member operator new 伪代码：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t size<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>bad_alloc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        尝试分配 size bytes<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>分配成功<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> <span class="token punctuation">(</span>一个指针，指向分配得来的内存<span class="token punctuation">)</span>；
        <span class="token punctuation">}</span>
        <span class="token comment">// 分配失败；找出目前的 new-handling 函数</span>
        new_handler globalHandler <span class="token operator">=</span> <span class="token function">set_new_handler</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">set_new_handler</span><span class="token punctuation">(</span>globalHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>globalHandler<span class="token punctuation">)</span>
          <span class="token punctuation">(</span><span class="token operator">*</span>globalHandler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
          <span class="token keyword">throw</span> std<span class="token double-colon punctuation">::</span><span class="token function">bad_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的技术是将 0 bytes 申请量视为 1 byte 申请。</p><h3 id="继承体系中的operator-new" tabindex="-1"><a class="header-anchor" href="#继承体系中的operator-new" aria-hidden="true">#</a> 继承体系中的operator new</h3><p>operator new 成员函数会被 derived classes 继承。</p><p>写出定制型内存管理器的一个最常见理由是为了针对某特定 class 的对象分配行为提供最优化，却不是为了该 class 的任何 derived classes.</p><p>针对 class Q 而设计的 operator new， 其行为很典型地只为大小刚好为 sizeof(Q) 的对象而设计。而一旦被继承下去，很可能 base class 的operator new 被调用以分配 derived class 对象。</p><p>解决办法就是：将“内存申请量错误”的调用行为改为标准 operator new</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span><span class="token operator">*</span> Base<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t size<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>bad_alloc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>size <span class="token operator">!=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Base<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果大小错误，</span>
        <span class="token keyword">return</span> <span class="token double-colon punctuation">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 令标准的 operator new 处理</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// 否则在这里处理</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里C++会裁定所有非附属（独立式) 对象必须有非零大小，因此 sizeof(Base) 无论如何不能为0，如果 size 为0，这份申请会被转交到 <code>::operator new</code> 手上，后者有责任以某种合理方式对待这份申请。</p><p>因此，不能在 <code>Base::operator new[]</code> 内假设 array 的每个元素对象的大小是 <code>sizeof(Base)</code>，意味着不能假设 array 的元素对象的个数是（bytes 申请数）/ sizeof(Base)</p><p>此外，传递给 <code>operator new[]</code> 的 size_t 参数，其值有可能比“将被填以对象”的内存数量更多，动态分配的arrays 可能包含额外空间用来存放元素个数。</p><h3 id="delete-null指针" tabindex="-1"><a class="header-anchor" href="#delete-null指针" aria-hidden="true">#</a> delete null指针</h3><p>C++ 保证&quot;删除 null 指针永远安全&quot;，必须保证这项实现。</p><p><strong>non-member 版本</strong></p><p>下面是 non-member operator delete 伪代码：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span> rawMemory<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>rawMemory <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 如果被删除的指针是 null 指针，那就什么都不做</span>
  现在，归还 rawMemory 所指的内存。
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>member版本</strong></p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t size<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>bad_alloc<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> rawMemory<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t size<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> Base<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> rawMemory<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t size<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>rawMemory <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 检查 null 指针</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">!=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Base<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment">// 如果大小错误，</span>
        <span class="token double-colon punctuation">::</span><span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span>rawMemory<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 令标准版 operator delete 处理此申请</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    现在归还 rawMemory 所指的内存
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果被删除的derived class 来自于某个 base class，而base class 欠缺 virtual 析构函数，那么 C++ 传给 operator delete 的 size_t 数值可能不正确， operator delete 可能无法正确运作。</p><p>这就是为什么&quot;base class 需要拥有 virtual 析构函数&quot;的原因。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><ul><li>operator new应该内含一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就应该调用new-handler。它也应该有能力处理0 bytes申请。Class专属版本则还应该处理&quot;比正确大小更大的(错误)申请&quot;。</li><li>operator delete应该在收到null指针时不做任何事。Class专属版本则还应该处理&quot;比正确大小更大的(错误)申请&quot;。</li></ul>`,27),o=[t];function c(l,i){return s(),a("div",null,o)}const r=n(p,[["render",c],["__file","effective-cpp-51.html.vue"]]);export{r as default};
