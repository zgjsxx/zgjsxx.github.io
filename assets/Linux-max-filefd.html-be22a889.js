import{_ as n,V as s,W as a,a0 as e}from"./framework-9a29aaa0.js";const i={},t=e(`<h1 id="linux-最大可以打开多少文件描述符" tabindex="-1"><a class="header-anchor" href="#linux-最大可以打开多少文件描述符" aria-hidden="true">#</a> Linux 最大可以打开多少文件描述符？</h1><p>在日常开发中，对文件的操作可谓是再寻常不过的一件事情。那么你是否有这样一个疑问，我最多可以打开多少个文件呢？</p><p>在Linux系统中，当某个程序<strong>打开文件</strong>时，内核会返回相应的<strong>文件描述符</strong> (fd: file descriptors），也就是所谓的文件句柄，程序为了处理该文件必须引用此描述符。</p><p><strong>文件描述符</strong>是大于等于0的整数，其可以标明每一个被进程所打开的文件和 socket。最前面的三个文件描述符（0，1，2）分别与标准输入（stdin），标准输出（stdout）和标准错误（stderr）对应，后面打开的文件依此类推对应 3、4…… 。</p><p>从文件描述符的描述中得知，其是按照每个进程来分配的。于是上面的问题&quot;我最多可以打开多少个文件&quot;就可以进一步细化为下面几个问题</p><ul><li>一个进程最多可以打开多少个文件描述符</li><li>一个用户最多可以打开多少个文件描述符</li><li>一个系统最多可以打开多少个文件描述符</li></ul><p>顺着这样的思路，下面就开始进行探索。</p><h2 id="一个进程最多可以打开多少个文件描述符" tabindex="-1"><a class="header-anchor" href="#一个进程最多可以打开多少个文件描述符" aria-hidden="true">#</a> 一个进程最多可以打开多少个文件描述符?</h2><p>下面的代码是一个用于测试能最多可以打开多少文件描述符的方法。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">//g++ main.cpp -o main</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;climits&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    size_t MAX<span class="token operator">=</span> UINT_MAX<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">&quot;./file.txt&quot;</span><span class="token punctuation">,</span>O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">==</span> fd<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span><span class="token string">&quot;open file %d  stderr, %s\\n&quot;</span><span class="token punctuation">,</span> i <span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用<code>std::cin.get()</code>停在了程序退出前，目的是为了去<code>/proc</code>文件系统下查看最大的文件描述符。使用下面的shell命令就可以得到运行的程序所打开的最大的文件描述符。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">ls</span> /proc/<span class="token operator">&lt;</span>process id<span class="token operator">&gt;</span>/fd <span class="token operator">|</span> <span class="token function">sort</span> <span class="token parameter variable">-n</span> <span class="token operator">|</span> <span class="token function">tail</span> <span class="token parameter variable">-n</span> <span class="token number">1</span>
<span class="token number">1023</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在我的测试环境中，上面的命令输出了1023。由于文件描述符是从0开始算起的，因此，实际上该进程最大打开了1024个文件描述符。</p><p>那么这个最大打开1024个文件的限制是在哪里的呢？</p><p>Linux <strong>ulimit</strong>命令用于控制shell程序的资源。 <strong>ulimit</strong>为shell内建指令，可用来控制shell执行程序的资源。</p><p><code>ulimit -n</code>即可查看当前允许打开的最大的文件描述符数量。</p><p>尝试修改最大的文件描述符数量：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># ulimit -n 10240</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># ulimit -n</span>
<span class="token number">10240</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样我们再次运行上面的程序进行测试：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># ls /proc/44570/fd | sort -n | tail -n 1</span>
<span class="token number">10239</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这个时候就发现系统可以打开的文件描述符数量已经达到了10239个。</p><p>上面我们通过<code>ulimit -n</code>成功的将当前进程可以打开的文件描述符提高到了10240个。 那么我们最多可以设置到多少呢？总不能可以无限制的修改下去把。</p><p>答案藏在Linux的<strong>nr_open</strong>文件中，<strong>nr_open</strong>用于限制<strong>单个进程</strong>可以分配的<strong>最大文件描述符</strong>，该限制对于系统上<strong>所有用户下</strong>的<strong>所有进程</strong>都生效，查看当时如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">cat</span> /proc/sys/fs/nr_open
<span class="token number">1073741816</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在我的系统中，如果设置了一个比nr_open更大的值将会抛出错误。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># ulimit -n 10000000000</span>
-bash: ulimit: <span class="token function">open</span> files: cannot modify limit: Operation not permitted
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的过程中，我们修改进程可以打开文件描述符的上限是使用<strong>ulimit命令</strong>，但是<strong>ulimit命令</strong>更改后只是在当前会话生效，当退出当前会话重新登录后又会回到默认值1024，要永久更改则需要修改文件 <code>/etc/security/limit.conf</code>。</p><p><strong>limit.conf</strong>中可以设置很多与用户限制相关的内容。</p><p>其格式如下所示：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">#&lt;domain&gt;        &lt;type&gt;  &lt;item&gt;  &lt;value&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>domain: 代表限制的对象，对哪些用户生效。其可以是一个用户名，也可以是一个用户组的名字，可以使用通配符*和%。</li><li>type: 仅仅有两种， soft和hard。 soft的限制的值不能超过hard限制的值。</li><li>item： 代表可以限制的内容, 可以有下面的一些选项可以设置 <ul><li>core - 显示coredump文件的大小 (单位KB)</li><li>data - 最大数据大小 (单位KB)</li><li>fsize - 最大文件大小 (单位KB)</li><li>memlock - 最大锁定内存地址空间 (单位KB)</li><li>nofile - 最大可以打开的文件描述符的数量</li><li>rss - 最大驻留集大小 (单位KB)</li><li>stack - 最大栈的大小 (KB)</li><li>cpu - 最多CPU占用时间，单位为MIN分钟</li><li>nproc - 最大可以打开的进程数量</li><li>as - 地址空间限制 (KB)</li><li>maxlogins - 用户可以同时登录的最大数量</li><li>maxsyslogins - 系统最大允许的登录数量</li><li>priority - 运行用户进程的优先级</li><li>locks - 用户可以持有的文件锁的最大数量</li><li>sigpending - 最大挂起信号数</li><li>msgqueue - POSIX 消息队列使用的最大内存 (单位 bytes)</li><li>nice - 允许的最大优先级提高到值 [-20，19]</li><li>rtprio - 最大实时优先级</li></ul></li><li>value： 就是为item设置的具体的数值。</li></ul><p>我们的需求是设置文件描述符的上限，因此item就是nofile。</p><p>加入下面的语句：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>tom hard nofile <span class="token number">10240</span>&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其含义是<strong>tom用户</strong>创建的<strong>每个进程</strong>的打开的最大的文件描述符数量不能超过硬限制<strong>10240</strong>。</p><p>这里顺便再提一下<strong>soft</strong>和<strong>hard</strong>的区别， 达到 soft 限制会在系统的日志（一般为<code>/var/log/messages</code>）里面记录一条告警日志，但不影响使用。达到hard的限制，有日志且会影响使用。</p><p>因此hard limit才是真正的限制。</p><p>从这样的实验中我们得出了结论：</p><p>一个进程可以打开的文件描述符 &lt; hard limit &lt; nr_open</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/Linux/application-dev/linux-max-file-fd/process-max-fd.png" alt="process open fd" tabindex="0" loading="lazy"><figcaption>process open fd</figcaption></figure><p>但是这里其实还有操作系统的资源的隐含限制，虽然你可以将进程的最大描述符设置的非常大，然而打开一个文件描述符是需要消耗一定的内存的，当文件描述打开非常多时，可能就会出现OOM的状况。 因此实际进程能打开的文件描述符可能还受<strong>内存资源</strong>的限制。</p><h2 id="一个用户最多可以打开多少个文件描述符" tabindex="-1"><a class="header-anchor" href="#一个用户最多可以打开多少个文件描述符" aria-hidden="true">#</a> 一个用户最多可以打开多少个文件描述符</h2><p>实际上一个用户可以打开的最大文件描述符 = （用于打开的最大进程数） * （每个进程最大可以打开的文件描述符数量）</p><p>每个进程可以打开的文件描述符数量在第一个问题中已经得到了解决。</p><p>那么这个问题就变成了一个用户最多可以打开多少个进程。</p><p>其中<code>ulimit -u</code>就可以设置当前shell可以打开的进程数量。</p><p>如果需要永久更改，则还是通过更改limits.conf文件。</p><p>方案一: 修改<code>/etc/security/limits.conf</code>文件, 在文件最后添加下述内容:</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>*  soft      nproc      <span class="token number">131072</span>
*  hard      nproc      <span class="token number">131072</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>方案二: 修改/etc/security/limits.d/90-nproc.conf文件, 在文件最后添加下述内容:</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 用户进程数的默认限制, 下面这个是对root外的其他用户限制max user processes, 要注释掉: </span>
<span class="token comment"># *          soft    nproc     1024</span>
root       soft    nproc     <span class="token number">131072</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对max user processes的配置, Linux系统默认先读取/etc/security/limits.conf 中的信息, 如果<code>/etc/security/limits.d/</code>目录下还有配置文件的话, 也会依次遍历读取, 最终, <code>/etc/security/limits.d/</code>中的配置会覆盖\`\`\`/etc/security/limits.conf\`\`\`\`\`\` 中的配置。</p><p>除上述限制以外，操作系统还有一个全局的限制，pid_max，用于设置操作系统可以打开的进程的总数量。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">cat</span> /proc/sys/kernel/pid_max
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>知道了这些限制之后，一个用户最多可以打开多少个文件描述符也迎刃而解了。 即用户打开的最大进程数 &lt; hard limit &lt; pid_max。</p><p>不过一个用户最多可以打开多少个文件描述符在实际开发中并不怎么需要去关注，更多的时候还是去关心一个进程最多可以打开多少文件描述符。</p><h2 id="一个系统最多可以打开多少个文件描述符" tabindex="-1"><a class="header-anchor" href="#一个系统最多可以打开多少个文件描述符" aria-hidden="true">#</a> 一个系统最多可以打开多少个文件描述符</h2><p>操作系统对于文件描述符有一个全局的限制， 其定义在<code>/proc/sys/fs/file-max</code>中，例如在我的系统中，其值如下所示：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">cat</span> /proc/sys/fs/file-max
<span class="token number">9223372036854775807</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到这个数值是非常大的，一般情况下都不会达到，因为达到该限制会有巨大的内存消耗。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><ul><li>一个进程可以打开的文件描述符的数量小于hard limit，而hard limit的值要小于nr_open。但是实际能打开的文件描述符的最大数量还和系统资源有关。</li><li>一个用户可以打开的文件描述符数量等于一个进程可以打开的文件描述符的数量* 一个用户最大可以打开的进程数量。</li><li>一个系统可以打开的文件描述符数量即所有用户的所有进程打开的文件描述符总数量受file-max限制。</li></ul>`,62),p=[t];function l(o,c){return s(),a("div",null,p)}const d=n(i,[["render",l],["__file","Linux-max-filefd.html.vue"]]);export{d as default};
