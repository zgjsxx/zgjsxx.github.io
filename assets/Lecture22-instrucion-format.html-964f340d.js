import{_ as h,V as n,W as s,X as t,Y as e,$ as a,a0 as r,F as i}from"./framework-9a29aaa0.js";const o={},l=r(`<h1 id="第二十二讲-指令格式" tabindex="-1"><a class="header-anchor" href="#第二十二讲-指令格式" aria-hidden="true">#</a> 第二十二讲 指令格式</h1><h2 id="mips32指令格式" tabindex="-1"><a class="header-anchor" href="#mips32指令格式" aria-hidden="true">#</a> MIPS32指令格式</h2><p>我们先前研究指令流水线是提到过<strong>MIPS32</strong>。<strong>MIPS32</strong>使用固定长度的指令，每个指令32位。MIPS32存在三种不同的指令格式，但这三种指令格式都使用高6位作为操作码。</p><h3 id="r指令格式" tabindex="-1"><a class="header-anchor" href="#r指令格式" aria-hidden="true">#</a> R指令格式</h3><p>R 指令格式具有三个寄存器的字段（通常为两个源寄存器和一个目标寄存器），以及移位量（5 位）和函数（6 位），其它用于没有立即操作数的算术/按位指令。</p><table><thead><tr><th>Opcode = 000000</th><th>RS</th><th>RT</th><th>RD</th><th>Sh.Amt</th><th>Func</th></tr></thead><tbody><tr><td>6bits</td><td>5</td><td>5</td><td>5</td><td>5</td><td>6</td></tr></tbody></table><h3 id="i指令格式" tabindex="-1"><a class="header-anchor" href="#i指令格式" aria-hidden="true">#</a> I指令格式</h3><p>I 指令格式包含两个寄存器（通常是源寄存器和目标寄存器）和 16 位立即值的字段。 I 格式用于带有立即数操作数的算术运算，也用于使用基址+位移内存寻址方案的加载/存储指令（位移存储在立即数字段中，并且仅限于 16 位，有符号）</p><table><thead><tr><th>Opcode</th><th>RS</th><th>RD</th><th>Immediate/Address</th></tr></thead><tbody><tr><td>6bits</td><td>5bits</td><td>5bits</td><td>16bits</td></tr></tbody></table><p>例1：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>00000000001000100001100000100000 <span class="token operator">=</span> 0x00221820
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>因为高 6 位是 0，这是一个算术运算，使用 R 编码，所以我们将指令分解为</p><table><thead><tr><th>000000</th><th>00001</th><th>00010</th><th>00011</th><th>00000</th><th>100000</th></tr></thead><tbody><tr><td>Opcode</td><td>Rs</td><td>Rt</td><td>Rd</td><td>sh.amt</td><td>Operation</td></tr></tbody></table><p>两个源寄存器是r1和r2；目标寄存器是r3 该操作是32，对应于add指令，因此解码为add r3, r1, r2</p><p>例2：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>00001000110110101100010000100110
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><table><thead><tr><th>000010</th><th>00110110101100010000100110</th></tr></thead><tbody><tr><td>Opcode</td><td>Address</td></tr></tbody></table><p>例3：</p><p>001000 00001 00010 0000000000100101</p><p>操作码是8，它既不是R指令也不是J指令，所以它必须使用I格式：</p><p>addi r2, r1, 37</p><h2 id="x86-64操作码的格式" tabindex="-1"><a class="header-anchor" href="#x86-64操作码的格式" aria-hidden="true">#</a> x86-64操作码的格式</h2>`,22),c={href:"https://www.intel.cn/content/www/cn/zh/content-details/782158/intel-64-and-ia-32-architectures-software-developer-s-manual-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html",target:"_blank",rel:"noopener noreferrer"},p=r('<p>基本指令格式如下：</p><table><thead><tr><th>Field</th><th>Prefixes</th><th>Opcode</th><th>ModR/M</th><th>SIB</th><th>Displacement</th><th>Immediate</th></tr></thead><tbody><tr><td>size(bytes)</td><td>1-4</td><td>1,2,3</td><td>0,1</td><td>0,1</td><td>0,1,2,4,8</td><td>0,1,2,4,8</td></tr></tbody></table><p>最大指令大小限制为 15 个字节。构建比这更大的理论指令是可能的，但它们是非法的。请注意，一些指令允许 8 字节立即数或 8 字节地址，但显然不能同时使用两者。有四组前缀 1-4，并且每组只能出现一个前缀。这些组可以按任何顺序给出，但 REX 前缀（如果存在）必须是最后一个前缀（即，应紧接在操作码之前）。因为所有 64 位指令都使用 REX 前缀，这意味着我们使用的每条指令都至少包含 REX 后跟操作码。</p><p>某些前缀对于某些指令是强制性的，表明这些指令必须存在前缀字节，尽管它没有其正常含义。当存在强制前缀时，它必须紧邻操作码之前（或者，如果使用，则放在 REX 前缀之前）。强制前缀通常用于通过将现有操作码用于不同目的来“扩展”可用操作码的空间。</p><p>前缀组是：</p><ul><li>锁定和重复前缀。锁定用于指示应以原子方式执行指令。重复前缀的值为 0xF2 (repne) 和 0xF3 (repe/rep)。对于一些不相关的指令来说，这些前缀是必需的。</li><li>段覆盖前缀。这些前缀指示指令应使用与其正常解释不同的段寄存器（如果启用了分段）。</li><li>操作数大小覆盖，编码为 0x66。这会在 16 位（默认）和 32 位（如果使用前缀）大小的操作数之间切换。某些 SSE 指令是强制性的。</li><li>地址大小覆盖，编码为 0x67。在 16 位和 32 位地址大小之间切换。默认值由当前处理器模式设置；如果存在前缀，则选择非默认大小。</li></ul><h3 id="前缀" tabindex="-1"><a class="header-anchor" href="#前缀" aria-hidden="true">#</a> 前缀</h3><p>前缀用于修改指令。例如，重复前缀<code>rep</code>、<code>repne</code>和<code>repe</code>都是前缀。他们适用于现有的字符串指令。</p>',8),b={href:"https://staffwww.fullcoll.edu/aclifton/cs241/lecture-instruction-format.html",target:"_blank",rel:"noopener noreferrer"};function u(m,f){const d=i("ExternalLinkIcon");return n(),s("div",null,[l,t("p",null,[e("x86架构的指令格式在intel的手册中可以查到："),t("a",c,[e("intel手册"),a(d)])]),p,t("p",null,[t("a",b,[e("https://staffwww.fullcoll.edu/aclifton/cs241/lecture-instruction-format.html"),a(d)])])])}const _=h(o,[["render",u],["__file","Lecture22-instrucion-format.html.vue"]]);export{_ as default};
