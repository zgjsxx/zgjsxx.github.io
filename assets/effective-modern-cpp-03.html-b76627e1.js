const n=JSON.parse('{"key":"v-e42bd3f6","path":"/posts/Program_language/cpp/effective-modern-cpp/effective-modern-cpp-03.html","title":"Item3：理解decltype","lang":"zh-CN","frontmatter":{"category":["C++","effective Modern C++"],"description":"Item3：理解decltype 本文主要讨论c++中的decltype。 decltype是一个奇怪的东西。给它一个名字或者表达式decltype就会告诉你这个名字或者表达式的类型。通常，它会精确的告诉你你想要的结果。但有时候它得出的结果也会让你挠头半天，最后只能求助网上问答或参考资料寻求启示。 我们将从一个简单的情况开始，没有任何令人惊讶的情况。相比模板类型推导和auto类型推导（参见Item1和Item2），decltype只是简单的返回名字或者表达式的类型： const int i = 0; //decltype(i)是const int bool f(const Widget&amp; w); //decltype(w)是const Widget&amp; //decltype(f)是bool(const Widget&amp;) struct Point{ int x,y; //decltype(Point::x)是int }; //decltype(Point::y)是int Widget w; //decltype(w)是Widget if (f(w))… //decltype(f(w))是bool template&lt;typename T&gt; //std::vector的简化版本 class vector{ public: … T&amp; operator[](std::size_t index); … }; vector&lt;int&gt; v; //decltype(v)是vector&lt;int&gt; … if (v[0] == 0)… //decltype(v[0])是int&amp;","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/Program_language/cpp/effective-modern-cpp/effective-modern-cpp-03.html"}],["meta",{"property":"og:site_name","content":"Code Building"}],["meta",{"property":"og:title","content":"Item3：理解decltype"}],["meta",{"property":"og:description","content":"Item3：理解decltype 本文主要讨论c++中的decltype。 decltype是一个奇怪的东西。给它一个名字或者表达式decltype就会告诉你这个名字或者表达式的类型。通常，它会精确的告诉你你想要的结果。但有时候它得出的结果也会让你挠头半天，最后只能求助网上问答或参考资料寻求启示。 我们将从一个简单的情况开始，没有任何令人惊讶的情况。相比模板类型推导和auto类型推导（参见Item1和Item2），decltype只是简单的返回名字或者表达式的类型： const int i = 0; //decltype(i)是const int bool f(const Widget&amp; w); //decltype(w)是const Widget&amp; //decltype(f)是bool(const Widget&amp;) struct Point{ int x,y; //decltype(Point::x)是int }; //decltype(Point::y)是int Widget w; //decltype(w)是Widget if (f(w))… //decltype(f(w))是bool template&lt;typename T&gt; //std::vector的简化版本 class vector{ public: … T&amp; operator[](std::size_t index); … }; vector&lt;int&gt; v; //decltype(v)是vector&lt;int&gt; … if (v[0] == 0)… //decltype(v[0])是int&amp;"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-05-11T06:58:32.000Z"}],["meta",{"property":"article:modified_time","content":"2023-05-11T06:58:32.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Item3：理解decltype\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-05-11T06:58:32.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1683788312000,"updatedTime":1683788312000,"contributors":[{"name":"zgjsxx","email":"119160524@qq.com","commits":1}]},"readingTime":{"minutes":11.36,"words":3408},"filePathRelative":"posts/Program_language/cpp/effective-modern-cpp/effective-modern-cpp-03.md","localizedDate":"2023年5月11日","excerpt":"<h1> Item3：理解decltype</h1>\\n<p>本文主要讨论c++中的decltype。</p>\\n<p>decltype是一个奇怪的东西。给它一个名字或者表达式decltype就会告诉你这个名字或者表达式的类型。通常，它会精确的告诉你你想要的结果。但有时候它得出的结果也会让你挠头半天，最后只能求助网上问答或参考资料寻求启示。</p>\\n<p>我们将从一个简单的情况开始，没有任何令人惊讶的情况。相比模板类型推导和auto类型推导（参见Item1和Item2），decltype只是简单的返回名字或者表达式的类型：</p>\\n<div class=\\"language-cpp line-numbers-mode\\" data-ext=\\"cpp\\"><pre class=\\"language-cpp\\"><code><span class=\\"token keyword\\">const</span> <span class=\\"token keyword\\">int</span> i <span class=\\"token operator\\">=</span> <span class=\\"token number\\">0</span><span class=\\"token punctuation\\">;</span>                <span class=\\"token comment\\">//decltype(i)是const int</span>\\n\\n<span class=\\"token keyword\\">bool</span> <span class=\\"token function\\">f</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">const</span> Widget<span class=\\"token operator\\">&amp;</span> w<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>        <span class=\\"token comment\\">//decltype(w)是const Widget&amp;</span>\\n                                <span class=\\"token comment\\">//decltype(f)是bool(const Widget&amp;)</span>\\n\\n<span class=\\"token keyword\\">struct</span> <span class=\\"token class-name\\">Point</span><span class=\\"token punctuation\\">{</span>\\n    <span class=\\"token keyword\\">int</span> x<span class=\\"token punctuation\\">,</span>y<span class=\\"token punctuation\\">;</span>                    <span class=\\"token comment\\">//decltype(Point::x)是int</span>\\n<span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">;</span>                              <span class=\\"token comment\\">//decltype(Point::y)是int</span>\\n\\nWidget w<span class=\\"token punctuation\\">;</span>                       <span class=\\"token comment\\">//decltype(w)是Widget</span>\\n\\n<span class=\\"token keyword\\">if</span> <span class=\\"token punctuation\\">(</span><span class=\\"token function\\">f</span><span class=\\"token punctuation\\">(</span>w<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">)</span>…                      <span class=\\"token comment\\">//decltype(f(w))是bool</span>\\n\\n<span class=\\"token keyword\\">template</span><span class=\\"token operator\\">&lt;</span><span class=\\"token keyword\\">typename</span> <span class=\\"token class-name\\">T</span><span class=\\"token operator\\">&gt;</span>            <span class=\\"token comment\\">//std::vector的简化版本</span>\\n<span class=\\"token keyword\\">class</span> <span class=\\"token class-name\\">vector</span><span class=\\"token punctuation\\">{</span>\\n<span class=\\"token keyword\\">public</span><span class=\\"token operator\\">:</span>\\n    …\\n    T<span class=\\"token operator\\">&amp;</span> <span class=\\"token keyword\\">operator</span><span class=\\"token punctuation\\">[</span><span class=\\"token punctuation\\">]</span><span class=\\"token punctuation\\">(</span>std<span class=\\"token double-colon punctuation\\">::</span>size_t index<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n    …\\n<span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">;</span>\\n\\nvector<span class=\\"token operator\\">&lt;</span><span class=\\"token keyword\\">int</span><span class=\\"token operator\\">&gt;</span> v<span class=\\"token punctuation\\">;</span>                  <span class=\\"token comment\\">//decltype(v)是vector&lt;int&gt;</span>\\n…\\n<span class=\\"token keyword\\">if</span> <span class=\\"token punctuation\\">(</span>v<span class=\\"token punctuation\\">[</span><span class=\\"token number\\">0</span><span class=\\"token punctuation\\">]</span> <span class=\\"token operator\\">==</span> <span class=\\"token number\\">0</span><span class=\\"token punctuation\\">)</span>…                 <span class=\\"token comment\\">//decltype(v[0])是int&amp;</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{n as data};
