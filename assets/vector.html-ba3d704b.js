import{_ as n,V as s,W as a,a0 as e}from"./framework-9a29aaa0.js";const p={},t=e(`<h1 id="vector" tabindex="-1"><a class="header-anchor" href="#vector" aria-hidden="true">#</a> vector</h1><p>vector是STL中使用最为广泛的容器之一，vector的动态内存的管理功能给我们写程序带来了很大的便利性。本节就通过分析MyTinySTL中关于vector的源码了解其实现原理。</p><h2 id="分析" tabindex="-1"><a class="header-anchor" href="#分析" aria-hidden="true">#</a> 分析</h2><h3 id="vector数据部分的定义" tabindex="-1"><a class="header-anchor" href="#vector数据部分的定义" aria-hidden="true">#</a> vector数据部分的定义</h3><p>下面是vector这个模板类数据部分的定义。可以看到public部分都是一些类型定义， 例如迭代器类型，const迭代器类型，reverse迭代器类型， const reverse迭代器类型等等。</p><p>private部分比较简单，就是三个<strong>原始指针</strong>类型的迭代器。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">vector</span>
<span class="token punctuation">{</span>
    <span class="token keyword">static_assert</span><span class="token punctuation">(</span><span class="token operator">!</span>std<span class="token double-colon punctuation">::</span>is_same<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">,</span> T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">,</span> <span class="token string">&quot;vector&lt;bool&gt; is abandoned in mystl&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// vector 的嵌套型别定义</span>
    <span class="token keyword">typedef</span> mystl<span class="token double-colon punctuation">::</span>allocator<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span>                      allocator_type<span class="token punctuation">;</span>
    <span class="token keyword">typedef</span> mystl<span class="token double-colon punctuation">::</span>allocator<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span>                      data_allocator<span class="token punctuation">;</span>

    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">allocator_type</span><span class="token double-colon punctuation">::</span>value_type      value_type<span class="token punctuation">;</span>
    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">allocator_type</span><span class="token double-colon punctuation">::</span>pointer         pointer<span class="token punctuation">;</span>
    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">allocator_type</span><span class="token double-colon punctuation">::</span>const_pointer   const_pointer<span class="token punctuation">;</span>
    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">allocator_type</span><span class="token double-colon punctuation">::</span>reference       reference<span class="token punctuation">;</span>
    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">allocator_type</span><span class="token double-colon punctuation">::</span>const_reference const_reference<span class="token punctuation">;</span>
    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">allocator_type</span><span class="token double-colon punctuation">::</span>size_type       size_type<span class="token punctuation">;</span>
    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">allocator_type</span><span class="token double-colon punctuation">::</span>difference_type difference_type<span class="token punctuation">;</span>

    <span class="token keyword">typedef</span> value_type<span class="token operator">*</span>                              iterator<span class="token punctuation">;</span>
    <span class="token keyword">typedef</span> <span class="token keyword">const</span> value_type<span class="token operator">*</span>                        const_iterator<span class="token punctuation">;</span>
    <span class="token keyword">typedef</span> mystl<span class="token double-colon punctuation">::</span>reverse_iterator<span class="token operator">&lt;</span>iterator<span class="token operator">&gt;</span>        reverse_iterator<span class="token punctuation">;</span>
    <span class="token keyword">typedef</span> mystl<span class="token double-colon punctuation">::</span>reverse_iterator<span class="token operator">&lt;</span>const_iterator<span class="token operator">&gt;</span>  const_reverse_iterator<span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    iterator begin_<span class="token punctuation">;</span>  <span class="token comment">// 表示目前使用空间的头部</span>
    iterator end_<span class="token punctuation">;</span>    <span class="token comment">// 表示目前使用空间的尾部</span>
    iterator cap_<span class="token punctuation">;</span>    <span class="token comment">// 表示目前储存空间的尾部</span>
<span class="token punctuation">}</span>；
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们的模板参数T为int，vector数据部分就如下所示：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">vector</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span>：
    <span class="token keyword">typedef</span> <span class="token keyword">int</span><span class="token operator">*</span>  iterator<span class="token punctuation">;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span><span class="token operator">*</span> begin_<span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token operator">*</span> end_<span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token operator">*</span> cap_<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们的模板参数为一个类，比如Widget，vector数据部分就如下所示：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Widget</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">vector</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span>：
    <span class="token keyword">typedef</span> Widget<span class="token operator">*</span>  iterator<span class="token punctuation">;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    Widget<span class="token operator">*</span> begin_<span class="token punctuation">;</span>
    Widget<span class="token operator">*</span> end_<span class="token punctuation">;</span>
    Widget<span class="token operator">*</span> cap_<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="vector-noexcept" tabindex="-1"><a class="header-anchor" href="#vector-noexcept" aria-hidden="true">#</a> vector() noexcept</h3><p><code>vector() noexcept</code>是一个默认的构造函数，并承若不抛出异常。 其内部调用了try_init方法进行初始化。</p><h3 id="try-init" tabindex="-1"><a class="header-anchor" href="#try-init" aria-hidden="true">#</a> try_init</h3><p>try_init是对内存进行初始化的方法，如果初始化失败，就将rollback，将所有指针置0。下面是try_init的源码。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token class-name">vector</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">try_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span>
<span class="token punctuation">{</span>
    <span class="token keyword">try</span>
    <span class="token punctuation">{</span>
        begin_ <span class="token operator">=</span> data_allocator<span class="token double-colon punctuation">::</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        end_ <span class="token operator">=</span> begin_<span class="token punctuation">;</span>
        cap_ <span class="token operator">=</span> begin_ <span class="token operator">+</span> <span class="token number">16</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        begin_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        end_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        cap_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中调用了<code>data_allocator::allocate</code>去分配内存，默认大小是16一个T类型的大小。</p><p><code>data_allocator::allocate</code>的实现也很简单，直接调用<code>::operator new</code>去申请16个T类型的内存大小。注意这里并不会调用构造函数，它仅仅是分配了内存空间。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
T<span class="token operator">*</span> <span class="token class-name">allocator</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">allocate</span><span class="token punctuation">(</span>size_type n<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token double-colon punctuation">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>n <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="push-back" tabindex="-1"><a class="header-anchor" href="#push-back" aria-hidden="true">#</a> push_back</h3><p>push_back是vector中一个非常重要的方法。应重点了解。包括其与emplace_back的区别也是十分重要，在很多大厂的面试题中非常高频的出现。</p><p>下面是push_back的源码。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token class-name">vector</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> value<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>end_ <span class="token operator">!=</span> cap_<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        data_allocator<span class="token double-colon punctuation">::</span><span class="token function">construct</span><span class="token punctuation">(</span>mystl<span class="token double-colon punctuation">::</span><span class="token function">address_of</span><span class="token punctuation">(</span><span class="token operator">*</span>end_<span class="token punctuation">)</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">++</span>end_<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
        <span class="token function">reallocate_insert</span><span class="token punctuation">(</span>end_<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码主要分为两个分支，第一个分支代表不需要扩容， 第二个分支代表需要扩容。</p><p>在第一个分支中，首先判断end_是否抵达了cap_的边界处，如果没有抵达边界，可以继续在尾部构建。这里调用了<code>data_allocator::construct</code>方法进行构建。</p><p>这里的construct实际上内部使用了placement new方法将对象构建在指定的内存上，并且是调用了复制构造函数进行的构建。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Ty1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Ty2</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">construct</span><span class="token punctuation">(</span>Ty1<span class="token operator">*</span> ptr<span class="token punctuation">,</span> <span class="token keyword">const</span> Ty2<span class="token operator">&amp;</span> value<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token double-colon punctuation">::</span><span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>ptr<span class="token punctuation">)</span> <span class="token function">Ty1</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里需要说的是作者使用了<code>mystl::address_of</code>用于获取对象地址，然而该实现可能是不正确的。因为如果重载了<code>operator&amp;</code>方法后，上述输出就可能有问题。 如果使用<code>std::addressof</code>可以解决。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Tp</span><span class="token operator">&gt;</span>
<span class="token keyword">constexpr</span> Tp<span class="token operator">*</span> <span class="token function">address_of</span><span class="token punctuation">(</span>Tp<span class="token operator">&amp;</span> value<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&amp;</span>value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,29),o=[t];function c(l,i){return s(),a("div",null,o)}const u=n(p,[["render",c],["__file","vector.html.vue"]]);export{u as default};
