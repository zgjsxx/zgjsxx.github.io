import{_ as e,V as s,W as a,a0 as t}from"./framework-9a29aaa0.js";const d={},n=t(`<h1 id="item35-优先考虑基于任务的编程而非基于线程的编程" tabindex="-1"><a class="header-anchor" href="#item35-优先考虑基于任务的编程而非基于线程的编程" aria-hidden="true">#</a> Item35：优先考虑基于任务的编程而非基于线程的编程</h1><p>通常我们想执行一个异步任务的时候，通常会采用线程的方法。本节介绍了一种新的方法，即<code>std::async</code>。其和<code>std::thread</code>有很大的相似性。</p><p><code>std::async</code>的一个调用的例子如下所示：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">auto</span> fut <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>doAsyncWork<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;fut&quot;表示&quot;future&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>从调用的形式可以看出，std::async会返回一个<code>std::future</code>对象，这将让我们很方便的线程获取返回值。</p><p>因为线程存在处理线程耗尽、资源超额、负责均衡问题，如果我们使用<code>std::thread</code>,就需要自己处理上述问题。但是<code>std::async</code>则会帮助我们处理这些问题。</p><p>上述便是两点<code>std::async</code>的优势。本节是建议大家在解决问题时，可以优先考虑<code>std::async</code>,因为其简单易用。 但是这不意味着不使用<code>std::thread</code>。</p><p>在下面的场景中，<code>std::thread</code>更具有优势：</p><ul><li>你需要访问非常基础的线程API。C++并发API通常是通过操作系统提供的系统级API（pthreads或者Windows threads）来实现的，系统级API通常会提供更加灵活的操作方式（举个例子，C++没有线程优先级和亲和性的概念）。为了提供对底层系统级线程API的访问，std::thread对象提供了native_handle的成员函数，而std::future（即std::async返回的东西）没有这种能力。</li><li>你需要且能够优化应用的线程使用。举个例子，你要开发一款已知执行概况的服务器软件，部署在有固定硬件特性的机器上，作为唯一的关键进程。</li><li>你需要实现C++并发API之外的线程技术，比如，C++实现中未支持的平台的线程池。</li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><ul><li>std::thread API不能直接访问异步执行的结果，如果执行函数有异常抛出，代码会终止执行。</li><li>基于线程的编程方式需要手动的线程耗尽、资源超额、负责均衡、平台适配性管理。</li><li>通过带有默认启动策略的std::async进行基于任务的编程方式会解决大部分问题。</li></ul>`,11),c=[n];function o(i,p){return s(),a("div",null,c)}const r=e(d,[["render",o],["__file","effective-modern-cpp-35.html.vue"]]);export{r as default};
