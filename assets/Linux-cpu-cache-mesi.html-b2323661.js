import{_ as n,V as t,W as r,X as e,Y as c,$ as i,a0 as h,F as o}from"./framework-9a29aaa0.js";const l={},s=h('<h1 id="cpu缓存哪些事儿" tabindex="-1"><a class="header-anchor" href="#cpu缓存哪些事儿" aria-hidden="true">#</a> CPU缓存哪些事儿</h1><h2 id="cache-line" tabindex="-1"><a class="header-anchor" href="#cache-line" aria-hidden="true">#</a> cache line</h2><p>cache line 又分为多种类型，分别为直接映射缓存，多路组相连缓存，全相连缓存。</p><h3 id="直接映射缓存" tabindex="-1"><a class="header-anchor" href="#直接映射缓存" aria-hidden="true">#</a> 直接映射缓存</h3><p>将一个内存地址划分为三块，分别是Tag, Index，Offset。</p><p>将cacheline理解为一个数组，那么通过Index则是数组的下标，通过Index就可以获取对应的cache-line。才获取cache-line的数据后，获取其中的Tag值，将其与地址中的Tag值进行对比，如果相同，则代表该内存地址位于该cache line中。最后根据Offset的值去data数组中获取对应的数据。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/Linux/application-dev/CPU-cache/cpu-cache-line.png" alt="cache line" tabindex="0" loading="lazy"><figcaption>cache line</figcaption></figure><p>下面是一个例子：</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/Linux/application-dev/CPU-cache/cpu-cache-line2.png" alt="cache line" tabindex="0" loading="lazy"><figcaption>cache line</figcaption></figure><h3 id="多路组相连缓存" tabindex="-1"><a class="header-anchor" href="#多路组相连缓存" aria-hidden="true">#</a> 多路组相连缓存</h3><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/Linux/application-dev/CPU-cache/multi-way.png" alt="cache line" tabindex="0" loading="lazy"><figcaption>cache line</figcaption></figure><h3 id="全相连缓存" tabindex="-1"><a class="header-anchor" href="#全相连缓存" aria-hidden="true">#</a> 全相连缓存</h3><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/Linux/application-dev/CPU-cache/full-connected.png" alt="cache line" tabindex="0" loading="lazy"><figcaption>cache line</figcaption></figure><p>全连接缓存中所有的cache line都位于一个组(set)内，因此地址中将不会划出一部分作为index。在判断cache line是否命中时，需要遍历所有的cache line，将其与虚拟地址中的tag成分进行对比，如果相等，则意味着匹配上了。因此对于全连接缓存而言，任意地址的数据可以缓存在任意的cache line中，这可以避免缓存的颠簸，但是与此同时，硬件上的成本也是最高。</p><h2 id="参考文献" tabindex="-1"><a class="header-anchor" href="#参考文献" aria-hidden="true">#</a> 参考文献</h2>',15),d={href:"https://www.scss.tcd.ie/Jeremy.Jones/VivioJS/caches/MESIHelp.htm",target:"_blank",rel:"noopener noreferrer"},p={href:"https://cloud.tencent.com/developer/article/1495957",target:"_blank",rel:"noopener noreferrer"};function g(u,f){const a=o("ExternalLinkIcon");return t(),r("div",null,[s,e("p",null,[e("a",d,[c("https://www.scss.tcd.ie/Jeremy.Jones/VivioJS/caches/MESIHelp.htm"),i(a)]),e("a",p,[c("https://cloud.tencent.com/developer/article/1495957"),i(a)])])])}const m=n(l,[["render",g],["__file","Linux-cpu-cache-mesi.html.vue"]]);export{m as default};
