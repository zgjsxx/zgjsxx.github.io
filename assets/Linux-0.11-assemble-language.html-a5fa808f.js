import{_ as a,V as e,W as s,a0 as n}from"./framework-9a29aaa0.js";const d={},i=n(`<ul><li><a href="#linux-011%E4%B8%AD%E7%9A%84%E6%B1%87%E7%BC%96">Linux-0.11中的汇编</a><ul><li><a href="#%E5%86%85%E5%B5%8C%E6%B1%87%E7%BC%96">内嵌汇编</a></li><li><a href="#movx">mov(x)</a></li><li><a href="#add">add</a></li><li><a href="#sub">sub</a></li><li><a href="#mul">mul</a></li><li><a href="#div">div</a></li><li><a href="#lea">lea</a></li><li><a href="#lds">lds</a></li><li><a href="#lss%E6%8C%87%E4%BB%A4">lss指令</a></li><li><a href="#lodsblodsw">lodsb/lodsw</a></li><li><a href="#stosbstosw">stosb/stosw</a></li><li><a href="#xorl">xorl</a></li><li><a href="#and">AND</a></li><li><a href="#std%E5%92%8Ccld">std和cld</a></li><li><a href="#test">test</a></li><li><a href="#jcc">jcc</a></li></ul></li></ul><h1 id="linux-0-11中的汇编" tabindex="-1"><a class="header-anchor" href="#linux-0-11中的汇编" aria-hidden="true">#</a> Linux-0.11中的汇编</h1><h2 id="内嵌汇编" tabindex="-1"><a class="header-anchor" href="#内嵌汇编" aria-hidden="true">#</a> 内嵌汇编</h2><p>基本的格式是：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">asm</span> <span class="token punctuation">(</span> <span class="token string">&quot;statements&quot;</span> 
    <span class="token operator">:</span> output_regs 
    <span class="token operator">:</span> input_regs 
    <span class="token operator">:</span> clobbered_regs
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中符号&quot;c&quot;(count)指示要把count的值放入ecx寄存器</p><p>类似的还有： a eax b ebx c ecx d edx S esi D edi I 常数值，(0 - 31) q,r 动态分配的寄存器 g eax,ebx,ecx,edx或内存变量 A 把eax和edx合成一个64位的寄存器(use long longs)</p><p>例1：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span> b<span class="token punctuation">;</span>
<span class="token keyword">asm</span> <span class="token punctuation">(</span>&quot;movl <span class="token operator">%</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">%</span><span class="token operator">%</span>eax<span class="token punctuation">;</span> 
	  movl <span class="token operator">%</span><span class="token operator">%</span>eax<span class="token punctuation">,</span> <span class="token operator">%</span><span class="token number">0</span><span class="token punctuation">;</span>&quot;
	 <span class="token operator">:</span><span class="token string">&quot;=r&quot;</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>        <span class="token comment">/* 输出操作数 */</span>
	 <span class="token operator">:</span><span class="token string">&quot;r&quot;</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>         <span class="token comment">/* 输入操作数 */</span>
	 <span class="token operator">:</span><span class="token string">&quot;%eax&quot;</span>         <span class="token comment">/* clobbered寄存器 */</span>
	 <span class="token punctuation">)</span><span class="token punctuation">;</span>   
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，</p><ul><li>b作为输出操作数，在汇编指令中使用%0来引用。a作为输入操作数，在汇编指令中使用%1来引用。</li><li>r用来约束操作数，告诉GCC可以使用任意寄存器来存储被约束的操作数。</li><li>对于输出操作数，双引号内的约束符还需要添加一个修饰符&#39;=&#39;，这个等号用来表示被修饰的是输出操作数，并且是只写的。</li></ul><p>对于寄存器，使用两个百分号&#39;%&#39;作为前缀（不是一个）；而对于普通操作数，则使用一个百分号&#39;%&#39;作为前缀。这样便于GCC区分解析寄存器和普通操作数。</p><p>最后一个参数%eax，用于通知GCC，寄存器eax将会在汇编指令中被使用和修改，让GCC不要使用该寄存器来存储任何值。</p><p>第1条指令，表示将输入操作数a传入寄存器eax。</p><p>第2条指令，表示将寄存器eax的值传入输出操作数b中。</p><h2 id="mov-x" tabindex="-1"><a class="header-anchor" href="#mov-x" aria-hidden="true">#</a> mov(x)</h2><p>movb:复制8位数据(1个字节)</p><p>movw:复制16位数据(2个字节)</p><p>movl:复制32位数据(4个字节)</p><h2 id="add" tabindex="-1"><a class="header-anchor" href="#add" aria-hidden="true">#</a> add</h2><p>ADD (Addition)：将源操作数的值加到目标操作数中，并将结果存储在目标操作数中。 示例：将两个寄存器的值相加并存储到目标寄存器中：</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>ADD eax, ebx   ; 将 ebx 寄存器的值加到 eax 寄存器中，并将结果存储在 eax 中
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="sub" tabindex="-1"><a class="header-anchor" href="#sub" aria-hidden="true">#</a> sub</h2><p>SUB (Subtraction)：从目标操作数中减去源操作数的值，并将结果存储在目标操作数中。 示例：从目标寄存器中减去一个立即数并将结果存储到目标寄存器中：</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>SUB ecx, 10   ; 从 ecx 寄存器中减去 10，并将结果存储在 ecx 中
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="mul" tabindex="-1"><a class="header-anchor" href="#mul" aria-hidden="true">#</a> mul</h2><p>MUL (Multiplication)：将目标操作数乘以源操作数的值，并将结果存储在目标操作数中。 示例：将一个寄存器的值乘以另一个寄存器的值并存储到目标寄存器中：</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>MUL edx   ; 将 edx 寄存器的值乘以 eax 寄存器中的值，并将结果存储在 edx:eax 中
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="div" tabindex="-1"><a class="header-anchor" href="#div" aria-hidden="true">#</a> div</h2><p>DIV (Division)：将目标操作数除以源操作数的值，并将商存储在目标操作数中。 示例：将目标寄存器中的值除以一个立即数并将商存储到目标寄存器中：</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>DIV ebx   ; 将 eax:edx 寄存器中的值除以 ebx 寄存器中的值，并将商存储在 eax 中，余数存储在 edx
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="lea" tabindex="-1"><a class="header-anchor" href="#lea" aria-hidden="true">#</a> lea</h2><p>lea = Load Effective Address, 即加载有效地址。</p><p><code>LEA Rt, [Rs1+a*Rs2+b] =&gt; Rt = Rs1 + a*Rs2 + b</code></p><h2 id="lds" tabindex="-1"><a class="header-anchor" href="#lds" aria-hidden="true">#</a> lds</h2><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>lds dest, src
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>把 <code>src</code> 指向的地址，高位存放在<code>DS</code>中，低位存放在<code>dest</code>中。</p><p>比如当前DS=1000H, BX=0100H。</p><p>当前内存:</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>1000:0100 01
1000:0101 02
1000:0102 03
1000:0103 04
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而有一条指令:<code>LDS BX,[BX]</code><code>[BX]</code>指向<code>1000:0100</code>,执行后BX存低位的内容,也就是<code>BX=0201</code>H, 而DS则存高位的内容,也就是<code>[BX+2]</code>的内容,<code>DS=0403H</code></p><h2 id="lss指令" tabindex="-1"><a class="header-anchor" href="#lss指令" aria-hidden="true">#</a> lss指令</h2><p>lss指令是SS装入指令，格式如下 <code>lss add, %esp</code> 把add指向的内容装入到\`\`\`SS:ESP\`\`中。 这里要注意，add是一个内存地址，lss指令会把add指向的内存地址的前四字节装入ESP寄存器，后两字节装入SS段寄存器，而不是把add这个值装入ESP寄存器。 如：内存0x1000地址的内容为0x0000F000,0x0010，则lss指令会把0x0000F000装入ESP，0x0010装入SS段寄存器。</p><h2 id="lodsb-lodsw" tabindex="-1"><a class="header-anchor" href="#lodsb-lodsw" aria-hidden="true">#</a> lodsb/lodsw</h2><p>lodsb等同于</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>mov al, ds:[si]
inc si
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>lodsw等同于</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>mov ax, ds:[si]
add si, 2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="stosb-stosw" tabindex="-1"><a class="header-anchor" href="#stosb-stosw" aria-hidden="true">#</a> stosb/stosw</h2><p>stosb等同于：</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>mov al, ds:[si]
inc si
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>stosw等同于：</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>mov ax, ds:[si]
add si, 2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="xorl" tabindex="-1"><a class="header-anchor" href="#xorl" aria-hidden="true">#</a> xorl</h2><p>按位异或，值相同为0，值不同为1，如果源操作数和目标操作数相同，等同于清零。</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>xorl %eax %eax
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="and" tabindex="-1"><a class="header-anchor" href="#and" aria-hidden="true">#</a> AND</h2><p>调用格式：</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>AND source destination
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>对两个操作数对应位之间进行按位逻辑与操作，并将操作存放在目标操作数之中。</p><p>例如bootsect.s， 将dx和0x0100进行按位与，并将值放入到dx中。</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>and	$0x0100, %dx
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="std和cld" tabindex="-1"><a class="header-anchor" href="#std和cld" aria-hidden="true">#</a> std和cld</h2><p>CLD： 设置DF=0</p><p>STD： 设置DF=1</p><p>movb: if DF = 0: SI = SI + 1 , DI = DI + 1 ; else if DF = 1 SI = SI - 1 , DI = DI - 1 ;</p><p>movw: if DF = 0: SI = SI + 2 , DI = DI + 2 ; else if DF = 1: SI = SI - 2 , DI = DI - 2 ;</p><h2 id="test" tabindex="-1"><a class="header-anchor" href="#test" aria-hidden="true">#</a> test</h2><p><strong>功能</strong>: 执行BIT与BIT之间的<strong>逻辑与</strong>运算</p><p>TEST可以判断测试位是否为0。</p><h2 id="jcc" tabindex="-1"><a class="header-anchor" href="#jcc" aria-hidden="true">#</a> jcc</h2><p>JE JZ</p><p>JE和JZ的功能是相同的。</p><p>如果标志位ZF=1， 则进行跳转</p><p>如果标志位ZF=0， 则不进行跳转</p><p>JNE JNZ JNE和JNZ的作用是相同的。</p><p>如果标志位ZF=0， 则进行跳转</p><p>如果标志位ZF=1， 则不进行跳转</p>`,78),l=[i];function r(c,o){return e(),s("div",null,l)}const p=a(d,[["render",r],["__file","Linux-0.11-assemble-language.html.vue"]]);export{p as default};
