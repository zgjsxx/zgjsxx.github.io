const e=JSON.parse('{"key":"v-635dc457","path":"/posts/lesson/cs6.824-distributed-system/lesson3.html","title":"GFS","lang":"zh-CN","frontmatter":{"description":"GFS GFS追加写文件 1.client向master发送请求，告知要追加的文件名，master需要找到该文件最后一个chunk的位置 如果Master发现是新文件，会创建新的chunk handle和chunk data，并分配三个chunk server 2.Master 查询primary Chunk，如果没有，需要先指定一个最新的副本为primary Chunk。版本号与 Master 一致的即为最新副本 读文件可以从任何最新的Chunk副本读，但是写文件必须通过Primary Chunk来写入。 Master 指定Primary Chunk即租约过程，租约有个期限（60秒），到期后失去Primary Chunk 身份。租约的作用就是将与客户端交互、更新Chunk的能力授权给Primary Chunk 服务器，客户端不需要再与 Master 交互。租约可以确保没有多个Primary Chunk 出现。 Master 每次指定新的Primary Chunk后，就会加一次版本号并写入磁盘，然后通知 Chunk server谁主谁备，并告知最新的版本号，Chunk server更新版本号并保存到磁盘。写入磁盘是为了故障恢复 Master 为何不直接将 Chunk 最大版本号作为最新版本号？因为有可能拥有最新版本号的 Chunk 故障未恢复。Master 定期询问 Chunk 持有的版本号，如果没找到和 Master 一致的版本号，Master 会等待不响应客户端请求 Master 可能在租约时崩溃，重启后有Chunk上报一个比本地更大的版本号，Master 会知道租约时发生了错误，选这个最大的版本号作为最新版本号","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/lesson/cs6.824-distributed-system/lesson3.html"}],["meta",{"property":"og:site_name","content":"Code Building"}],["meta",{"property":"og:title","content":"GFS"}],["meta",{"property":"og:description","content":"GFS GFS追加写文件 1.client向master发送请求，告知要追加的文件名，master需要找到该文件最后一个chunk的位置 如果Master发现是新文件，会创建新的chunk handle和chunk data，并分配三个chunk server 2.Master 查询primary Chunk，如果没有，需要先指定一个最新的副本为primary Chunk。版本号与 Master 一致的即为最新副本 读文件可以从任何最新的Chunk副本读，但是写文件必须通过Primary Chunk来写入。 Master 指定Primary Chunk即租约过程，租约有个期限（60秒），到期后失去Primary Chunk 身份。租约的作用就是将与客户端交互、更新Chunk的能力授权给Primary Chunk 服务器，客户端不需要再与 Master 交互。租约可以确保没有多个Primary Chunk 出现。 Master 每次指定新的Primary Chunk后，就会加一次版本号并写入磁盘，然后通知 Chunk server谁主谁备，并告知最新的版本号，Chunk server更新版本号并保存到磁盘。写入磁盘是为了故障恢复 Master 为何不直接将 Chunk 最大版本号作为最新版本号？因为有可能拥有最新版本号的 Chunk 故障未恢复。Master 定期询问 Chunk 持有的版本号，如果没找到和 Master 一致的版本号，Master 会等待不响应客户端请求 Master 可能在租约时崩溃，重启后有Chunk上报一个比本地更大的版本号，Master 会知道租约时发生了错误，选这个最大的版本号作为最新版本号"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-11T09:23:20.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-11T09:23:20.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"GFS\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-09-11T09:23:20.000Z\\",\\"author\\":[]}"]]},"headers":[],"git":{"createdTime":1726046357000,"updatedTime":1726046600000,"contributors":[{"name":"zgjsxx","email":"119160524@qq.com","commits":2}]},"readingTime":{"minutes":1.81,"words":544},"filePathRelative":"posts/lesson/cs6.824-distributed-system/lesson3.md","localizedDate":"2024年9月11日","excerpt":"<h1> GFS</h1>\\n<p><strong>GFS追加写文件</strong></p>\\n<p>1.client向master发送请求，告知要追加的文件名，master需要找到该文件最后一个chunk的位置</p>\\n<p>如果Master发现是新文件，会创建新的chunk handle和chunk data，并分配三个chunk server</p>\\n<p>2.Master 查询primary Chunk，如果没有，需要先指定一个最新的副本为primary Chunk。版本号与 Master 一致的即为最新副本</p>\\n<ul>\\n<li>\\n<p>读文件可以从任何最新的Chunk副本读，但是写文件必须通过Primary Chunk来写入。</p>\\n</li>\\n<li>\\n<p>Master 指定Primary Chunk即租约过程，租约有个期限（60秒），到期后失去Primary Chunk 身份。租约的作用就是将与客户端交互、更新Chunk的能力授权给Primary Chunk 服务器，客户端不需要再与 Master 交互。租约可以确保没有多个Primary Chunk 出现。</p>\\n</li>\\n<li>\\n<p>Master 每次指定新的Primary Chunk后，就会加一次版本号并写入磁盘，然后通知 Chunk server谁主谁备，并告知最新的版本号，Chunk server更新版本号并保存到磁盘。写入磁盘是为了故障恢复</p>\\n</li>\\n<li>\\n<p>Master 为何不直接将 Chunk 最大版本号作为最新版本号？因为有可能拥有最新版本号的 Chunk 故障未恢复。Master 定期询问 Chunk 持有的版本号，如果没找到和 Master 一致的版本号，Master 会等待不响应客户端请求</p>\\n</li>\\n<li>\\n<p>Master 可能在租约时崩溃，重启后有Chunk上报一个比本地更大的版本号，Master 会知道租约时发生了错误，选这个最大的版本号作为最新版本号</p>\\n</li>\\n</ul>","autoDesc":true}');export{e as data};
