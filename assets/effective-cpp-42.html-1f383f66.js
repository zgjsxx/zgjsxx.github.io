import{_ as s,V as n,W as a,a0 as e}from"./framework-9a29aaa0.js";const t={},p=e(`<h1 id="effective-c-42-typename的双重含义" tabindex="-1"><a class="header-anchor" href="#effective-c-42-typename的双重含义" aria-hidden="true">#</a> effective c++ 42-typename的双重含义</h1><h2 id="_1-在用于声明template参数的时候-class和typename的含义是相同的" tabindex="-1"><a class="header-anchor" href="#_1-在用于声明template参数的时候-class和typename的含义是相同的" aria-hidden="true">#</a> 1.在用于声明template参数的时候，class和typename的含义是相同的</h2><p>下面两种声明中，<code>class</code>和<code>typename</code>的含义是相同的。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">Widget</span><span class="token punctuation">;</span>                 <span class="token comment">// uses &quot;class&quot;</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">Widget</span><span class="token punctuation">;</span>              <span class="token comment">// uses &quot;typename&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-typename必须作为嵌套从属类型名称的前缀词-但是有两个例外" tabindex="-1"><a class="header-anchor" href="#_2-typename必须作为嵌套从属类型名称的前缀词-但是有两个例外" aria-hidden="true">#</a> 2.typename必须作为嵌套从属类型名称的前缀词， 但是有两个例外</h2><p>在模板函数体中，使用<code>::</code>去获取嵌套从属类型时，需要加上<code>typename</code>， 例如：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">IterT</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">workWithIterator</span><span class="token punctuation">(</span>IterT iter<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>iterator_traits<span class="token operator">&lt;</span>IterT<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value_type <span class="token function">temp</span><span class="token punctuation">(</span><span class="token operator">*</span>iter<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是有两个例外，不要加<code>typename</code>，</p><p><strong>第一个例外</strong>是存在继承时，基类不需要加上<code>typename</code>。</p><p><strong>第二个例外</strong>是存在继承时，构造函数成员值初始化时不需要加上<code>typename</code>。</p><p>例如如下的例子：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Derived</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token class-name">Nested</span></span>
<span class="token punctuation">{</span> 					<span class="token comment">// base class list: typename not</span>
<span class="token keyword">public</span><span class="token operator">:</span>                                 <span class="token comment">// allowed</span>

  <span class="token keyword">explicit</span> <span class="token function">Derived</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> 
  <span class="token operator">:</span> <span class="token class-name">Base</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">Nested</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>                  <span class="token comment">// base class identifier in mem</span>
  <span class="token punctuation">{</span>                                     <span class="token comment">// init. list: typename not allowed</span>
    <span class="token keyword">typename</span> <span class="token class-name">Base</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>Nested temp<span class="token punctuation">;</span>      <span class="token comment">// use of nested dependent type</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                 <span class="token comment">// name not in a base class list or</span>
  <span class="token punctuation">}</span>                                     <span class="token comment">// as a base class identifier in a</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                   <span class="token comment">// mem. init. list: typename required</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际上总结起来就是在<code>typename</code>只允许在函数体内部出现。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><ul><li>在用于声明template参数的时候，class和typename的含义是相同的</li><li>typename必须作为嵌套从属类型名称的前缀词, 但是这一原则有两个例外，一个在在继承时，基类不需要加上<code>typename</code>， 二是在构造函数成员值初始化时不需要加上<code>typename</code></li></ul>`,15),o=[p];function c(l,i){return n(),a("div",null,o)}const r=s(t,[["render",c],["__file","effective-cpp-42.html.vue"]]);export{r as default};
