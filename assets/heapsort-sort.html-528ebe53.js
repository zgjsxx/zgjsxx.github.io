import{_ as t,V as p,W as e,a0 as a,X as n,Y as s}from"./framework-9a29aaa0.js";const o={},i=a('<h1 id="堆排序算法及其稳定性分析" tabindex="-1"><a class="header-anchor" href="#堆排序算法及其稳定性分析" aria-hidden="true">#</a> 堆排序算法及其稳定性分析</h1><h2 id="什么是堆排序" tabindex="-1"><a class="header-anchor" href="#什么是堆排序" aria-hidden="true">#</a> 什么是堆排序？</h2><p>堆排序是利用数据结构堆而设计的一种排序算法。</p><p>堆分为两种，<strong>大顶堆</strong>和<strong>小顶堆</strong>。</p><p>所谓大顶堆就是每个节点的值都大于或者等于其左右孩子节点的值。</p><p>小顶堆则是相反的，每个节点的值都小于或者等于其左右孩子节点的值。</p><p>下面是一个大顶堆的示例，其拥有下面的性质:</p><p><code>arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</code></p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort1.png" alt="heapsort1" tabindex="0" loading="lazy"><figcaption>heapsort1</figcaption></figure><p>下面是一个小顶堆的实例，其拥有下面的性质：</p><p><code>arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</code></p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort2.png" alt="heapsort2" tabindex="0" loading="lazy"><figcaption>heapsort2</figcaption></figure><p>大顶堆和小顶堆数据结构是堆排序的基础，下面就看堆排序是如何利用堆来进行排序的。</p><p>堆排序的步骤如下：</p><ul><li>1.将原始数组转换成一个大顶堆(如果要求升序)或者小顶堆(如果要求降序)。</li><li>2.将大顶堆或者小顶堆的首元素与最后一个元素交换</li><li>3.剔除尾部元素，将剩下的元素重新构成一个大顶堆或者小顶堆，重复2。</li></ul><p>以一个例子来看一下上述过程是怎样的。</p><p>原始数组<code>arr = [3,1,4,5,2]</code>， 对其进行升序。</p><p>步骤1：首先将原数组构建成一个大顶堆。首先从叶子节点开始，将1和5进行对调。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort-demo1.png" alt="heapsort-demo" tabindex="0" loading="lazy"><figcaption>heapsort-demo</figcaption></figure><p>步骤2：继续进行调整，将5和3进行对调，此时已经成为了一个大顶堆。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort-demo2.png" alt="heapsort-demo" tabindex="0" loading="lazy"><figcaption>heapsort-demo</figcaption></figure><p>步骤3：将堆顶元素5和尾部元素2进行对调。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort-demo3.png" alt="heapsort-demo" tabindex="0" loading="lazy"><figcaption>heapsort-demo</figcaption></figure><p>步骤4：重新构建一个大顶堆。将2和4进行对调。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort-demo4.png" alt="heapsort-demo" tabindex="0" loading="lazy"><figcaption>heapsort-demo</figcaption></figure><p>步骤5：将堆顶元素4和尾部元素1进行对调。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort-demo5.png" alt="heapsort-demo" tabindex="0" loading="lazy"><figcaption>heapsort-demo</figcaption></figure><p>步骤6：重新构建一个大顶堆。将元素1和3进行对调。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort-demo6.png" alt="heapsort-demo" tabindex="0" loading="lazy"><figcaption>heapsort-demo</figcaption></figure><p>步骤7：将堆顶元素3和尾部元素2进行对调。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort-demo7.png" alt="heapsort-demo" tabindex="0" loading="lazy"><figcaption>heapsort-demo</figcaption></figure><p>步骤8：将堆顶元素2和尾部元素1进行对调。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort-demo8.png" alt="heapsort-demo" tabindex="0" loading="lazy"><figcaption>heapsort-demo</figcaption></figure><p><strong>复杂度</strong>：</p>',34),c=n("p",null,[s("时间复杂度："),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"n"),n("mi",null,"l"),n("mi",null,"o"),n("mi",null,"g"),n("mi",null,"n"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(nlogn)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),n("span",{class:"mord mathnormal"},"o"),n("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"g"),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mclose"},")")])])])],-1),l=n("p",null,[s("空间复杂度为: "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mn",null,"1"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(1)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord"},"1"),n("span",{class:"mclose"},")")])])]),s("。没有使用额外的存储空间。")],-1),r=a(`<h2 id="堆排序的代码实现" tabindex="-1"><a class="header-anchor" href="#堆排序的代码实现" aria-hidden="true">#</a> 堆排序的代码实现</h2><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span>    </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;ctype.h&gt;</span>      </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span>   </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;math.h&gt;</span>  </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h&gt;</span></span>

<span class="token keyword">typedef</span> <span class="token keyword">int</span> Status<span class="token punctuation">;</span> 


<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXSIZE</span> <span class="token expression"><span class="token number">10000</span>  </span><span class="token comment">/* 用于要排序数组个数最大值，可根据需要修改 */</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> r<span class="token punctuation">[</span>MAXSIZE<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">/* 用于存储要排序数组，r[0]用作哨兵或临时变量 */</span>
	<span class="token keyword">int</span> length<span class="token punctuation">;</span>			<span class="token comment">/* 用于记录顺序表的长度 */</span>
<span class="token punctuation">}</span>SqList<span class="token punctuation">;</span>

<span class="token comment">/* 交换L中数组r的下标为i和j的值 */</span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> j<span class="token punctuation">)</span> 
<span class="token punctuation">{</span> 
	<span class="token keyword">int</span> temp<span class="token operator">=</span>L<span class="token operator">-&gt;</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> 
	L<span class="token operator">-&gt;</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>L<span class="token operator">-&gt;</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> 
	L<span class="token operator">-&gt;</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>SqList L<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> i<span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>L<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d,&quot;</span><span class="token punctuation">,</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">/* 已知L-&gt;r[s..m]中记录的关键字除L-&gt;r[s]之外均满足堆的定义， */</span>
<span class="token comment">/* 本函数调整L-&gt;r[s]的关键字,使L-&gt;r[s..m]成为一个大顶堆 */</span>
<span class="token keyword">void</span> <span class="token function">HeapAdjust</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> s<span class="token punctuation">,</span><span class="token keyword">int</span> m<span class="token punctuation">)</span>
<span class="token punctuation">{</span> 
	<span class="token keyword">int</span> temp<span class="token punctuation">,</span>j<span class="token punctuation">;</span>
	temp<span class="token operator">=</span>L<span class="token operator">-&gt;</span>r<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span>s<span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span>j<span class="token operator">*=</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">/* 沿关键字较大的孩子结点向下筛选 */</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>m <span class="token operator">&amp;&amp;</span> L<span class="token operator">-&gt;</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>L<span class="token operator">-&gt;</span>r<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token operator">++</span>j<span class="token punctuation">;</span> <span class="token comment">/* j为关键字中较大的记录的下标 */</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>temp<span class="token operator">&gt;=</span>L<span class="token operator">-&gt;</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">/* rc应插入在位置s上 */</span>
		L<span class="token operator">-&gt;</span>r<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token operator">=</span>L<span class="token operator">-&gt;</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
		s<span class="token operator">=</span>j<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	L<span class="token operator">-&gt;</span>r<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">;</span> <span class="token comment">/* 插入 */</span>
<span class="token punctuation">}</span>

<span class="token comment">/*  对顺序表L进行堆排序 */</span>
<span class="token keyword">void</span> <span class="token function">HeapSort</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>L<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> i<span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>L<span class="token operator">-&gt;</span>length<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token comment">/*  把L中的r构建成一个大根堆 */</span>
		 <span class="token function">HeapAdjust</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span>i<span class="token punctuation">,</span>L<span class="token operator">-&gt;</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>L<span class="token operator">-&gt;</span>length<span class="token punctuation">;</span>i<span class="token operator">&gt;</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span> 
		 <span class="token function">swap</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 将堆顶记录和当前未经排序子序列的最后一个记录交换 */</span>
		 <span class="token function">HeapAdjust</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/*  将L-&gt;r[1..i-1]重新调整为大根堆 */</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/* **************************************** */</span>


<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">9</span></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   <span class="token keyword">int</span> i<span class="token punctuation">;</span>
   
   <span class="token comment">/* int d[N]={9,1,5,8,3,7,4,6,2}; */</span>
   <span class="token keyword">int</span> d<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">90</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">70</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token number">80</span><span class="token punctuation">,</span><span class="token number">60</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
   <span class="token comment">/* int d[N]={9,8,7,6,5,4,3,2,1}; */</span>

   SqList l0<span class="token punctuation">,</span>l1<span class="token punctuation">,</span>l2<span class="token punctuation">,</span>l3<span class="token punctuation">,</span>l4<span class="token punctuation">,</span>l5<span class="token punctuation">,</span>l6<span class="token punctuation">,</span>l7<span class="token punctuation">,</span>l8<span class="token punctuation">,</span>l9<span class="token punctuation">,</span>l10<span class="token punctuation">;</span>
   
   <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
     l0<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
   l0<span class="token punctuation">.</span>length<span class="token operator">=</span>N<span class="token punctuation">;</span>
   l1<span class="token operator">=</span>l2<span class="token operator">=</span>l3<span class="token operator">=</span>l4<span class="token operator">=</span>l5<span class="token operator">=</span>l6<span class="token operator">=</span>l7<span class="token operator">=</span>l8<span class="token operator">=</span>l9<span class="token operator">=</span>l10<span class="token operator">=</span>l0<span class="token punctuation">;</span>
   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;排序前:\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token function">print</span><span class="token punctuation">(</span>l0<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;堆排序:\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token function">HeapSort</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>l6<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token function">print</span><span class="token punctuation">(</span>l6<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="稳定性分析" tabindex="-1"><a class="header-anchor" href="#稳定性分析" aria-hidden="true">#</a> 稳定性分析</h2><p><strong>稳定性</strong>就是指对于两个关键字相等的记录，它们在序列中的相对位置，在排序之前和排序之后没有发生改变。通俗地讲就是有两个关键字相等的数据A、B，排序前，A的位置是 i ，B的位置是 j，此时 i &lt; j，则如果在排序后A的位置还是在B之前，那么称它是稳定的。</p><p>那么堆排序是一个稳定排序吗？</p><h3 id="堆排序的稳定性分析" tabindex="-1"><a class="header-anchor" href="#堆排序的稳定性分析" aria-hidden="true">#</a> 堆排序的稳定性分析</h3><p>直接上答案堆排序并不是一个稳定排序。</p><p>堆排序的会将原始的数组转化成一个大顶堆或一个小顶堆，在输出堆顶后，此时需要维护堆，操作如下：</p><p>（1）堆顶与堆尾交换并删除堆尾，被删除的堆尾的元素就是输出过的元素</p><p>（2）把当前堆顶向下调整，直到满足构成堆的条件，重复（1）步骤</p><p>在堆顶与堆尾交换的时候两个相等的记录在序列中的相对位置就可能发生改变，这就影响其稳定性了。</p><p>下面看一个实际的例子， [5A,6,5B,7,8] ，A和B用于区分相同元素。</p><p>数组的原始的状态如下所示：</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort-stable1.png" alt="heapsort-stable1" tabindex="0" loading="lazy"><figcaption>heapsort-stable1</figcaption></figure><p>首先调整下方的子树[6，7，8]，将8和6的位置调换。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort-stable2.png" alt="heapsort-stable2" tabindex="0" loading="lazy"><figcaption>heapsort-stable2</figcaption></figure><p>接着调整下方的子树[5A，8，5B]，将8和5A的位置调换。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort-stable3.png" alt="heapsort-stable3" tabindex="0" loading="lazy"><figcaption>heapsort-stable3</figcaption></figure><p>由于5A和8位置的调换，需要重新调整下方的子树[5A，7，6]，将5A和7的位置调换。这个时候5A和5B的顺序就出现了一次乱序。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort-stable4.png" alt="heapsort-stable4" tabindex="0" loading="lazy"><figcaption>heapsort-stable4</figcaption></figure><p>至此，第一轮排序完毕，将8和数组尾部元素6交换。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort-stable5.png" alt="heapsort-stable5" tabindex="0" loading="lazy"><figcaption>heapsort-stable5</figcaption></figure><p>接着调整顶部的子树[6，7，5B]，将7和6的位置调换。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort-stable6.png" alt="heapsort-stable6" tabindex="0" loading="lazy"><figcaption>heapsort-stable6</figcaption></figure><p>这个时候第二轮排序已经结束，此时可以将7和数组尾部元素5A进行调整。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort-stable7.png" alt="heapsort-stable7" tabindex="0" loading="lazy"><figcaption>heapsort-stable7</figcaption></figure><p>接着调整顶部的子树[5A，6，5B]，将6和5A的位置调换。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort-stable8.png" alt="heapsort-stable8" tabindex="0" loading="lazy"><figcaption>heapsort-stable8</figcaption></figure><p>这个时候第三轮排序已经结束，此时可以将6和数组尾部元素5B进行调整。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort-stable9.png" alt="heapsort-stable9" tabindex="0" loading="lazy"><figcaption>heapsort-stable9</figcaption></figure><p>剩下的元素已经满足了排序的要求，于是直接输出结果。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort-stable10.png" alt="heapsort-stable10" tabindex="0" loading="lazy"><figcaption>heapsort-stable10</figcaption></figure><p>至此[5A,6,5B,7,8] 排序为 [5B,5A,6,7,8]。可以看到5A和5B的关系发生了变化。</p><p>通过这个例子也证明了堆排序不是一个稳定排序。</p>`,34),u=[i,c,l,r];function d(k,m){return p(),e("div",null,u)}const h=t(o,[["render",d],["__file","heapsort-sort.html.vue"]]);export{h as default};
