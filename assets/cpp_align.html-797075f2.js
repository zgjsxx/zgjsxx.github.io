const e=JSON.parse('{"key":"v-62851eba","path":"/posts/Program_language/cpp/cpp_align.html","title":"c++中的对齐问题","lang":"zh-CN","frontmatter":{"category":["C++"],"description":"c++中的对齐问题 需要对齐的原因 对齐的规则 有效对齐值：是 #pragma pack(n)和结构体中最长数据类型长度中较小的那个。有效对齐值也叫对齐单位。 注意： #pragma pack(n)中的n可以取(1 , 2 , 4 , 8 , 16)中的任意一值。 2）规则： 结构体变量的首地址是有效对齐值（对齐单位）的整数倍。 结构体第一个成员的偏移量（offset）为0，以后每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节。 结构体的总大小为有效对齐值的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。 结构体内类型相同的连续元素将在连续的空间内，和数组一样。","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/Program_language/cpp/cpp_align.html"}],["meta",{"property":"og:site_name","content":"Code Building"}],["meta",{"property":"og:title","content":"c++中的对齐问题"}],["meta",{"property":"og:description","content":"c++中的对齐问题 需要对齐的原因 对齐的规则 有效对齐值：是 #pragma pack(n)和结构体中最长数据类型长度中较小的那个。有效对齐值也叫对齐单位。 注意： #pragma pack(n)中的n可以取(1 , 2 , 4 , 8 , 16)中的任意一值。 2）规则： 结构体变量的首地址是有效对齐值（对齐单位）的整数倍。 结构体第一个成员的偏移量（offset）为0，以后每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节。 结构体的总大小为有效对齐值的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。 结构体内类型相同的连续元素将在连续的空间内，和数组一样。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-09-05T08:28:35.000Z"}],["meta",{"property":"article:modified_time","content":"2023-09-05T08:28:35.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"c++中的对齐问题\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-09-05T08:28:35.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"需要对齐的原因","slug":"需要对齐的原因","link":"#需要对齐的原因","children":[]},{"level":2,"title":"对齐的规则","slug":"对齐的规则","link":"#对齐的规则","children":[]}],"git":{"createdTime":1693816898000,"updatedTime":1693902515000,"contributors":[{"name":"zgjsxx","email":"119160524@qq.com","commits":2}]},"readingTime":{"minutes":5.26,"words":1577},"filePathRelative":"posts/Program_language/cpp/cpp_align.md","localizedDate":"2023年9月4日","excerpt":"<h1> c++中的对齐问题</h1>\\n<h2> 需要对齐的原因</h2>\\n<h2> 对齐的规则</h2>\\n<p><strong>有效对齐值</strong>：是 <code>#pragma pack(n)</code>和结构体中最长数据类型长度中较小的那个。有效对齐值也叫<strong>对齐单位</strong>。</p>\\n<p>注意：\\n<code>#pragma pack(n)</code>中的n可以取(1 , 2 , 4 , 8 , 16)中的任意一值。</p>\\n<p>2）规则：</p>\\n<ul>\\n<li>\\n<p>结构体变量的首地址是有效对齐值（对齐单位）的整数倍。</p>\\n</li>\\n<li>\\n<p>结构体第一个成员的偏移量（offset）为0，以后每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节。</p>\\n</li>\\n<li>\\n<p>结构体的总大小为有效对齐值的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。</p>\\n</li>\\n<li>\\n<p>结构体内类型相同的连续元素将在连续的空间内，和数组一样。</p>\\n</li>\\n</ul>","autoDesc":true}');export{e as data};
