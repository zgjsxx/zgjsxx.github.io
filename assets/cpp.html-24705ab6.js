import{_ as a,V as t,W as p,X as n,Y as e,$ as o,a0 as c,F as l}from"./framework-9a29aaa0.js";const i={},u=c(`<ul><li><a href="#c%E9%9D%A2%E7%BB%8F">c++面经</a><ul><li><a href="#c%E5%9F%BA%E7%A1%80">c++基础</a><ul><li><a href="#const%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8">const关键字的作用</a></li><li><a href="#%E8%AF%B7%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAstrcpy%E6%96%B9%E6%B3%95">请实现一个strcpy方法</a></li><li><a href="#%E5%86%85%E5%AD%98%E5%A0%86%E6%A0%88%E5%AF%B9%E6%AF%94%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%E5%AE%83%E4%BB%AC%E7%9A%84%E5%88%86%E9%85%8D%E6%95%88%E7%8E%87%E5%A6%82%E4%BD%95">内存堆栈对比，分别有什么特点？它们的分配效率如何？</a></li><li><a href="#i%E5%92%8Ci%E5%93%AA%E4%B8%AA%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98">++i和i++哪个效率更高？</a></li><li><a href="#%E5%A6%82%E4%BD%95%E7%A6%81%E7%94%A8%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">如何禁用拷贝构造函数</a></li><li><a href="#stdfuture%E5%92%8Cstdpromise%E7%9A%84%E4%BD%9C%E7%94%A8">std::future和std::promise的作用</a></li></ul></li><li><a href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1">类和对象</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFrtti">什么是RTTI</a></li></ul></li><li><a href="#stl">STL</a><ul><li><a href="#map%E5%92%8Cunordered_map%E7%9A%84%E5%8C%BA%E5%88%AB-%E5%90%84%E8%87%AA%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88">map和unordered_map的区别? 各自使用场景是什么？</a></li></ul></li><li><a href="#%E5%8F%82%E8%80%83">参考</a></li></ul></li></ul><h1 id="c-面经" tabindex="-1"><a class="header-anchor" href="#c-面经" aria-hidden="true">#</a> c++面经</h1><h2 id="c-基础" tabindex="-1"><a class="header-anchor" href="#c-基础" aria-hidden="true">#</a> c++基础</h2><h3 id="const关键字的作用" tabindex="-1"><a class="header-anchor" href="#const关键字的作用" aria-hidden="true">#</a> const关键字的作用</h3><p>const 关键字在C++中用于定义常量。它是一个非常重要的关键字，主要用于声明不可修改的变量、指针、引用和成员函数。使用 const 可以帮助防止意外修改数据，提高代码的安全性和可维护性。</p><p><strong>const 的主要用法和作用</strong></p><p><strong>1.常量变量:</strong></p><p>使用 const 声明的变量在初始化后不可被修改。这对于定义不可改变的值（如数学常量）特别有用。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">int</span> MAX_SIZE <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>、
<span class="token comment">// MAX_SIZE 不能被修改</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>2.常量指针</strong>:</p><p><strong>指向常量的指针</strong>: const 用于指针声明中，表示指针指向的数据不可修改。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> ptr<span class="token punctuation">;</span>
<span class="token comment">// *ptr 不能被修改，但 ptr 可以指向不同的地址</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>常量的指针</strong>: const 也可以放在指针前面，表示指针本身是常量，不可修改。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span><span class="token operator">*</span> <span class="token keyword">const</span> ptr<span class="token punctuation">;</span>
<span class="token comment">// ptr 不能被修改，但 *ptr 可以被修改</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>常量指针和常量数据</strong>: 可以将 const 关键字应用于指针和指向的数据，表示指针和数据都不可修改。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> <span class="token keyword">const</span> ptr<span class="token punctuation">;</span>
<span class="token comment">// ptr 和 *ptr 都不能被修改</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>3.常量参数</strong>:</p><p>使用 const 可以保证函数参数在函数内部不会被修改，提高函数的安全性和可读性。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">processData</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// data 不能被修改</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>4.常量成员函数:</strong></p><p>在类中，常量成员函数是不会修改类成员的函数，声明为 const 的成员函数可以保证不会改变对象的状态。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
        <span class="token comment">// 不能修改类的成员变量</span>
    <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>5.常量返回值:</strong></p><p>函数返回 const 值，表示返回的值不能被修改。这通常用于防止修改返回对象的成员。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>使用 const 的好处</strong></p><ul><li>提高安全性: const 关键字可以防止数据被意外或错误地修改，从而提高代码的稳定性。</li><li>增强可读性: 明确表明某些数据或对象不应该被修改，使代码更易于理解和维护。</li><li>优化编译: 编译器可以利用 const 信息进行优化，因为它知道某些数据在代码运行期间不会变化。</li></ul><p><strong>总结</strong></p><p>const 是C++中的一个重要关键字，广泛用于定义常量、常量指针、常量引用、常量成员函数等。它不仅有助于防止数据的意外修改，还提高了代码的安全性和可读性。在设计类和函数接口时合理使用 const 可以帮助创建更可靠和维护友好的代码。</p><h3 id="请实现一个strcpy方法" tabindex="-1"><a class="header-anchor" href="#请实现一个strcpy方法" aria-hidden="true">#</a> 请实现一个strcpy方法</h3><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token comment">// 实现 strcpy 函数</span>
<span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">my_strcpy</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> destination<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> source<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">char</span><span class="token operator">*</span> ptr <span class="token operator">=</span> destination<span class="token punctuation">;</span>

    <span class="token comment">// 复制源字符串中的每一个字符到目标字符串</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>source <span class="token operator">!=</span> <span class="token char">&#39;\\0&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">*</span>ptr<span class="token operator">++</span> <span class="token operator">=</span> <span class="token operator">*</span>source<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 确保目标字符串以 &#39;\\0&#39; 结尾</span>
    <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token char">&#39;\\0&#39;</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> destination<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">char</span> source<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;Hello, World!&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> destination<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 目标字符串的大小应足够容纳源字符串</span>

    <span class="token comment">// 使用自定义的 strcpy 函数</span>
    <span class="token function">my_strcpy</span><span class="token punctuation">(</span>destination<span class="token punctuation">,</span> source<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 输出复制后的目标字符串</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Copied string: %s\\n&quot;</span><span class="token punctuation">,</span> destination<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里函数需要返回<code>char*</code>，主要是因为：</p><ul><li>链式调用（Chaining）：</li></ul><p>由于strcpy返回destination，可以在一条语句中进行多个操作。例如：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">char</span> destination<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s\\n&quot;</span><span class="token punctuation">,</span> <span class="token function">strcpy</span><span class="token punctuation">(</span>destination<span class="token punctuation">,</span> <span class="token string">&quot;Hello, World!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>一致的函数接口设计：</li></ul><p>在C标准库中，许多字符串处理函数（例如strcat、strncpy等）都会返回目标字符串指针。这种设计提供了一种一致的接口，使得函数的行为和使用方式更具一致性和可预测性。</p><ul><li>增强代码的灵活性：</li></ul><p>返回目标字符串指针可以增强代码的灵活性，使调用者可以在需要时使用返回值，或忽略它。例如：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">char</span> destination<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span>result <span class="token operator">=</span> <span class="token function">strcpy</span><span class="token punctuation">(</span>destination<span class="token punctuation">,</span> <span class="token string">&quot;Hello, World!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Copied string: %s\\n&quot;</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="内存堆栈对比-分别有什么特点-它们的分配效率如何" tabindex="-1"><a class="header-anchor" href="#内存堆栈对比-分别有什么特点-它们的分配效率如何" aria-hidden="true">#</a> 内存堆栈对比，分别有什么特点？它们的分配效率如何？</h3><p><strong>栈（Stack）</strong></p><p>特点：</p><ul><li>内存分配方式：栈是一个连续的内存区域，内存分配和释放遵循后进先出（LIFO，Last In First Out）原则。</li><li>管理方式：由编译器自动管理，无需手动控制。函数调用时，栈帧会自动分配，函数返回时，栈帧会自动释放。</li><li>生命周期：变量的生命周期与其所在的作用域一致，当作用域结束时，变量的内存会自动释放。</li><li>内存大小：栈的大小通常较小，并且在程序启动时确定。大多数系统的栈大小限制在几MB至几十MB之间。</li></ul><p>分配效率：</p><ul><li>高效率：由于栈是由编译器自动管理的，内存分配和释放速度非常快，通常只需增加或减少栈指针即可完成。</li><li>低开销：栈上的内存分配不需要复杂的内存管理算法，开销极低。</li></ul><p><strong>堆（Heap）</strong></p><p>特点：</p><ul><li>内存分配方式：堆是一个不连续的内存区域，通过动态内存分配函数（如malloc、calloc、realloc、free）进行分配和释放。</li><li>管理方式：需要程序员手动管理内存分配和释放，容易发生内存泄漏（忘记释放内存）或内存碎片（频繁分配和释放导致）。</li><li>生命周期：变量的生命周期由程序员控制，分配的内存在手动释放前一直有效。</li><li>内存大小：堆的大小通常较大，可以根据系统的物理内存和操作系统的限制进行扩展。</li></ul><p>分配效率：</p><ul><li>较低效率：堆内存的分配和释放涉及复杂的算法和数据结构（如自由链表、二叉树、位图等），因此速度较慢。</li><li>较高开销：由于需要维护内存管理的数据结构，分配和释放内存的操作开销较高。</li></ul><p>总结</p><ul><li>栈： <ul><li>优点：分配和释放速度快、开销低、自动管理内存、不容易发生内存泄漏。</li><li>缺点：内存空间有限、灵活性差，不能用于需要大量内存或动态调整大小的情况。</li></ul></li><li>堆： <ul><li>优点：内存空间大、灵活性高，可以分配任意大小的内存块，适合需要动态内存分配的场景。</li><li>缺点：分配和释放速度慢、开销高、需要手动管理内存、容易发生内存泄漏和碎片化。</li></ul></li></ul><h3 id="i和i-哪个效率更高" tabindex="-1"><a class="header-anchor" href="#i和i-哪个效率更高" aria-hidden="true">#</a> ++i和i++哪个效率更高？</h3><p>对于<strong>内建数据类型</strong>，效率没有区别。</p><p>对于<strong>自定义的数据类型</strong>， 前缀式(++i)可以返回对象的引用，而后缀式(i++)必须返回对象的值，存在复制开销。因此++i效率更高。</p><h3 id="如何禁用拷贝构造函数" tabindex="-1"><a class="header-anchor" href="#如何禁用拷贝构造函数" aria-hidden="true">#</a> 如何禁用拷贝构造函数</h3><ul><li><p>如果你的编译器支持 C++11，直接使用 delete</p></li><li><p>可以把拷贝构造函数和赋值操作符声明成private同时不提供实现。</p></li><li><p>可以通过一个基类来封装第二步，因为默认生成的拷贝构造函数会自动调用基类的拷贝构造函数，如果基类的拷贝构造函数是private，那么它无法访问，也就无法正常生成拷贝构造函数</p></li></ul><h3 id="std-future和std-promise的作用" tabindex="-1"><a class="header-anchor" href="#std-future和std-promise的作用" aria-hidden="true">#</a> std::future和std::promise的作用</h3><p><strong>1.std::promise 和 std::future 的设计原理</strong></p><p><strong>std::promise</strong></p><ul><li>std::promise 是一个模板类，表示一个值的“承诺”（promise），它允许我们在未来某个时刻设置一个值或传递一个异常。</li><li>promise 对象内部维护了一个共享状态，这个状态可以包含一个值或异常。</li><li>std::promise 的主要操作是 set_value（设置值）和 set_exception（设置异常）。设置完成后，这个共享状态会被标记为“就绪”。</li></ul><p><strong>std::future</strong></p><ul><li>std::future 是与 std::promise 配对的对象，用于检索 promise 设置的值或异常。</li><li>future 对象也持有相同的共享状态。通过调用 get() 方法，future 可以访问该状态中的值或捕获的异常。</li><li>如果 future 的 get() 在共享状态未就绪时调用，它会阻塞调用线程，直到状态就绪。</li></ul><p><strong>2. promise 和 future 的基本原理</strong></p><p>1.共享状态:</p><ul><li>promise 和 future 之间共享同一个状态。promise 是生产者，可以设置共享状态的值或异常；future 是消费者，可以等待并获取这个状态的值或异常。</li></ul><p>2.一次性:</p><ul><li>promise 的 set_value 或 set_exception 只能调用一次；相应地，future 的 get() 也只能调用一次。调用 get() 后，future 不再持有共享状态。</li><li>如果多次调用 get() 会抛出 std::future_error 异常。</li></ul><p>3.线程安全:</p><ul><li>promise 和 future 的实现保证了它们在不同线程之间操作时的线程安全性。这使得它们非常适合多线程环境下的同步操作。</li></ul><p><strong>3. 典型使用场景</strong></p><p>单一任务的异步结果获取</p><ul><li>场景: 你有一个耗时操作需要在后台线程中完成，但你希望在主线程中等待其结果。</li><li>解决方案: 创建一个 std::promise，启动线程执行耗时任务，并在任务完成时通过 promise.set_value() 设置结果。主线程通过 std::future 的 get() 方法获取结果。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> p<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> f <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span>p<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 执行耗时操作</span>
    <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">some_long_running_task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    p<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> result <span class="token operator">=</span> f<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 阻塞直到 result 就绪</span>
t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>异常传递</p><ul><li>场景: 如果后台任务在执行过程中发生异常，你希望在主线程中处理这个异常。</li><li>解决方案: 在后台线程中捕获异常并通过 promise.set_exception() 传递给主线程。主线程在调用 future.get() 时会捕获到这个异常。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> p<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> f <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span>p<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">some_potentially_throwing_task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        p<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        p<span class="token punctuation">.</span><span class="token function">set_exception</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">current_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> result <span class="token operator">=</span> f<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>exception<span class="token operator">&amp;</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Exception: &quot;</span> <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>4.std::async 和 std::shared_future</strong> std::async</p><ul><li>作用: std::async 是一个高层的工具，用于启动异步任务，并返回一个 std::future。它可以在后台线程或当前线程中执行任务，取决于传递的标志（std::launch::async 或 std::launch::deferred）。</li><li>内部实现: std::async 内部会创建一个 promise，并启动任务。在任务完成时，将结果通过 promise 设置，从而使得返回的 future 可以获取这个结果。</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>std::future&lt;int&gt; f = std::async(std::launch::async, [] {
    return some_long_running_task();
});

int result = f.get();  // 阻塞直到结果就绪
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>std::shared_future</p><ul><li>作用: std::future 是一次性的，不能被多次调用 get()。为了实现结果的多次访问，C++ 提供了 std::shared_future，它允许多个线程共享同一个 future 的结果。</li><li>用法: 可以通过 future.share() 方法将 std::future 转换为 std::shared_future。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> p<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>shared_future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> sf <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">share</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span>sf<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">int</span> result <span class="token operator">=</span> sf<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span>sf<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">int</span> result <span class="token operator">=</span> sf<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

p<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>5. promise 和 future 的高级用法</strong></p><p>链式任务执行</p><ul><li>场景: 有时一个任务的输出需要作为另一个任务的输入，这种情况下可以通过 future 的链式调用来实现任务的依赖管理。</li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> p<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> f <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">auto</span> chained_future <span class="token operator">=</span> f<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> result<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> val <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> val <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

p<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> final_result <span class="token operator">=</span> chained_future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// final_result = 42</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>并行任务处理 场景: 你有多个独立的任务，希望它们同时执行，并在所有任务完成后获取结果。 解决方案: 可以启动多个线程，每个线程处理一个任务并使用 promise 来设置结果。使用多个 future 来等待所有任务的完成。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> futures<span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    futures<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>launch<span class="token double-colon punctuation">::</span>async<span class="token punctuation">,</span> <span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> i <span class="token operator">*</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> f <span class="token operator">:</span> futures<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Result: &quot;</span> <span class="token operator">&lt;&lt;</span> f<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>小结</p><ul><li>std::promise: 用于在多线程环境中设置一个值或异常，并将其传递给 future。</li><li>std::future: 用于等待和获取 promise 设置的值或异常。get() 方法在值就绪之前阻塞调用线程。</li><li>std::async: 提供了一个简单的接口来启动异步任务，并返回一个 future。</li><li>std::shared_future: 允许多个线程共享同一个 future 的结果。</li></ul><p>通过合理地使用 promise 和 future，可以有效地管理多线程任务的结果传递和异常处理，从而实现复杂的异步编程模式。</p><h2 id="类和对象" tabindex="-1"><a class="header-anchor" href="#类和对象" aria-hidden="true">#</a> 类和对象</h2><h3 id="什么是rtti" tabindex="-1"><a class="header-anchor" href="#什么是rtti" aria-hidden="true">#</a> 什么是RTTI</h3><p>RTTI（Run-Time Type Information，运行时类型信息）是一种在程序运行时提供对象类型信息的机制。它允许在运行时检查对象的类型，通常用于以下几个方面：</p><ul><li>类型识别：确定一个对象是否属于特定的类，或者确定对象的实际类型。</li><li>动态转换：安全地将基类指针或引用转换为派生类指针或引用。</li><li>调试和日志记录：在调试和日志记录过程中获取对象的类型信息。</li></ul><p>在C++中，RTTI主要通过以下两个操作符实现：</p><ul><li><p>typeid：用于获取对象的类型信息。例如，typeid(object)会返回一个表示object类型的std::type_info对象。</p></li><li><p>dynamic_cast：用于将基类指针或引用安全地转换为派生类指针或引用。只有在转换是合法的情况下，dynamic_cast才会成功，否则会返回nullptr（对于指针）或抛出std::bad_cast异常（对于引用）。</p></li><li></li></ul><p>使用RTTI需要在编译时启用支持RTTI的选项，因为某些编译器可能默认禁用RTTI以优化性能和减小代码大小。RTTI机制在C++的多态性（polymorphism）中非常有用，特别是在处理继承层次结构复杂的情况下。</p><p>以下是一个简单的示例，展示了RTTI的使用：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;typeinfo&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Base<span class="token operator">*</span> b <span class="token operator">=</span> <span class="token keyword">new</span> Derived<span class="token punctuation">;</span>
    
    <span class="token comment">// 使用typeid操作符</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Type of b: &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span><span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

    <span class="token comment">// 使用dynamic_cast进行安全的向下转换</span>
    Derived<span class="token operator">*</span> d <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Derived<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;b is of type Derived.&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;b is not of type Derived.&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">delete</span> b<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，<code>typeid</code>用于获取对象的类型信息，而<code>dynamic_cast</code>用于安全地将基类指针转换为派生类指针。</p><h2 id="stl" tabindex="-1"><a class="header-anchor" href="#stl" aria-hidden="true">#</a> STL</h2><h3 id="map和unordered-map的区别-各自使用场景是什么" tabindex="-1"><a class="header-anchor" href="#map和unordered-map的区别-各自使用场景是什么" aria-hidden="true">#</a> map和unordered_map的区别? 各自使用场景是什么？</h3><p><strong>1.底层实现</strong></p><ul><li>map: 是基于红黑树（一种自平衡二叉搜索树）实现的。这使得 map 中的元素是按照键的顺序自动排序的。</li><li>unordered_map: 是基于哈希表实现的，元素的存储顺序是无序的，取决于哈希函数的结果。</li></ul><p><strong>2. 时间复杂度</strong></p><ul><li><p>map: 由于是平衡二叉搜索树，插入、删除和查找操作的平均时间复杂度为 O(log n)。</p></li><li><p>unordered_map: 由于是基于哈希表实现的，插入、删除和查找操作的平均时间复杂度为 O(1)。但在最坏情况下，可能会退化到 O(n)（例如，当哈希冲突严重时）。 <strong>3. 元素的存储顺序</strong></p></li><li><p>map: 元素按键的顺序存储和遍历。</p></li><li><p>unordered_map: 元素没有特定的顺序，遍历顺序是不可预测的。 <strong>4. 内存消耗</strong></p></li><li><p>map: 由于红黑树结构的原因，通常需要额外的内存来维持树的平衡。</p></li><li><p>unordered_map: 由于使用哈希表，其内存使用量主要取决于负载因子和哈希冲突的处理方式。 <strong>5. 使用场景</strong></p></li><li><p>map:</p><ul><li>当需要对键值进行排序或按顺序遍历时，选择 map。</li><li>例如，需要按字母顺序存储和检索学生姓名及其成绩的情况。</li><li>适合需要较稳定的时间复杂度和有序数据访问的场景。</li></ul></li><li><p>unordered_map:</p><ul><li>当主要关注查找速度而不关心键的顺序时，选择 unordered_map。</li><li>例如，用于统计单词频率或存储哈希表以快速查找的情况。</li><li>适合数据量大且对性能要求高的场景，特别是需要高效的查找、插入和删除操作时。</li></ul></li></ul><p><strong>总结</strong></p><ul><li>使用 map 当你需要有序的数据或者需要比较稳定的性能时。</li><li>使用 unordered_map 当你更关注查找、插入和删除操作的性能，并且不需要数据顺序时。</li></ul><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2>`,112),r={href:"https://zhuanlan.zhihu.com/p/629336564(%E5%90%AB%E7%AD%94%E6%A1%88)",target:"_blank",rel:"noopener noreferrer"};function d(k,v){const s=l("ExternalLinkIcon");return t(),p("div",null,[u,n("p",null,[n("a",r,[e("https://zhuanlan.zhihu.com/p/629336564(含答案)"),o(s)])])])}const b=a(i,[["render",d],["__file","cpp.html.vue"]]);export{b as default};
