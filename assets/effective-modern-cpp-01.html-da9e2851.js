import{_ as n,V as s,W as a,a0 as p}from"./framework-c954d91f.js";const e={},t=p(`<h1 id="模板中的类型推导" tabindex="-1"><a class="header-anchor" href="#模板中的类型推导" aria-hidden="true">#</a> 模板中的类型推导</h1><p>本文主要讨论c++模板中的类型推导过程。</p><p>通常，模板的格式如下所示：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>ParamType param<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>而模板的调用格式如下所示：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token function">f</span><span class="token punctuation">(</span>expr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>所谓类型推导，就是<strong>已知expr</strong>， 推导出<strong>ParamType和T</strong>。模板类型的推导是对T和ParamType同时进行的。</p><p>推导过程需要按照ParamType的格式分别讨论：</p><ul><li>ParamType是一个指针或者引用, 但不是通用引用</li><li>ParamType是一个万能引用</li><li>ParamType既不是指针也不是引用</li></ul><h2 id="paramtype是一个指针或引用-但不是通用引用" tabindex="-1"><a class="header-anchor" href="#paramtype是一个指针或引用-但不是通用引用" aria-hidden="true">#</a> ParamType是一个指针或引用，但不是通用引用</h2><p>在这种情况下，类型推导会这样进行：</p><ul><li>如果expr的类型是一个引用，忽略引用部分</li><li>然后expr的类型与ParamType进行模式匹配来决定T</li></ul><p>我们通过例子进行理解，假设我们的模板中的ParamType是<code>T&amp; param</code>。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">//ParamType是一个引用</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>我们声明这些变量，</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">27</span><span class="token punctuation">;</span>                       <span class="token comment">//x是int</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> cx<span class="token operator">=</span>x<span class="token punctuation">;</span>                 <span class="token comment">//cx是const int</span>
<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> rx<span class="token operator">=</span>x<span class="token punctuation">;</span>                <span class="token comment">//rx是指向作为const int的x的引用const int&amp;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在不同的调用中，对param和T推导的类型会是这样：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                           <span class="token comment">//T是int，param的类型是int&amp;</span>
<span class="token function">f</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//T是const int，param的类型是const int&amp;</span>
<span class="token function">f</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//expr是const int&amp;， 按照规则要忽略引用部分， 因此T是const int，param的类型是const int&amp;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果ParamType中包含了const，推导如下：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//param现在是reference-to-const</span>

<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>                     <span class="token comment">//x是int</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> cx <span class="token operator">=</span> x<span class="token punctuation">;</span>               <span class="token comment">//cx是const int</span>
<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> rx <span class="token operator">=</span> x<span class="token punctuation">;</span>              <span class="token comment">//rx是指向作为const int的x的引用const int&amp;</span>

<span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                           <span class="token comment">//T是int，param的类型是const int&amp;</span>
<span class="token function">f</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//T是int，param的类型是const int&amp;</span>
<span class="token function">f</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">///expr是const int&amp;T，因为ParamType里面已经有了&amp;，因此忽略这里的引用，因此T是int，param的类型是const int&amp;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当ParamType是指针时：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">*</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">//param现在是指针</span>

<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>                     <span class="token comment">//同之前一样</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>px <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>             <span class="token comment">//px是指向作为const int的x的指针</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//T是int，param的类型是int*</span>
<span class="token function">f</span><span class="token punctuation">(</span>px<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//T是const int，param的类型是const int*</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="paramtype是一个通用引用" tabindex="-1"><a class="header-anchor" href="#paramtype是一个通用引用" aria-hidden="true">#</a> ParamType是一个通用引用</h2><ul><li><p>如果expr是左值，T和ParamType都会被推导为左值引用。这非常不寻常，第一，这是模板类型推导中唯一一种T被推导为引用的情况。第二，虽然ParamType被声明为右值引用类型，但是最后推导的结果是左值引用。</p></li><li><p>如果expr是右值，就使用正常的（也就是情景一）推导规则</p></li></ul><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">//param现在是一个通用引用类型</span>
		
<span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">27</span><span class="token punctuation">;</span>                       <span class="token comment">//如之前一样</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> cx<span class="token operator">=</span>x<span class="token punctuation">;</span>                 <span class="token comment">//如之前一样</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span> rx<span class="token operator">=</span>cx<span class="token punctuation">;</span>              <span class="token comment">//如之前一样</span>

<span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                           <span class="token comment">//x是左值，所以T是int&amp;，</span>
                                <span class="token comment">//param类型也是int&amp;</span>

<span class="token function">f</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//cx是左值，所以T是const int&amp;，</span>
                                <span class="token comment">//param类型也是const int&amp;</span>

<span class="token function">f</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//rx是左值，所以T是const int&amp;，</span>
                                <span class="token comment">//param类型也是const int&amp;</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//27是右值，所以T是int，</span>
                                <span class="token comment">//param类型就是int&amp;&amp;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="paramtype既不是指针也不是引用-值传递" tabindex="-1"><a class="header-anchor" href="#paramtype既不是指针也不是引用-值传递" aria-hidden="true">#</a> ParamType既不是指针也不是引用(值传递)</h2><p>当ParamType既不是指针也不是引用时，我们通过传值（pass-by-value）的方式处理：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//以传值的方式处理param</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>和之前一样，如果expr的类型是一个引用，忽略这个引用部分</li><li>如果忽略expr的引用性（reference-ness）之后，expr是一个const，那就再忽略const。如果它是volatile，也忽略volatile。忽略cv属性。</li><li>expr不可以是指针</li></ul><p>因此</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">27</span><span class="token punctuation">;</span>                       <span class="token comment">//如之前一样</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> cx<span class="token operator">=</span>x<span class="token punctuation">;</span>                 <span class="token comment">//如之前一样</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span> rx<span class="token operator">=</span>cx<span class="token punctuation">;</span>              <span class="token comment">//如之前一样</span>

<span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                           <span class="token comment">//T和param的类型都是int</span>
<span class="token function">f</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//T和param的类型都是int</span>
<span class="token function">f</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//T和param的类型都是int</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意即使cx和rx表示const值，param也不是const。这是有意义的。</p><p>param是一个完全独立于cx和rx的对象——是cx或rx的一个拷贝。具有常量性的cx和rx不可修改并不代表param也是一样。这就是为什么expr的常量性constness（或易变性volatileness)在推导param类型时会被忽略：因为expr不可修改并不意味着它的拷贝也不能被修改。</p><p>我们实际跑一下这个例子，</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    param <span class="token operator">=</span> <span class="token number">28</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> cx <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> rx <span class="token operator">=</span> cx<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> rrx <span class="token operator">=</span> x<span class="token punctuation">;</span>

    <span class="token comment">/*
    void f(int param)}
    {
        param = 28;
    }
    */</span>
    <span class="token function">f</span><span class="token punctuation">(</span>rrx<span class="token punctuation">)</span><span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> rrx <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结果为：27。</p><p>从运行结果可以看到，rrx的值并没有被修改。并且expr含有const，但是param=28并没有const， 说明const属性被去掉了。综上，这里的T推导的是int，param的类型为int。</p><p>认识到只有在传值给形参时才会忽略const（和volatile）这一点很重要，正如我们看到的，对于reference-to-const和pointer-to-const形参来说，expr的常量性constness在推导时会被保留。但是考虑这样的情况，expr是一个const指针，指向const对象，expr通过传值传递给param：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//仍然以传值的方式处理param</span>

<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> ptr <span class="token operator">=</span>         <span class="token comment">//ptr是一个常量指针，指向常量对象 </span>
    <span class="token string">&quot;Fun with pointers&quot;</span><span class="token punctuation">;</span>

<span class="token function">f</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">//传递const char * const类型的实参</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里，解引用符号<code>（*）</code>的右边的const表示ptr本身是一个const：ptr不能被修改为指向其它地址，也不能被设置为null（解引用符号左边的const表示ptr指向一个字符串，这个字符串是const，因此字符串不能被修改）。当ptr作为实参传给f，组成这个指针的每一比特都被拷贝进param。像这种情况，ptr自身的值会被传给形参，根据类型推导的第三条规则，ptr自身的常量性constness将会被省略，所以param是const char*，也就是一个可变指针指向const字符串。在类型推导中，这个指针指向的数据的常量性constness将会被保留，但是当拷贝ptr来创造一个新指针param时，ptr自身的常量性constness将会被忽略。</p><h2 id="特别讨论-数组入参和函数入参" tabindex="-1"><a class="header-anchor" href="#特别讨论-数组入参和函数入参" aria-hidden="true">#</a> 特别讨论：数组入参和函数入参</h2><p><strong>数组实参</strong> 上面的内容几乎覆盖了模板类型推导的大部分内容，但这里还有一些小细节值得注意，比如数组类型不同于指针类型，虽然它们两个有时候是可互换的。关于这个错觉最常见的例子是，在很多上下文中数组会退化为指向它的第一个元素的指针。这样的退化允许像这样的代码可以被编译：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;J. P. Briggs&quot;</span><span class="token punctuation">;</span>     <span class="token comment">//name的类型是const char[13]</span>

<span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> ptrToName <span class="token operator">=</span> name<span class="token punctuation">;</span>          <span class="token comment">//数组退化为指针</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里<code>const char*</code>指针ptrToName会由name初始化，而name的类型为<code>const char[13]</code>，这两种类型（<code>const char*</code>和<code>const char[13]</code>）是不一样的，但是由于数组退化为指针的规则，编译器允许这样的代码。</p><p>但要是一个数组传值给一个模板会怎样？会发生什么？</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">//传值形参的模板</span>

<span class="token function">f</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment">//T和param会推导成什么类型?</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们从一个简单的例子开始，这里有一个函数的形参是数组，是的，这样的语法是合法的，</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">myFunc</span><span class="token punctuation">(</span><span class="token keyword">int</span> param<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但是数组声明会被视作指针声明，这意味着myFunc的声明和下面声明是等价的：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">myFunc</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//与上面相同的函数</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>数组与指针形参这样的等价是C语言的产物，C++又是建立在C语言的基础上，它让人产生了一种数组和指针是等价的的错觉。</p><p>因为数组形参会视作指针形参，所以传值给模板的一个数组类型会被推导为一个指针类型。这意味着在模板函数f的调用中，它的类型形参T会被推导为const char*：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token function">f</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">//name是一个数组，但是T被推导为const char*</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但是现在难题来了，虽然函数不能声明形参为真正的数组，但是可以接受指向数组的引用！所以我们修改f为传引用：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment">//传引用形参的模板</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>我们这样进行调用，</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token function">f</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment">//传数组给f</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>T被推导为了真正的数组！这个类型包括了数组的大小，在这个例子中T被推导为const char[13]，f的形参（对这个数组的引用）的类型则为const char (&amp;)[13]。是的，这种语法看起来简直有毒，但是知道它将会让你在关心这些问题的人的提问中获得大神的称号。</p><p>有趣的是，可声明指向数组的引用的能力，使得我们可以创建一个模板函数来推导出数组的大小：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">//在编译期间返回一个数组大小的常量值（//数组形参没有名字，</span>
<span class="token comment">//因为我们只关心数组的大小）</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t N<span class="token operator">&gt;</span>                     <span class="token comment">//关于</span>
<span class="token keyword">constexpr</span> std<span class="token double-colon punctuation">::</span>size_t <span class="token function">arraySize</span><span class="token punctuation">(</span><span class="token function">T</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span>      <span class="token comment">//constexpr</span>
<span class="token punctuation">{</span>                                                       <span class="token comment">//和noexcept</span>
    <span class="token keyword">return</span> N<span class="token punctuation">;</span>                                           <span class="token comment">//的信息</span>
<span class="token punctuation">}</span>                                                       <span class="token comment">//请看下面</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在Item15提到将一个函数声明为constexpr使得结果在编译期间可用。这使得我们可以用一个花括号声明一个数组，然后第二个数组可以使用第一个数组的大小作为它的大小，就像这样：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> keyVals<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">35</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>             <span class="token comment">//keyVals有七个元素</span>

<span class="token keyword">int</span> mappedVals<span class="token punctuation">[</span><span class="token function">arraySize</span><span class="token punctuation">(</span>keyVals<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                     <span class="token comment">//mappedVals也有七个</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然作为一个现代C++程序员，你自然应该想到使用std::array而不是内置的数组：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token function">arraySize</span><span class="token punctuation">(</span>keyVals<span class="token punctuation">)</span><span class="token operator">&gt;</span> mappedVals<span class="token punctuation">;</span>         <span class="token comment">//mappedVals的大小为7</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>至于arraySize被声明为noexcept，会使得编译器生成更好的代码，具体的细节请参见Item14。</p><p><strong>函数实参</strong> 在C++中不只是数组会退化为指针，函数类型也会退化为一个函数指针，我们对于数组类型推导的全部讨论都可以应用到函数类型推导和退化为函数指针上来。结果是：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">someFunc</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//someFunc是一个函数，</span>
                                    <span class="token comment">//类型是void(int, double)</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">//传值给f1</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//传引用给f2</span>

<span class="token function">f1</span><span class="token punctuation">(</span>someFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment">//param被推导为指向函数的指针，</span>
                                    <span class="token comment">//类型是void(*)(int, double)</span>
<span class="token function">f2</span><span class="token punctuation">(</span>someFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment">//param被推导为指向函数的引用，</span>
                                    <span class="token comment">//类型是void(&amp;)(int, double)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个实际上没有什么不同，但是如果你知道数组退化为指针，你也会知道函数退化为指针。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><ul><li>在模板类型推导时，有引用的实参会被视为无引用，他们的引用会被忽略</li><li>对于通用引用的推导，左值实参会被特殊对待</li><li>对于传值类型推导，const和/或volatile实参会被认为是non-const的和non-volatile的</li><li>在模板类型推导时，数组名或者函数名实参会退化为指针，除非它们被用于初始化引用</li></ul>`,70),c=[t];function o(l,i){return s(),a("div",null,c)}const u=n(e,[["render",o],["__file","effective-modern-cpp-01.html.vue"]]);export{u as default};
