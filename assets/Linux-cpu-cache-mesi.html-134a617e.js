import{_ as c,V as n,W as o,X as e,Y as a,$ as t,a0 as r,F as s}from"./framework-9a29aaa0.js";const h={},p=r('<h1 id="cpu缓存一致性原理" tabindex="-1"><a class="header-anchor" href="#cpu缓存一致性原理" aria-hidden="true">#</a> CPU缓存一致性原理</h1><p>在本站的文章<strong>CPU缓存那些事儿</strong>中， 介绍了cpu的多级缓存的架构和cpu缓存行cacheline的结构。CPU对于缓存的操作包含读和写，读操作在cacheline中有所涉及，在本文中，将讨论CPU对于缓存进行写时的行为。</p><h2 id="cpu对高速缓存的读操作" tabindex="-1"><a class="header-anchor" href="#cpu对高速缓存的读操作" aria-hidden="true">#</a> CPU对高速缓存的读操作</h2><h2 id="cpu对于高速缓存的写操作" tabindex="-1"><a class="header-anchor" href="#cpu对于高速缓存的写操作" aria-hidden="true">#</a> CPU对于高速缓存的写操作</h2><h3 id="写直达" tabindex="-1"><a class="header-anchor" href="#写直达" aria-hidden="true">#</a> 写直达</h3><h3 id="写回策略" tabindex="-1"><a class="header-anchor" href="#写回策略" aria-hidden="true">#</a> 写回策略</h3><h2 id="写操作带来的不一致问题" tabindex="-1"><a class="header-anchor" href="#写操作带来的不一致问题" aria-hidden="true">#</a> 写操作带来的不一致问题</h2><h3 id="mesi协议" tabindex="-1"><a class="header-anchor" href="#mesi协议" aria-hidden="true">#</a> MESI协议</h3><p>MESI协议是一种用于保证缓存一致性的协议，其对应了CPU cache的四种状态，每个字母代表了一种状态，其含义如下：</p><ul><li>M（Modified，已修改）： 表明 Cache 块被修改过，但未同步回内存；</li><li>E（Exclusive，独占）： 表明 Cache 块被当前核心独占，而其它核心的同一个 Cache 块会失效；</li><li>S（Shared，共享）： 表明 Cache 块被多个核心持有且都是有效的；</li><li>I（Invalidated，已失效）： 表明 Cache 块的数据是过时的。</li></ul><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/Linux/application-dev/CPU-cache-mesi/MESI-state.png" alt="cache line" tabindex="0" loading="lazy"><figcaption>cache line</figcaption></figure><p>状态E转状态M</p><p>初始化状态为E：</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/Linux/application-dev/CPU-cache-mesi/EtoM_1.png" alt="cache line" tabindex="0" loading="lazy"><figcaption>cache line</figcaption></figure><p>通过processor write，状态E转为状态M：</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/Linux/application-dev/CPU-cache-mesi/EtoM_2.png" alt="cache line" tabindex="0" loading="lazy"><figcaption>cache line</figcaption></figure><p>状态M转状态S</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/Linux/application-dev/CPU-cache-mesi/MtoS_1.png" alt="cache line" tabindex="0" loading="lazy"><figcaption>cache line</figcaption></figure><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/Linux/application-dev/CPU-cache-mesi/MtoS_2.png" alt="cache line" tabindex="0" loading="lazy"><figcaption>cache line</figcaption></figure><p>状态S转状态I</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/Linux/application-dev/CPU-cache-mesi/StoI_1.png" alt="cache line" tabindex="0" loading="lazy"><figcaption>cache line</figcaption></figure><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/Linux/application-dev/CPU-cache-mesi/StoI_2.png" alt="cache line" tabindex="0" loading="lazy"><figcaption>cache line</figcaption></figure><p>状态S转状态E</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/Linux/application-dev/CPU-cache-mesi/StoE_1.png" alt="cache line" tabindex="0" loading="lazy"><figcaption>cache line</figcaption></figure><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/Linux/application-dev/CPU-cache-mesi/StoE_2.png" alt="cache line" tabindex="0" loading="lazy"><figcaption>cache line</figcaption></figure><p>写缓冲区（Store Buffer）</p><p>由于在写入操作之前，CPU 核心 1 需要先广播 RFO 请求获得独占权，在其它核心回应 ACK 之前，当前核心只能空等待，这对 CPU 资源是一种浪费。因此，现代 CPU 会采用 “写缓冲区” 机制：写入指令放到写缓冲区后并发送 RFO 请求后，CPU 就可以去执行其它任务，等收到 ACK 后再将写入操作写到 Cache 上。</p><p>失效队列（Invalidation Queue）</p><p>由于其他核心在收到 RFO 请求时，需要及时回应 ACK。但如果核心很忙不能及时回复，就会造成发送 RFO 请求的核心在等待 ACK。因此，现代 CPU 会采用 “失效队列” 机制：先把其它核心发过来的 RFO 请求放到失效队列，然后直接返回 ACK，等当前核心处理完任务后再去处理失效队列中的失效请求。</p>',29),l={href:"https://www.scss.tcd.ie/Jeremy.Jones/VivioJS/caches/MESIHelp.htm",target:"_blank",rel:"noopener noreferrer"},g={href:"https://juejin.cn/post/7158395475362578462",target:"_blank",rel:"noopener noreferrer"},d={href:"https://blog.51cto.com/qmiller/5285102",target:"_blank",rel:"noopener noreferrer"};function u(m,f){const i=s("ExternalLinkIcon");return n(),o("div",null,[p,e("p",null,[e("a",l,[a("https://www.scss.tcd.ie/Jeremy.Jones/VivioJS/caches/MESIHelp.htm"),t(i)]),e("a",g,[a("https://juejin.cn/post/7158395475362578462"),t(i)]),e("a",d,[a("https://blog.51cto.com/qmiller/5285102"),t(i)])])])}const b=c(h,[["render",u],["__file","Linux-cpu-cache-mesi.html.vue"]]);export{b as default};
