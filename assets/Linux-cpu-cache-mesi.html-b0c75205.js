const e=JSON.parse('{"key":"v-bf0b1b8a","path":"/posts/Linux/application-dev/Linux-cpu-cache-mesi.html","title":"CPU缓存一致性原理","lang":"zh-CN","frontmatter":{"category":["Linux"],"description":"CPU缓存一致性原理 在本站的文章CPU缓存那些事儿中， 介绍了cpu的多级缓存的架构和cpu缓存行cacheline的结构。CPU对于缓存的操作包含读和写，读操作在cacheline中有所涉及，在本文中，将讨论CPU对于缓存进行写时的行为。 CPU对高速缓存的读操作 CPU对于高速缓存的读操作的过程在之前的文章中有提到过，这里梳理一下其流程： 1.首先对于一个内存地址，按照索引规则（直接映射/多路组相连/全相连）去cache line中进行检索。 2.如果检索到了，意味着该内存地址的内容已经存在于cache line中，则直接读取内容到CPU中，流程结束。如果没有检索到，进行步骤3。 3.此时确认内存的数据不在cache line中，如果cpu cache line已经存满或者已经被其他内存地址映射，则进入步骤4，如果cache line中还有空位，则进入步骤5. 4.执行缓存淘汰策略，腾出位置 5.加载内存数据到cache line中，将cache块上的内容读取到cpu中。","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/Linux/application-dev/Linux-cpu-cache-mesi.html"}],["meta",{"property":"og:site_name","content":"Code Building"}],["meta",{"property":"og:title","content":"CPU缓存一致性原理"}],["meta",{"property":"og:description","content":"CPU缓存一致性原理 在本站的文章CPU缓存那些事儿中， 介绍了cpu的多级缓存的架构和cpu缓存行cacheline的结构。CPU对于缓存的操作包含读和写，读操作在cacheline中有所涉及，在本文中，将讨论CPU对于缓存进行写时的行为。 CPU对高速缓存的读操作 CPU对于高速缓存的读操作的过程在之前的文章中有提到过，这里梳理一下其流程： 1.首先对于一个内存地址，按照索引规则（直接映射/多路组相连/全相连）去cache line中进行检索。 2.如果检索到了，意味着该内存地址的内容已经存在于cache line中，则直接读取内容到CPU中，流程结束。如果没有检索到，进行步骤3。 3.此时确认内存的数据不在cache line中，如果cpu cache line已经存满或者已经被其他内存地址映射，则进入步骤4，如果cache line中还有空位，则进入步骤5. 4.执行缓存淘汰策略，腾出位置 5.加载内存数据到cache line中，将cache块上的内容读取到cpu中。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-08-16T02:45:29.000Z"}],["meta",{"property":"article:modified_time","content":"2023-08-16T02:45:29.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"CPU缓存一致性原理\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-08-16T02:45:29.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"CPU对高速缓存的读操作","slug":"cpu对高速缓存的读操作","link":"#cpu对高速缓存的读操作","children":[]},{"level":2,"title":"CPU对于高速缓存的写操作","slug":"cpu对于高速缓存的写操作","link":"#cpu对于高速缓存的写操作","children":[{"level":3,"title":"写直达","slug":"写直达","link":"#写直达","children":[]},{"level":3,"title":"写回策略","slug":"写回策略","link":"#写回策略","children":[]}]},{"level":2,"title":"写操作带来的不一致问题","slug":"写操作带来的不一致问题","link":"#写操作带来的不一致问题","children":[{"level":3,"title":"MESI协议","slug":"mesi协议","link":"#mesi协议","children":[]}]}],"git":{"createdTime":1688367205000,"updatedTime":1692153929000,"contributors":[{"name":"zgjsxx","email":"119160524@qq.com","commits":17}]},"readingTime":{"minutes":4.13,"words":1239},"filePathRelative":"posts/Linux/application-dev/Linux-cpu-cache-mesi.md","localizedDate":"2023年7月3日","excerpt":"<h1> CPU缓存一致性原理</h1>\\n<p>在本站的文章<strong>CPU缓存那些事儿</strong>中， 介绍了cpu的多级缓存的架构和cpu缓存行cacheline的结构。CPU对于缓存的操作包含读和写，读操作在cacheline中有所涉及，在本文中，将讨论CPU对于缓存进行写时的行为。</p>\\n<h2> CPU对高速缓存的读操作</h2>\\n<p>CPU对于高速缓存的读操作的过程在之前的文章中有提到过，这里梳理一下其流程：</p>\\n<ul>\\n<li>1.首先对于一个内存地址，按照索引规则（直接映射/多路组相连/全相连）去cache line中进行检索。</li>\\n<li>2.如果检索到了，意味着该内存地址的内容已经存在于cache line中，则直接读取内容到CPU中，流程结束。如果没有检索到，进行步骤3。</li>\\n<li>3.此时确认内存的数据不在cache line中，如果cpu cache line已经存满或者已经被其他内存地址映射，则进入步骤4，如果cache line中还有空位，则进入步骤5.</li>\\n<li>4.执行缓存淘汰策略，腾出位置</li>\\n<li>5.加载内存数据到cache line中，将cache块上的内容读取到cpu中。</li>\\n</ul>","autoDesc":true}');export{e as data};
