import{_ as c,V as p,W as l,X as s,Y as n,$ as e,a1 as t,a0 as o,F as u}from"./framework-9a29aaa0.js";const d={},i=s("h1",{id:"item36-如果有异步的必要请指定std-launch-async",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#item36-如果有异步的必要请指定std-launch-async","aria-hidden":"true"},"#"),n(" Item36：如果有异步的必要请指定std::launch::async")],-1),r=s("code",null,"std::async",-1),k=s("code",null,"std::async",-1),m=s("code",null,"std::async",-1),_=s("code",null,"std::launch",-1),f=s("code",null,"enum",-1),v=s("code",null,"f",-1),h=s("code",null,"std::async",-1),b=s("li",null,[s("strong",null,[s("code",null,"std::launch::async"),n("启动策略")]),n("意味着"),s("code",null,"f"),n("必须异步执行，即在不同的线程。")],-1),y=s("strong",null,[s("code",null,"std::launch::deferred"),n("启动策略")],-1),g=s("code",null,"f",-1),w=s("code",null,"std::async",-1),x=s("em",null,"future",-1),T=s("code",null,"get",-1),C=s("code",null,"wait",-1),I=s("code",null,"f",-1),P=s("strong",null,"推迟",-1),A=s("code",null,"get",-1),F=s("code",null,"wait",-1),M=s("code",null,"f",-1),V=s("code",null,"f",-1),L=s("code",null,"get",-1),N=s("code",null,"wait",-1),R=s("code",null,"f",-1),S=s("code",null,"get",-1),B=s("code",null,"wait",-1),E=s("em",null,"future",-1),W=s("em",null,"future",-1),X=s("em",null,"future",-1),Y=s("code",null,"std::future",-1),$=s("code",null,"std::shared_future",-1),j=s("code",null,"std::shared_future",-1),q=s("code",null,"f",-1),z=s("code",null,"std::async",-1),D=s("em",null,"future",-1),G=s("code",null,"std::async",-1),H=s("em",null,"future",-1),J=s("code",null,"std::async",-1),K=s("em",null,"future",-1),O=s("code",null,"get",-1),Q=s("code",null,"wait",-1),U=o(`<p>可能让人惊奇的是，<code>std::async</code>的默认启动策略——你不显式指定一个策略时它使用的那个——不是上面中任意一个。相反，是求或在一起的。下面的两种调用含义相同：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">auto</span> fut1 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment">//使用默认启动策略运行f</span>
<span class="token keyword">auto</span> fut2 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>launch<span class="token double-colon punctuation">::</span>async <span class="token operator">|</span>     <span class="token comment">//使用async或者deferred运行f</span>
                       std<span class="token double-colon punctuation">::</span>launch<span class="token double-colon punctuation">::</span>deferred<span class="token punctuation">,</span>
                       f<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,2),Z=s("code",null,"f",-1),nn=s("code",null,"std::async",-1),sn=s("code",null,"std::async",-1),an=o(`<p>但是，使用默认启动策略的<code>std::async</code>也有一些有趣的影响。给定一个线程<code>t</code>执行此语句：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">auto</span> fut <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//使用默认启动策略运行f</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><strong>无法预测<code>f</code>是否会与<code>t</code>并发运行</strong>，因为<code>f</code>可能被安排延迟运行。</li><li><strong>无法预测<code>f</code>是否会在与某线程相异的另一线程上执行，这个某线程在<code>fut</code>上调用<code>get</code>或<code>wait</code></strong>。如果对<code>fut</code>调用函数的线程是<code>t</code>，含义就是无法预测<code>f</code>是否在异于<code>t</code>的另一线程上执行。</li><li><strong>无法预测<code>f</code>是否执行</strong>，因为不能确保在程序每条路径上，都会不会在<code>fut</code>上调用<code>get</code>或者<code>wait</code>。</li></ul><p>默认启动策略的调度灵活性导致使用<code>thread_local</code>变量比较麻烦，因为这意味着如果<code>f</code>读写了<strong>线程本地存储</strong>（<em>thread-local storage</em>，TLS），不可能预测到哪个线程的变量被访问：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">auto</span> fut <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//f的TLS可能是为单独的线程建的，</span>
                            <span class="token comment">//也可能是为在fut上调用get或者wait的线程建的</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>`,5),en=s("code",null,"wait",-1),tn=s("code",null,"wait_for",-1),on=s("code",null,"wait_until",-1),cn=s("code",null,"std::launch::deferred",-1),pn=o(`<div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token double-colon punctuation">::</span>literals<span class="token punctuation">;</span>      <span class="token comment">//为了使用C++14中的时间段后缀；参见条款34</span>

<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                            <span class="token comment">//f休眠1秒，然后返回</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span><span class="token number">1</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">auto</span> fut <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">//异步运行f（理论上）</span>

<span class="token keyword">while</span> <span class="token punctuation">(</span>fut<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span><span class="token number">100</span>ms<span class="token punctuation">)</span> <span class="token operator">!=</span>       <span class="token comment">//循环，直到f完成运行时停止...</span>
       std<span class="token double-colon punctuation">::</span>future_status<span class="token double-colon punctuation">::</span>ready<span class="token punctuation">)</span>   <span class="token comment">//但是有可能永远不会发生！</span>
<span class="token punctuation">{</span>
    …
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果<code>f</code>与调用<code>std::async</code>的线程并发运行（即，如果为<code>f</code>选择的启动策略是<code>std::launch::async</code>），这里没有问题（假定<code>f</code>最终会执行完毕），但是如果<code>f</code>是延迟执行，<code>fut.wait_for</code>将总是返回<code>std::future_status::deferred</code>。这永远不等于<code>std::future_status::ready</code>，循环会永远执行下去。</p><p>这种错误很容易在开发和单元测试中忽略，因为它可能在负载过高时才能显现出来。那些是使机器资源超额或者线程耗尽的条件，此时任务推迟执行才最有可能发生。毕竟，如果硬件没有资源耗尽，没有理由不安排任务并发执行。</p><p>修复也是很简单的：只需要检查与<code>std::async</code>对应的<code>future</code>是否被延迟执行即可，那样就会避免进入无限循环。不幸的是，没有直接的方法来查看<code>future</code>是否被延迟执行。相反，你必须调用一个超时函数——比如<code>wait_for</code>这种函数。在这个情况中，你不想等待任何事，只想查看返回值是否是<code>std::future_status::deferred</code>，所以无须怀疑，使用0调用<code>wait_for</code>：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">auto</span> fut <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">//同上</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>fut<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span><span class="token number">0</span>s<span class="token punctuation">)</span> <span class="token operator">==</span>                 <span class="token comment">//如果task是deferred（被延迟）状态</span>
    std<span class="token double-colon punctuation">::</span>future_status<span class="token double-colon punctuation">::</span>deferred<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    …                                   <span class="token comment">//在fut上调用wait或get来异步调用f</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                                <span class="token comment">//task没有deferred（被延迟）</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>fut<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span><span class="token number">100</span>ms<span class="token punctuation">)</span> <span class="token operator">!=</span>       <span class="token comment">//不可能无限循环（假设f完成）</span>
           std<span class="token double-colon punctuation">::</span>future_status<span class="token double-colon punctuation">::</span>ready<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        …                               <span class="token comment">//task没deferred（被延迟），也没ready（已准备）</span>
                                        <span class="token comment">//做并行工作直到已准备</span>
    <span class="token punctuation">}</span>
    …                                   <span class="token comment">//fut是ready（已准备）状态</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些各种考虑的结果就是，只要满足以下条件，<code>std::async</code>的默认启动策略就可以使用：</p><ul><li>任务不需要和执行<code>get</code>或<code>wait</code>的线程并行执行。</li><li>读写哪个线程的<code>thread_local</code>变量没什么问题。</li><li>可以保证会在<code>std::async</code>返回的<em>future</em>上调用<code>get</code>或<code>wait</code>，或者该任务可能永远不会执行也可以接受。</li><li>使用<code>wait_for</code>或<code>wait_until</code>编码时考虑到了延迟状态。</li></ul><p>如果上述条件任何一个都满足不了，你可能想要保证<code>std::async</code>会安排任务进行真正的异步执行。进行此操作的方法是调用时，将<code>std::launch::async</code>作为第一个实参传递：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">auto</span> fut <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>launch<span class="token double-colon punctuation">::</span>async<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//异步启动f的执行</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>事实上，对于一个类似<code>std::async</code>行为的函数，但是会自动使用<code>std::launch::async</code>作为启动策略的工具，拥有它会非常方便，而且编写起来很容易也使它看起来很棒。C++11版本如下：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">F</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">&gt;</span>
<span class="token keyword">inline</span>
std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>result_of<span class="token operator">&lt;</span><span class="token function">F</span><span class="token punctuation">(</span>Ts<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token operator">&gt;</span>
<span class="token function">reallyAsync</span><span class="token punctuation">(</span>F<span class="token operator">&amp;&amp;</span> f<span class="token punctuation">,</span> Ts<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span>          <span class="token comment">//返回异步调用f(params...)得来的future</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>launch<span class="token double-colon punctuation">::</span>async<span class="token punctuation">,</span>
                      std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>F<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">,</span>
                      std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>Ts<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,11),ln=s("code",null,"f",-1),un=s("code",null,"params",-1),dn=s("code",null,"std::async",-1),rn=s("code",null,"std::launch::async",-1),kn=s("code",null,"std::async",-1),mn=s("code",null,"std::future",-1),_n=s("code",null,"params",-1),fn=s("code",null,"f",-1),vn=s("em",null,"type trait",-1),hn=s("code",null,"std::result_of",-1),bn=s("em",null,"type trait",-1),yn=o(`<p><code>reallyAsync</code>就像<code>std::async</code>一样使用：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">auto</span> fut <span class="token operator">=</span> <span class="token function">reallyAsync</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//异步运行f，如果std::async抛出异常它也会抛出</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在C++14中，<code>reallyAsync</code>返回类型的推导能力可以简化函数的声明：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">F</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">&gt;</span>
<span class="token keyword">inline</span>
<span class="token keyword">auto</span>                                        <span class="token comment">// C++14</span>
<span class="token function">reallyAsync</span><span class="token punctuation">(</span>F<span class="token operator">&amp;&amp;</span> f<span class="token punctuation">,</span> Ts<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>launch<span class="token double-colon punctuation">::</span>async<span class="token punctuation">,</span>
                      std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>F<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">,</span>
                      std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>Ts<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个版本清楚表明，<code>reallyAsync</code>除了使用<code>std::launch::async</code>启动策略之外什么也没有做。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><ul><li><code>std::async</code>的默认启动策略是异步和同步执行兼有的。</li><li>这个灵活性导致访问<code>thread_local</code>s的不确定性，隐含了任务可能不会被执行的意思，会影响调用基于超时的<code>wait</code>的程序逻辑。</li><li>如果异步执行任务非常关键，则指定<code>std::launch::async</code>。</li></ul>`,7);function gn(wn,xn){const a=u("RouterLink");return p(),l("div",null,[i,s("p",null,[n("当你调用"),r,n("执行函数时（或者其他可调用对象），你通常希望异步执行函数。但是这并不一定是你要求"),k,n("执行的操作。你事实上要求这个函数按照"),m,n("启动策略来执行。有两种标准策略，每种都通过"),_,n("这个限域"),f,n("的一个枚举名表示（关于枚举的更多细节参见"),e(a,{to:"/posts/Program_language/3.MovingToModernCpp/item10.html"},{default:t(()=>[n("Item10")]),_:1}),n("）。假定一个函数"),v,n("传给"),h,n("来执行：")]),s("ul",null,[b,s("li",null,[y,n("意味着"),g,n("仅当在"),w,n("返回的"),x,n("上调用"),T,n("或者"),C,n("时才执行。这表示"),I,P,n("到存在这样的调用时才执行（译者注：异步与并发是两个不同概念，这里侧重于惰性求值）。当"),A,n("或"),F,n("被调用，"),M,n("会同步执行，即调用方被阻塞，直到"),V,n("运行结束。如果"),L,n("和"),N,n("都没有被调用，"),R,n("将不会被执行。（这是个简化说法。关键点不是要在其上调用"),S,n("或"),B,n("的那个"),E,n("，而是"),W,n("引用的那个共享状态。（"),e(a,{to:"/posts/Program_language/7.TheConcurrencyAPI/item38.html"},{default:t(()=>[n("Item38")]),_:1}),n("讨论了"),X,n("与共享状态的关系。）因为"),Y,n("支持移动，也可以用来构造"),$,n("，并且因为"),j,n("可以被拷贝，对共享状态——对"),q,n("传到的那个"),z,n("进行调用产生的——进行引用的"),D,n("对象，有可能与"),G,n("返回的那个"),H,n("对象不同。这非常绕口，所以经常回避这个事实，简称为在"),J,n("返回的"),K,n("上调用"),O,n("或"),Q,n("。）")])]),U,s("p",null,[n("因此默认策略允许"),Z,n("异步或者同步执行。如同"),e(a,{to:"/posts/Program_language/7.TheConcurrencyAPI/Item35.html"},{default:t(()=>[n("Item35")]),_:1}),n("中指出，这种灵活性允许"),nn,n("和标准库的线程管理组件承担线程创建和销毁的责任，避免资源超额，以及平衡负载。这就是使用"),sn,n("并发编程如此方便的原因。")]),an,s("p",null,[n("这还会影响到基于"),en,n("的循环使用超时机制，因为在一个延时的任务（参见"),e(a,{to:"/posts/Program_language/7.TheConcurrencyAPI/Item35.html"},{default:t(()=>[n("Item35")]),_:1}),n("）上调用"),tn,n("或者"),on,n("会产生"),cn,n("值。意味着，以下循环看似应该最终会终止，但可能实际上永远运行：")]),pn,s("p",null,[n("这个函数接受一个可调用对象"),ln,n("和0或多个形参"),un,n("，然后完美转发（参见"),e(a,{to:"/posts/Program_language/5.RRefMovSemPerfForw/item25.html"},{default:t(()=>[n("Item25")]),_:1}),n("）给"),dn,n("，使用"),rn,n("作为启动策略。就像"),kn,n("一样，返回"),mn,n("作为用"),_n,n("调用"),fn,n("得到的结果。确定结果的类型很容易，因为"),vn,n(),hn,n("可以提供给你。（参见"),e(a,{to:"/posts/Program_language/3.MovingToModernCpp/item9.html"},{default:t(()=>[n("Item9")]),_:1}),n("关于"),bn,n("的详细表述。）")]),yn])}const Cn=c(d,[["render",gn],["__file","effective-modern-cpp-36.html.vue"]]);export{Cn as default};
