import{_ as n,V as s,W as a,a0 as e}from"./framework-c954d91f.js";const p={},t=e(`<h1 id="item42-考虑使用置入-emplace-emplace-back-代替插入-push-push-back" tabindex="-1"><a class="header-anchor" href="#item42-考虑使用置入-emplace-emplace-back-代替插入-push-push-back" aria-hidden="true">#</a> Item42：考虑使用置入(emplace, emplace_back)代替插入(push, push_back)</h1><p>考虑我们有一个std::vector容器， 里面存放的内容是std::string。添加新元素时，我们需要使用如下的表达式：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> vs<span class="token punctuation">;</span>        <span class="token comment">//std::string的容器</span>
vs<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">&quot;xyzzy&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//创建临时std::string，把它传给push_back</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个过程中push_back做了如下的事情：</p><ul><li><p>1.一个<code>std::string</code>的临时对象从字面量“xyzzy”被创建。这个对象没有名字，我们可以称为temp。temp的构造是第一次std::string构造。因为是临时变量，所以temp是右值。</p></li><li><p>2.temp被传递给push_back的右值重载函数，绑定到右值引用形参x。在<code>std::vector</code>的内存中一个x的副本被创建。这次构造——也是第二次构造——在<code>std::vecto</code>r内部真正创建一个对象。（将x副本拷贝到<code>std::vector</code>内部的构造函数是移动构造函数，因为x在它被拷贝前被转换为一个右值，成为右值引用。有关将右值引用形参强制转换为右值的信息，请参见Item25）。</p></li><li><p>3。在push_back返回之后，temp立刻被销毁，调用了一次<code>std::string</code>的析构函数。</p></li></ul><p>可以看到，这里需要创建temp对象，是否存在一种方法可以获取字符串字面量并将其直接传入到步骤2里在std::vector内构造std::string的代码中，可以避免临时对象temp的创建与销毁。就像下面这样呢？</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> vs<span class="token punctuation">;</span>        <span class="token comment">//std::string的容器</span>
vs<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">&quot;xyzzy&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//是否可以直接传递字面量，避免temp对象的构建？</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>emplace_back</strong>就是像我们想要的那样做的：使用传递给它的任何实参直接在<code>std::vector</code>内部构造一个<code>std::string</code>。没有临时变量会生成：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vs<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token string">&quot;xyzzy&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">//直接用“xyzzy”在vs内构造std::string</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>对比<strong>push_back</strong>和<strong>emplace_back</strong>的方法声明，emplace_back使用<strong>完美转发</strong>，因此只要你没有遇到完美转发的限制（参见Item30），就可以传递任何实参以及组合到emplace_back。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>  <span class="token keyword">void</span> <span class="token function">emplace_back</span><span class="token punctuation">(</span>Args<span class="token operator">&amp;&amp;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> value<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为可以传递容器内元素类型的实参给置入函数（因此该实参使函数执行复制或者移动构造函数），所以在插入函数不会构造临时对象的情况，也可以使用置入函数。在这种情况下，插入和置入函数做的是同一件事，比如：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>string <span class="token function">queenOfDisco</span><span class="token punctuation">(</span><span class="token string">&quot;Donna Summer&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>下面的调用都是可行的，对容器的实际效果也一样：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>vs<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>queenOfDisco<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//拷贝构造queenOfDisco</span>
vs<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>queenOfDisco<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//同上</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>因此，置入函数可以完成插入函数的所有功能。并且有时效率更高，至少在理论上，不会更低效。那为什么不在所有场合使用它们？</p><p>因为，就像说的那样，只是“理论上”，在理论和实际上没有什么区别，但是实际上区别还是有的。在当前标准库的实现下，有些场景，就像预期的那样，置入执行性能优于插入，但是，有些场景反而插入更快。这种场景不容易描述，因为依赖于传递的实参的类型、使用的容器、置入或插入到容器中的位置、容器中类型的构造函数的异常安全性，和对于禁止重复值的容器（即<code>std::set</code>，<code>std::map</code>，<code>std::unordered_set</code>，<code>set::unordered_map</code>）要添加的值是否已经在容器中。因此，大致的调用建议是：通过benchmark测试来确定置入和插入哪种更快。</p><p>当然这个结论不是很令人满意，所以你会很高兴听到还有一种启发式的方法来帮助你确定是否应该使用置入。如果下列条件都能满足，置入会优于插入：</p><ul><li><p>值是通过构造函数添加到容器，而不是直接赋值。 例子就像本条款刚开始的那样（用&quot;xyzzy&quot;添加<code>std::string</code>到<code>std::vector</code>容器vs中），值添加到vs末尾——一个先前没有对象存在的地方。新值必须通过构造函数添加到<code>std::vector</code>。如果我们回看这个例子，新值放到已经存在了对象的一个地方，那情况就完全不一样了。考虑下：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> vs<span class="token punctuation">;</span>        <span class="token comment">//跟之前一样</span>
…                                   <span class="token comment">//添加元素到vs</span>
vs<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>vs<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;xyzzy&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//添加“xyzzy”到vs头部</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于这份代码，没有实现会在已经存在对象的位置<code>vs[0]</code>构造这个添加的<code>std::string</code>。而是，通过移动赋值的方式添加到需要的位置。但是移动赋值需要一个源对象，所以这意味着一个临时对象要被创建，而置入优于插入的原因就是没有临时对象的创建和销毁，所以当通过赋值操作添加元素时，置入的优势消失殆尽。</p><p>而且，向容器添加元素是通过构造还是赋值通常取决于实现者。但是，启发式仍然是有帮助的。基于节点的容器实际上总是使用构造添加新元素，大多数标准库容器都是基于节点的。例外的容器只有<code>std::vector</code>，<code>std::deque</code>，<code>std::string</code>。（<code>std::arra</code>y也不是基于节点的，但是它不支持置入和插入，所以它与这儿无关。）在不是基于节点的容器中，你可以依靠emplace_back来使用构造向容器添加元素，对于<code>std::deque</code>，<code>emplace_front</code>也是一样的。</p></li><li><p>传递的实参类型与容器的初始化类型不同。 再次强调，置入优于插入通常基于以下事实：当传递的实参不是容器保存的类型时，接口不需要创建和销毁临时对象。当将类型为T的对象添加到<code>container&lt;T&gt;</code>时，没有理由期望置入比插入运行的更快，因为不需要创建临时对象来满足插入的接口。</p></li><li><p>容器不拒绝重复项作为新值。 这意味着容器要么允许添加重复值，要么你添加的元素大部分都是不重复的。这样要求的原因是为了判断一个元素是否已经存在于容器中，置入实现通常会创建一个具有新值的节点，以便可以将该节点的值与现有容器中节点的值进行比较。如果要添加的值不在容器中，则链接该节点。然后，如果值已经存在，置入操作取消，创建的节点被销毁，意味着构造和析构时的开销被浪费了。这样的节点更多的是为置入函数而创建，相比起为插入函数来说。</p></li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><ul><li>原则上，置入函数有时会比插入函数高效，并且不会更差。</li><li>实际上，当以下条件满足时，置入函数更快：（1）值被构造到容器中，而不是直接赋值；（2）传入的类型与容器的元素类型不一致；（3）容器不拒绝已经存在的重复值。(非常重要)</li><li>置入函数可能执行插入函数拒绝的类型转换。（注意即可）</li></ul>`,21),c=[t];function o(l,i){return s(),a("div",null,c)}const d=n(p,[["render",o],["__file","effective-modern-cpp-42.html.vue"]]);export{d as default};
