import{_ as s,V as e,W as a,a0 as n}from"./framework-9a29aaa0.js";const d={},t=n(`<h1 id="第十一讲-指令级并行-simd-和流水线" tabindex="-1"><a class="header-anchor" href="#第十一讲-指令级并行-simd-和流水线" aria-hidden="true">#</a> 第十一讲：指令级并行, SIMD 和流水线</h1><p>如果 <code>xmm</code> 寄存器是 128 位宽，但浮点值是 32 或 64 位宽，那么剩下的位是什么？答案是，更多的浮点值！每个 <code>xmm</code> 寄存器都可以被视为打包到单个寄存器中的 4 个单精度或 2 个双精度浮点值的数组。 所有上述操作仅对寄存器中的“低”值进行操作（以数组表示法，<code>xmm[0]</code>）.他们通常只是复制其余元素不变。</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>addps xmm0, xmm1
; 等同于:
;   xmm0[0] += xmm1[0]
;   xmm0[1] += xmm1[1]
;   xmm0[2] += xmm1[2]
;   xmm0[3] += xmm1[3]
; 但是是同时运行的
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这与只执行一次加法的普通 <code>addss</code> 指令占用相同的 CPU 时间。 （第一个 s 代表“标量”，而 p 代表“打包”。）</p><p>这种并行性称为<strong>单指令-多数据</strong> (<strong>S</strong>ingle-<strong>I</strong>nstruction, <strong>M</strong>ultiple-<strong>D</strong>ata), 简称SIMD。我们发出一条指令，但它并行应用于多个操作数。</p><p>需要记住的一件事是，因为这些操作与正常的“解包”浮点操作花费相同的时间，所以即使我们只有一个浮点值要操作，我们也可以使用它们， 只是忽略所有其他结果。有些“打包”操作没有解包的单元素等价物，但即使在非并行代码中，您也应该随意使用它们。</p><p>另一件需要注意的事情是，许多压缩操作需要整数操作数，或者直接对其操作数的位进行操作。一般来说，这些指令对浮点操作数没有意义，除了一种情况：操作符号位。在单精度和双精度浮点值中，符号位始终是最高位。因此，我们可以使用打包的按位 AND/OR/XOR 运算来操作浮点数的符号，而无需求助于乘以 -1 之类的技巧:</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>; This sets up xmm1 so that only the high bit is set
cmpeqd xmm1, xmm1   ; xmm1 == xmm1? True, sets all bits to 1
pslld  xmm1, 31

xorps xmm0, xmm1 ; xmm0 = -xmm0
orps  xmm0, xmm1 ; xmm0 = -abs(xmm0)
pandn xmm0, xmm1 ; xmm0 = abs(xmm0)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>cmpeqd</code> 比较源和目标中的双字元素是否相等；如果比较为真，则每个元素设置为全 1；如果比较为假，则设置为全 0。因此，这将 xmm1 设置为全 1。</li><li><code>pslld</code> 对每个元素执行左移。将每个元素向左移动 31 位，实际上会移动 31 个 0，在最高位位置（符号位的位置）留下 1。</li><li><code>xorps</code> 对每对元素的位执行异或运算。由于 xmm1 中仅设置了符号位，因此这实际上翻转了 xmm0 的符号位。</li><li>orps 对每对元素的位执行 OR 运算，将 xmm0 的符号位设置为 1。</li><li>pandn 对这些位执行 AND-NOT 运算，首先对 xmm1 取反（这样除了符号位为 0 之外，它都是 1），然后与 xmm0 进行 AND 运算，清除符号位，同时保持其他位不变。</li></ul><p>这种东西也可以用来直接在寄存器中“生成”浮点常量，而不是从内存中加载它。</p><h2 id="压缩算术运算" tabindex="-1"><a class="header-anchor" href="#压缩算术运算" aria-hidden="true">#</a> 压缩算术运算</h2><p>最容易理解的压缩 (SIMD) 运算是算术运算；这些进行算术运算（+、-、*、/）并应用</p><p><strong>&quot;垂直&quot;与&quot;水平&quot;操作</strong></p><p>我们可以将打包操作视为“垂直”：我们有很多值，并且我们希望对它们应用相同的操作</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>xmm0<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    xmm0<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    xmm0<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>    xmm0<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>
   +          +          +          +   
   <span class="token operator">=</span>          <span class="token operator">=</span>          <span class="token operator">=</span>          <span class="token operator">=</span>
xmm1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    xmm1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    xmm1<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>    xmm1<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这与对序列元素求和等操作不同，我们可以将其视为“水平”：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>a + b + c + d
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在垂直运算中，没有任何加法依赖于任何其他加法，因此我们可以在一次加法的时间内同时完成所有这些操作。在水平操作中，无论我们如何分解，某些加法都必须等待另一个加法的结果。我们能做的最好的就是</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">(</span>a + b<span class="token punctuation">)</span> + <span class="token punctuation">(</span>c + d<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但即使我们可以与 <code>c + d</code> 同时执行 <code>a + b</code>，外部加法也必须等到这两个操作都完成。横向操作有数据依赖。操作的一部分必须等待另一部分。</p><p>复杂性理论家已经计算出了如果允许无限量的并行性，我们可以预期的加速程度。例如，如果我们有一个可以同时执行无限次加法的 CPU，那么我们可以在恒定时间内执行任意大小的垂直加法，O(1)。但水平添加由于其数据依赖性，仍然会需要一些等待。事实上，即使具有无限并行性，水平、数据相关的操作最多也可以以对数、O(logn) 的方式完成。无论我们有多少并行性，我们永远无法将它们降低到 O(1)。</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>haddps dest, src        ; add dest[0] = src[0]+src[1], dest[1] = src[2]+src[3]
haddpd dest, src
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，为了对所有四个元素求和，我们需要执行两个 haddps 指令。 hadd 和 hsub 是唯一支持的两个水平操作；所有其他打包操作都是垂直的。</p><h3 id="移动打包数据" tabindex="-1"><a class="header-anchor" href="#移动打包数据" aria-hidden="true">#</a> 移动打包数据</h3><p>我们用于浮点的 <code>movss</code>/<code>movsd</code> 指令也可用于打包数据, 源数据的低位元素被复制到目标，而目标的其余元素保持不变。<code>movss</code>仅仅复制低32bit数据，<code>movsd</code>复制低64bit数据。</p><p>最简单的打包 mov 指令是 <code>movups</code>/<code>movupd</code>。这会将 128 位数据从内存移动到 xmm 寄存器，从 xmm 寄存器移动到内存，或者从一个 xmm 寄存器移动到另一个 xmm 寄存器。数据被解释为四个单精度浮点数或两个双精度浮点数。<code>u</code> 代表未对齐；当移入或移出内存时，这些指令不要求目标与 16 字节的倍数对齐。</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>movups dest, src
movupd dest, src
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果您知道内存数据与 16 字节的倍数对齐，则对齐移动会更快：</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>movaps dest, src
movapd dest, src
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果您尝试在未对齐的地址上使用对齐的 <code>movap</code>，您的程序将会崩溃。</p><p>如果需要将单个值加载到 xmm 寄存器的所有元素中，可以使用 vbroadcast：</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>vbroadcastss dest, mem ; load dword from [mem] into all elements of dest
vbroadcastsd dest, mem ; load qword from [mem] into both elements of dest
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="在寄存器内移动" tabindex="-1"><a class="header-anchor" href="#在寄存器内移动" aria-hidden="true">#</a> 在寄存器内移动</h3><p>有许多指令可用于移动寄存器内的打包值。例如，movsldup 指令将源寄存器的偶数元素复制到目标寄存器的偶数和奇数元素中，并复制它们。那是，</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>movsldup xmm0, xmm1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>等价于：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>xmm0<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> xmm0<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> xmm1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
xmm0<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> xmm0<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> xmm1<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>movshdup 执行相同的操作，但使用源的奇数元素。</p><h3 id="压缩算术" tabindex="-1"><a class="header-anchor" href="#压缩算术" aria-hidden="true">#</a> 压缩算术</h3><p>所有正常的浮点运算都有压缩变体：</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>addps dest, src
addpd dest, src
subps dest, src
subpd dest, src
mulps dest, src
mulpd dest, src
divps dest, src
divpd dest, src
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="打包转换" tabindex="-1"><a class="header-anchor" href="#打包转换" aria-hidden="true">#</a> 打包转换</h3><p>所有 cvt 指令都包含等效指令。当与整数进行转换时，它们不是转换为通用寄存器，而是转换为 xmm 寄存器</p><h3 id="打包比较" tabindex="-1"><a class="header-anchor" href="#打包比较" aria-hidden="true">#</a> 打包比较</h3><p>打包比较的工作方式与普通比较完全不同。因为相同的操作必须应用于 xmm 寄存器的所有元素，所以将比较结果写入标志寄存器（哪个结果？）是没有用的，即使有，我们将如何使用这些结果，因为（取决于比较）我们可能需要对寄存器的不同元素执行不同的操作？</p><p>打包比较将布尔（0 或 1）结果生成到另一个 xmm 寄存器中。然后，这些结果可以用作掩码，以避免操作特定元素，或相乘，将某些元素归零等。这扩展了条件移动范例，其中我们有一系列始终执行的指令，但部分指令有条件地激活/停用，取决于数据值。</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>cmpeqps  dest, src           ; ==
cmpltps  dest, src           ; &lt;
cmpleps  dest, src           ; &lt;=
cmpneps  dest, src           ; != 
cmpnltps dest, src           ; &gt;=
cmpnleps dest, src           ; &gt;
cmpordps dest, src           ; True if neither operand is NaN
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果比较结果为真，则将dest对应的元素设置为全1，否则设置为全0。</p><p>（所有这些实际上只是 cmpss 指令的别名，其第三个操作数具有不同的值。）</p><h3 id="打包等价于浮点操作" tabindex="-1"><a class="header-anchor" href="#打包等价于浮点操作" aria-hidden="true">#</a> 打包等价于浮点操作</h3><table><thead><tr><th>操作</th><th>描述</th></tr></thead><tbody><tr><td><code>maxps dest, src</code></td><td><code>dest = max(dest, src)</code></td></tr><tr><td><code>minps dest, src</code></td><td><code> dest = min(dest, src)</code></td></tr><tr><td><code>sqrtps dest, src</code></td><td><code>dest = sqrt(src)</code></td></tr><tr><td><code>rcpps dest, src</code></td><td><code>dest = 1/src</code></td></tr><tr><td><code>rsqrtps dest, src</code></td><td><code>dest = 1 / sqrt(src)</code></td></tr><tr><td><code>roundps dest, src, mode</code></td><td></td></tr><tr><td><code>dpps</code></td><td></td></tr></tbody></table>`,51),i=[t];function c(l,r){return e(),a("div",null,i)}const p=s(d,[["render",c],["__file","Lecture11-instruction-level-parallelism.html.vue"]]);export{p as default};
