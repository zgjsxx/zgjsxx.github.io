import{_ as n,V as s,W as a,a0 as e}from"./framework-c954d91f.js";const i={},o=e(`<h1 id="linux-0-11-文件系统" tabindex="-1"><a class="header-anchor" href="#linux-0-11-文件系统" aria-hidden="true">#</a> Linux-0.11 文件系统</h1><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">buffer_head</span> <span class="token operator">*</span> <span class="token function">getblk</span><span class="token punctuation">(</span><span class="token keyword">int</span> dev<span class="token punctuation">,</span><span class="token keyword">int</span> block<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>作用</strong>:获取高速缓存中指定的缓存块</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token function">bread</span><span class="token punctuation">(</span><span class="token keyword">int</span> dev<span class="token punctuation">,</span><span class="token keyword">int</span> block<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>作用</strong>:从设备上读取一个逻辑块内容到缓存块上</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token function">iget</span><span class="token punctuation">(</span><span class="token keyword">int</span> dev<span class="token punctuation">,</span><span class="token keyword">int</span> nr<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="知道了inode的序号-如何在硬盘上查找到inode块的内容" tabindex="-1"><a class="header-anchor" href="#知道了inode的序号-如何在硬盘上查找到inode块的内容" aria-hidden="true">#</a> 知道了inode的序号，如何在硬盘上查找到inode块的内容？</h2><p>回顾一下minux文件系统的分布， 如下图所示:</p><figure><img src="https://github.com/zgjsxx/static-img-repo/raw/main/blog/Linux/Linux-0.11-fs/minixfs.drawio.png" alt="inode" tabindex="0" loading="lazy"><figcaption>inode</figcaption></figure><figure><img src="https://github.com/zgjsxx/static-img-repo/raw/main/blog/Linux/Linux-0.11-fs/inode_map.drawio.png" alt="inode" tabindex="0" loading="lazy"><figcaption>inode</figcaption></figure><p>其中引导块为一个block，超级块为一个block，inode位图的大小在超级块中定义，逻辑块位图的大小在超级块中定义。 跳过这些块， 就可以来到inode节点块的起点。</p><p>那么inode节点会在哪个block中呢？</p><p>inode节点的序号从0开始， 但是0号是个保留号， 实际存储并不会存0号inode， 因此inode的实际起始位置是1。</p><p>因此序号为n的inode， 在磁盘上的盘块号为:</p><p>block = 1 + 1 + s_imap_blocks + s_zmap_blocks + (n - 1)/每个磁盘块存储的inode数量。</p><p>找到了inode所在的磁盘块， 计算inode在该块中的下标， 则通过</p><p>index = (n - 1) % 每个磁盘块存储的inode数量</p><p>到此， 给定一个inode号，就可以从磁盘上找到对应的inode节点。</p><div class="language-C line-numbers-mode" data-ext="C"><pre class="language-C"><code>if (!(sb=get_super(inode-&gt;i_dev)))
    panic(&quot;trying to read inode without dev&quot;);
block = 2 + sb-&gt;s_imap_blocks + sb-&gt;s_zmap_blocks +
    (inode-&gt;i_num-1)/INODES_PER_BLOCK;
if (!(bh=bread(inode-&gt;i_dev,block)))
    panic(&quot;unable to read i-node block&quot;);
*(struct d_inode *)inode =
    ((struct d_inode *)bh-&gt;b_data)
        [(inode-&gt;i_num-1)%INODES_PER_BLOCK];
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>字节Byte是计算机数据处理的最小单位，习惯上用大写的B表示，每个字节有8个二进制位，其中<strong>最右边</strong>的一位为最低位，<strong>最左边</strong>的一位为最高位，每个二进制位的值不是0就是1。一个字节由8个二进制位组成。也就是1字节Byte等于8比特Bit。这也是计算机设计时规定的。一个字节最大为8个1（11111111）即2的8次方，总共是256种状态。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">m_inode</span> <span class="token operator">*</span> <span class="token function">get_dir</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> pathname<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>绝对路径</p><p>/home/work/test.c</p><p>/ -&gt;找到 /的inode thisname = &quot;home/work/test.c&quot;</p><p>namelen=4</p><p>指定长度的字符串和de-&gt;name做比较</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">match</span><span class="token punctuation">(</span><span class="token keyword">int</span> len<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> name<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">dir_entry</span> <span class="token operator">*</span> de<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>name字符串的前len个字符与de-&gt;name做比较</p><p>m_inode:内存中存取的inode的内容</p><p>d_inode:磁盘中的inode的内容</p><p>sys_open-&gt;open_namei-&gt;</p>`,31),t=[o];function p(d,c){return s(),a("div",null,t)}const r=n(i,[["render",p],["__file","Linux-0.11-fs.html.vue"]]);export{r as default};
