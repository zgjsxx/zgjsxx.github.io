import{_ as n,V as s,W as a,a0 as t}from"./framework-9a29aaa0.js";const p={},o=t(`<h1 id="item37-使std-thread在所有路径最后都不可结合" tabindex="-1"><a class="header-anchor" href="#item37-使std-thread在所有路径最后都不可结合" aria-hidden="true">#</a> Item37：使std::thread在所有路径最后都不可结合</h1><p>每个<code>std::thread</code>对象处于两个状态之一：可结合的（joinable）或者不可结合的（unjoinable）。可结合状态的std::thread对应于正在运行或者可能要运行的异步执行线程。比如，对应于一个阻塞的（blocked）或者等待调度的线程的std::thread是可结合的，对应于运行结束的线程的std::thread也可以认为是可结合的。</p><p>不可结合的<code>std::thread</code>正如所期待：一个不是可结合状态的<code>std::thread</code>。不可结合的<code>std::thread</code>对象包括：</p><p>默认构造的<code>std::threads</code>。这种<code>std::thread</code>没有函数执行，因此没有对应到底层执行线程上。 已经被移动走的<code>std::thread</code>对象。移动的结果就是一个<code>std::thread</code>原来对应的执行线程现在对应于另一个<code>std::thread</code>。 已经被join的<code>std::thread</code> 。在join之后，<code>std::thread</code>不再对应于已经运行完了的执行线程。 已经被detach的<code>std::thread</code> 。detach断开了<code>std::thread</code>对象与执行线程之间的连接。 （译者注：<code>std::thread</code>可以视作状态保存的对象，保存的状态可能也包括可调用对象，有没有具体的线程承载就是有没有连接）</p><p><code>std::thread</code>的可结合性如此重要的原因之一就是当可结合的线程的析构函数被调用，程序执行会终止。比如，假定有一个函数doWork，使用一个过滤函数filter，一个最大值maxVal作为形参。doWork检查是否满足计算所需的条件，然后使用在0到maxVal之间的通过过滤器的所有值进行计算。如果进行过滤非常耗时，并且确定doWork条件是否满足也很耗时，则将两件事并发计算是很合理的。</p><p>我们希望为此采用基于任务的设计（参见Item35），但是假设我们希望设置做过滤的线程的优先级。Item35阐释了那需要线程的原生句柄，只能通过<code>std::thread</code>的API来完成；基于任务的API（比如future）做不到。所以最终采用基于线程而不是基于任务。</p><p>我们可能写出以下代码：</p><p>代码如下：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">constexpr</span> <span class="token keyword">auto</span> tenMillion <span class="token operator">=</span> <span class="token number">10000000</span><span class="token punctuation">;</span>           <span class="token comment">//constexpr见条款15</span>

<span class="token keyword">bool</span> <span class="token function">doWork</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> filter<span class="token punctuation">,</span>    <span class="token comment">//返回计算是否执行；</span>
            <span class="token keyword">int</span> maxVal <span class="token operator">=</span> tenMillion<span class="token punctuation">)</span>            <span class="token comment">//std::function见条款2</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> goodVals<span class="token punctuation">;</span>                  <span class="token comment">//满足filter的值</span>

    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span>filter<span class="token punctuation">,</span> maxVal<span class="token punctuation">,</span> <span class="token operator">&amp;</span>goodVals<span class="token punctuation">]</span>  <span class="token comment">//填充goodVals</span>
                  <span class="token punctuation">{</span>
                      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> maxVal<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
                          <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">filter</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> goodVals<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
                  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">auto</span> nh <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">native_handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//使用t的原生句柄</span>
    …                                           <span class="token comment">//来设置t的优先级</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">conditionsAreSatisfied</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                               <span class="token comment">//等t完成</span>
        <span class="token function">performComputation</span><span class="token punctuation">(</span>goodVals<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                            <span class="token comment">//执行了计算</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                               <span class="token comment">//未执行计算</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在解释这份代码为什么有问题之前，我先把tenMillion的初始化值弄得更可读一些，这利用了C++14的能力，使用单引号作为数字分隔符：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">constexpr</span> <span class="token keyword">auto</span> tenMillion <span class="token operator">=</span> <span class="token number">10&#39;000&#39;000</span><span class="token punctuation">;</span>         <span class="token comment">//C++14</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>还要指出，在开始运行之后设置t的优先级就像把马放出去之后再关上马厩门一样（译者注：太晚了）。更好的设计是在挂起状态时开始t（这样可以在执行任何计算前调整优先级），但是我不想你为考虑那些代码而分心。如果你对代码中忽略的部分感兴趣，可以转到Item39，那个Item告诉你如何以开始那些挂起状态的线程。</p><p>返回doWork。如果conditionsAreSatisfied()返回true，没什么问题，但是如果返回false或者抛出异常，在doWork结束调用t的析构函数时，<code>std::thread</code>对象t会是可结合的。这造成程序执行中止。</p><p>你可能会想，为什么<code>std::thread</code>析构的行为是这样的，那是因为另外两种显而易见的方式更糟：</p><p>隐式join 。这种情况下，<code>std::thread</code>的析构函数将等待其底层的异步执行线程完成。这听起来是合理的，但是可能会导致难以追踪的异常表现。比如，如果<code>conditonAreStatisfied()</code>已经返回了false，doWork继续等待过滤器应用于所有值就很违反直觉。</p><p>隐式detach 。这种情况下，<code>std::thread</code>析构函数会分离<code>std::thread</code>与其底层的线程。底层线程继续运行。听起来比join的方式好，但是可能导致更严重的调试问题。比如，在doWork中，goodVals是通过引用捕获的局部变量。它也被lambda修改（通过调用push_back）。假定，lambda异步执行时，conditionsAreSatisfied()返回false。这时，doWork返回，同时局部变量（包括goodVals）被销毁。栈被弹出，并在doWork的调用点继续执行线程。</p><p>调用点之后的语句有时会进行其他函数调用，并且至少一个这样的调用可能会占用曾经被doWork使用的栈位置。我们调用那么一个函数f。当f运行时，doWork启动的lambda仍在继续异步运行。该lambda可能在栈内存上调用push_back，该内存曾属于goodVals，但是现在是f的栈内存的某个位置。这意味着对f来说，内存被自动修改了！想象一下调试的时候“乐趣”吧。</p><p>标准委员会认为，销毁可结合的线程如此可怕以至于实际上禁止了它（规定销毁可结合的线程导致程序终止）。</p><p>这使你有责任确保使用<code>std::thread</code>对象时，在所有的路径上超出定义所在的作用域时都是不可结合的。但是覆盖每条路径可能很复杂，可能包括自然执行通过作用域，或者通过return，continue，break，goto或异常跳出作用域，有太多可能的路径。</p><p>每当你想在执行跳至块之外的每条路径执行某种操作，最通用的方式就是将该操作放入局部对象的析构函数中。这些对象称为RAII对象（RAII objects），从RAII类中实例化。（RAII全称为 “Resource Acquisition Is Initialization”（资源获得即初始化），尽管技术关键点在析构上而不是实例化上）。RAII类在标准库中很常见。比如STL容器（每个容器析构函数都销毁容器中的内容物并释放内存），标准智能指针（Item18-20解释了，<code>std::uniqu_ptr</code>的析构函数调用他指向的对象的删除器，<code>std::shared_ptr</code>和<code>std::weak_ptr</code>的析构函数递减引用计数），<code>std::fstream</code>对象（它们的析构函数关闭对应的文件）等。但是标准库没有<code>std::thread</code>的RAII类，可能是因为标准委员会拒绝将join和detach作为默认选项，不知道应该怎么样完成RAII。</p><p>幸运的是，完成自行实现的类并不难。比如，下面的类实现允许调用者指定ThreadRAII对象（一个std::thread的RAII对象）析构时，调用join或者detach：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">ThreadRAII</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">DtorAction</span> <span class="token punctuation">{</span> join<span class="token punctuation">,</span> detach <span class="token punctuation">}</span><span class="token punctuation">;</span>     <span class="token comment">//enum class的信息见条款10</span>
    
    <span class="token function">ThreadRAII</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">,</span> DtorAction a<span class="token punctuation">)</span>   <span class="token comment">//析构函数中对t实行a动作</span>
    <span class="token operator">:</span> <span class="token function">action</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">t</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token operator">~</span><span class="token function">ThreadRAII</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>                                           <span class="token comment">//可结合性测试见下</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>action <span class="token operator">==</span> DtorAction<span class="token double-colon punctuation">::</span>join<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                t<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&amp;</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> t<span class="token punctuation">;</span> <span class="token punctuation">}</span>            <span class="token comment">//见下</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    DtorAction action<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread t<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我希望这段代码是不言自明的，但是下面几点说明可能会有所帮助：</p><p>构造器只接受<code>std::thread</code>右值，因为我们想要把传来的<code>std::thread</code>对象移动进ThreadRAII。（<code>std::thread</code>不可以复制。）</p><p>构造器的形参顺序设计的符合调用者直觉（首先传递<code>std::thread</code>，然后选择析构执行的动作，这比反过来更合理），但是成员初始化列表设计的匹配成员声明的顺序。将<code>std::thread</code>对象放在声明最后。在这个类中，这个顺序没什么特别之处，但是通常，可能一个数据成员的初始化依赖于另一个，因为<code>std::thread</code>对象可能会在初始化结束后就立即执行函数了，所以在最后声明是一个好习惯。这样就能保证一旦构造结束，在前面的所有数据成员都初始化完毕，可以供<code>std::thread</code>数据成员绑定的异步运行的线程安全使用。</p><p>ThreadRAII提供了get函数访问内部的<code>std::thread</code>对象。这类似于标准智能指针提供的get函数，可以提供访问原始指针的入口。提供get函数避免了ThreadRAII复制完整<code>std::thread</code>接口的需要，也意味着ThreadRAII可以在需要<code>std::thread</code>对象的上下文环境中使用。</p><p>在ThreadRAII析构函数调用<code>std::thread</code>对象t的成员函数之前，检查t是否可结合。这是必须的，因为在不可结合的<code>std::thread</code>上调用join或detach会导致未定义行为。客户端可能会构造一个<code>std::thread</code>，然后用它构造一个ThreadRAII，使用get获取t，然后移动t，或者调用join或detach，每一个操作都使得t变为不可结合的。</p><p>如果你担心下面这段代码</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>action <span class="token operator">==</span> DtorAction<span class="token double-colon punctuation">::</span>join<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        t<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>存在竞争，因为在t.joinable()的执行和调用join或detach的中间，可能有其他线程改变了t为不可结合，你的直觉值得表扬，但是这个担心不必要。只有调用成员函数才能使<code>std::thread</code>对象从可结合变为不可结合状态，比如join，detach或者移动操作。在ThreadRAII对象析构函数调用时，应当没有其他线程在那个对象上调用成员函数。如果同时进行调用，那肯定是有竞争的，但是不在析构函数中，是在客户端代码中试图同时在一个对象上调用两个成员函数（析构函数和其他函数）。通常，仅当所有都为const成员函数时，在一个对象同时调用多个成员函数才是安全的。</p><p>在doWork的例子上使用ThreadRAII的代码如下：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">bool</span> <span class="token function">doWork</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> filter<span class="token punctuation">,</span>        <span class="token comment">//同之前一样</span>
            <span class="token keyword">int</span> maxVal <span class="token operator">=</span> tenMillion<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> goodVals<span class="token punctuation">;</span>                      <span class="token comment">//同之前一样</span>

    ThreadRAII <span class="token function">t</span><span class="token punctuation">(</span>                                   <span class="token comment">//使用RAII对象</span>
        std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span>filter<span class="token punctuation">,</span> maxVal<span class="token punctuation">,</span> <span class="token operator">&amp;</span>goodVals<span class="token punctuation">]</span>
                    <span class="token punctuation">{</span>
                        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> maxVal<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
                            <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">filter</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> goodVals<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    ThreadRAII<span class="token double-colon punctuation">::</span>DtorAction<span class="token double-colon punctuation">::</span>join    <span class="token comment">//RAII动作</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">auto</span> nh <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">native_handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    …

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">conditionsAreSatisfied</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        t<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">performComputation</span><span class="token punctuation">(</span>goodVals<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种情况下，我们选择在ThreadRAII的析构函数对异步执行的线程进行join，因为在先前分析中，detach可能导致噩梦般的调试过程。我们之前也分析了join可能会导致表现异常（坦率说，也可能调试困难），但是在未定义行为（detach导致），程序终止（使用原生<code>std::thread</code>导致），或者表现异常之间选择一个后果，可能表现异常是最好的那个。</p><p>哎，Item39表明了使用ThreadRAII来保证在<code>std::thread</code>的析构时执行join有时不仅可能导致程序表现异常，还可能导致程序挂起。“适当”的解决方案是此类程序应该和异步执行的lambda通信，告诉它不需要执行了，可以直接返回，但是C++11中不支持可中断线程（interruptible threads）。可以自行实现，但是这不是本书讨论的主题。（关于这一点，Anthony Williams的《C++ Concurrency in Action》（Manning Publications，2012）的section 9.2中有详细讨论。）（译者注：此书中文版已出版，名为《C++并发编程实战》，且本文翻译时（2020）已有第二版出版。）</p><p>Item17说明因为ThreadRAII声明了一个析构函数，因此不会有编译器生成移动操作，但是没有理由ThreadRAII对象不能移动。如果要求编译器生成这些函数，函数的功能也正确，所以显式声明来告诉编译器自动生成也是合适的：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">ThreadRAII</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">DtorAction</span> <span class="token punctuation">{</span> join<span class="token punctuation">,</span> detach <span class="token punctuation">}</span><span class="token punctuation">;</span>         <span class="token comment">//跟之前一样</span>

    <span class="token function">ThreadRAII</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">,</span> DtorAction a<span class="token punctuation">)</span>       <span class="token comment">//跟之前一样</span>
    <span class="token operator">:</span> <span class="token function">action</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">t</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token operator">~</span><span class="token function">ThreadRAII</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        …                                           <span class="token comment">//跟之前一样</span>
    <span class="token punctuation">}</span>

    <span class="token function">ThreadRAII</span><span class="token punctuation">(</span>ThreadRAII<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>             <span class="token comment">//支持移动</span>
    ThreadRAII<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>ThreadRAII<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&amp;</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> t<span class="token punctuation">;</span> <span class="token punctuation">}</span>                <span class="token comment">//跟之前一样</span>

<span class="token keyword">private</span><span class="token operator">:</span> <span class="token comment">// as before</span>
    DtorAction action<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread t<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><ul><li>在所有路径上保证thread最终是不可结合的。</li><li>析构时join会导致难以调试的表现异常问题。</li><li>析构时detach会导致难以调试的未定义行为。</li><li>声明类数据成员时，最后声明std::thread对象。</li></ul>`,38),e=[o];function c(l,i){return s(),a("div",null,e)}const d=n(p,[["render",c],["__file","effective-modern-cpp-37.html.vue"]]);export{d as default};
