const e=JSON.parse('{"key":"v-bf0b1b8a","path":"/posts/Linux/application-dev/Linux-cpu-cache-mesi.html","title":"CPU缓存一致性原理","lang":"zh-CN","frontmatter":{"category":["Linux"],"description":"CPU缓存一致性原理 在本站的文章CPU缓存那些事儿中， 介绍了cpu的多级缓存的架构和cpu缓存行cache line的结构。CPU对于缓存的操作包含读和写，读操作在cacheline中有所涉及，在本文中，将重点讨论CPU对于缓存进行写时的行为。 单核CPU对高速缓存的读操作 CPU对于高速缓存的读操作的过程在之前的文章中有提到过，这里梳理一下其流程： 1.首先对于一个内存地址，CPU会按照索引规则（直接映射/多路组相连/全相连）优先去cache line中进行检索。 2.如果检索到了，意味着该内存地址的内容已经存在于cache中，则直接读取内容到CPU中，流程结束。如果没有检索到，进行步骤3。 3.此时确认内存的数据不在cache line中，如果cache已经存满或者已经被其他内存地址映射，则进入步骤4，如果cache line中还有空位，则进入步骤5. 4.执行缓存淘汰策略，腾出位置 5.加载内存数据到cache line中，将cache块上的内容读取到cpu中。","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/Linux/application-dev/Linux-cpu-cache-mesi.html"}],["meta",{"property":"og:site_name","content":"Code Building"}],["meta",{"property":"og:title","content":"CPU缓存一致性原理"}],["meta",{"property":"og:description","content":"CPU缓存一致性原理 在本站的文章CPU缓存那些事儿中， 介绍了cpu的多级缓存的架构和cpu缓存行cache line的结构。CPU对于缓存的操作包含读和写，读操作在cacheline中有所涉及，在本文中，将重点讨论CPU对于缓存进行写时的行为。 单核CPU对高速缓存的读操作 CPU对于高速缓存的读操作的过程在之前的文章中有提到过，这里梳理一下其流程： 1.首先对于一个内存地址，CPU会按照索引规则（直接映射/多路组相连/全相连）优先去cache line中进行检索。 2.如果检索到了，意味着该内存地址的内容已经存在于cache中，则直接读取内容到CPU中，流程结束。如果没有检索到，进行步骤3。 3.此时确认内存的数据不在cache line中，如果cache已经存满或者已经被其他内存地址映射，则进入步骤4，如果cache line中还有空位，则进入步骤5. 4.执行缓存淘汰策略，腾出位置 5.加载内存数据到cache line中，将cache块上的内容读取到cpu中。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-08-20T08:57:21.000Z"}],["meta",{"property":"article:modified_time","content":"2023-08-20T08:57:21.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"CPU缓存一致性原理\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-08-20T08:57:21.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"单核CPU对高速缓存的读操作","slug":"单核cpu对高速缓存的读操作","link":"#单核cpu对高速缓存的读操作","children":[]},{"level":2,"title":"单核CPU对于高速缓存的写操作","slug":"单核cpu对于高速缓存的写操作","link":"#单核cpu对于高速缓存的写操作","children":[{"level":3,"title":"写直达策略(Write-Through)","slug":"写直达策略-write-through","link":"#写直达策略-write-through","children":[]},{"level":3,"title":"写回策略(Write-Back)","slug":"写回策略-write-back","link":"#写回策略-write-back","children":[]},{"level":3,"title":"多CPU核的缓存一致性问题。","slug":"多cpu核的缓存一致性问题。","link":"#多cpu核的缓存一致性问题。","children":[]},{"level":3,"title":"写缓冲区和失效队列","slug":"写缓冲区和失效队列","link":"#写缓冲区和失效队列","children":[]}]},{"level":2,"title":"参考文献","slug":"参考文献","link":"#参考文献","children":[]}],"git":{"createdTime":1688367205000,"updatedTime":1692521841000,"contributors":[{"name":"zgjsxx","email":"119160524@qq.com","commits":21}]},"readingTime":{"minutes":10.61,"words":3182},"filePathRelative":"posts/Linux/application-dev/Linux-cpu-cache-mesi.md","localizedDate":"2023年7月3日","excerpt":"<h1> CPU缓存一致性原理</h1>\\n<p>在本站的文章<strong>CPU缓存那些事儿</strong>中， 介绍了cpu的多级缓存的架构和cpu缓存行cache line的结构。CPU对于缓存的操作包含读和写，读操作在cacheline中有所涉及，在本文中，将重点讨论CPU对于缓存进行写时的行为。</p>\\n<h2> 单核CPU对高速缓存的读操作</h2>\\n<p>CPU对于高速缓存的读操作的过程在之前的文章中有提到过，这里梳理一下其流程：</p>\\n<ul>\\n<li>1.首先对于一个内存地址，CPU会按照索引规则（直接映射/多路组相连/全相连）优先去cache line中进行检索。</li>\\n<li>2.如果检索到了，意味着该内存地址的内容已经存在于cache中，则直接读取内容到CPU中，流程结束。如果没有检索到，进行步骤3。</li>\\n<li>3.此时确认内存的数据不在cache line中，如果cache已经存满或者已经被其他内存地址映射，则进入步骤4，如果cache line中还有空位，则进入步骤5.</li>\\n<li>4.执行缓存淘汰策略，腾出位置</li>\\n<li>5.加载内存数据到cache line中，将cache块上的内容读取到cpu中。</li>\\n</ul>","autoDesc":true}');export{e as data};
