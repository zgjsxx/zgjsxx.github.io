const e=JSON.parse('{"key":"v-0c54f870","path":"/posts/Program_language/Assembly_language/fullerton_CSci241/Lecture19-macros.html","title":"第十九讲： 宏定义","lang":"zh-CN","frontmatter":{"category":["汇编语言"],"description":"第十九讲： 宏定义 就像 C/C++ 一样，YASM 有一个预处理器，它在实际进行汇编之前对汇编程序的文本进行操作。因为它在汇编时运行，所以它实际上可以是比汇编本身更丰富的“语言”。另一方面，因为它在汇编时运行，所以它不能引用任何运行时信息（寄存器或内存的内容）。基于文本的宏定义语言实际上在计算机科学中相当常见，因此值得深入了解至少一种（如果您还没有研究过 C/C++ 预处理器）。 错误 我们可以使用 %error 宏停止汇编并打印消息： %error Something went wrong.","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/Program_language/Assembly_language/fullerton_CSci241/Lecture19-macros.html"}],["meta",{"property":"og:site_name","content":"Code Building"}],["meta",{"property":"og:title","content":"第十九讲： 宏定义"}],["meta",{"property":"og:description","content":"第十九讲： 宏定义 就像 C/C++ 一样，YASM 有一个预处理器，它在实际进行汇编之前对汇编程序的文本进行操作。因为它在汇编时运行，所以它实际上可以是比汇编本身更丰富的“语言”。另一方面，因为它在汇编时运行，所以它不能引用任何运行时信息（寄存器或内存的内容）。基于文本的宏定义语言实际上在计算机科学中相当常见，因此值得深入了解至少一种（如果您还没有研究过 C/C++ 预处理器）。 错误 我们可以使用 %error 宏停止汇编并打印消息： %error Something went wrong."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-13T02:42:53.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-13T02:42:53.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"第十九讲： 宏定义\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-03-13T02:42:53.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"错误","slug":"错误","link":"#错误","children":[]},{"level":2,"title":"包含文件","slug":"包含文件","link":"#包含文件","children":[]},{"level":2,"title":"单行宏","slug":"单行宏","link":"#单行宏","children":[]},{"level":2,"title":"函数式宏","slug":"函数式宏","link":"#函数式宏","children":[]},{"level":2,"title":"区分大小写","slug":"区分大小写","link":"#区分大小写","children":[]},{"level":2,"title":"连接宏扩展","slug":"连接宏扩展","link":"#连接宏扩展","children":[]},{"level":2,"title":"算术扩展宏","slug":"算术扩展宏","link":"#算术扩展宏","children":[]},{"level":2,"title":"字符串处理","slug":"字符串处理","link":"#字符串处理","children":[]},{"level":2,"title":"多行宏","slug":"多行宏","link":"#多行宏","children":[]},{"level":2,"title":"其余参数","slug":"其余参数","link":"#其余参数","children":[]},{"level":2,"title":"默认参数","slug":"默认参数","link":"#默认参数","children":[]},{"level":2,"title":"旋转参数列表","slug":"旋转参数列表","link":"#旋转参数列表","children":[]},{"level":2,"title":"宏局部名称","slug":"宏局部名称","link":"#宏局部名称","children":[]},{"level":2,"title":"串联多行参数","slug":"串联多行参数","link":"#串联多行参数","children":[]},{"level":2,"title":"条件码参数","slug":"条件码参数","link":"#条件码参数","children":[]},{"level":2,"title":"条件宏","slug":"条件宏","link":"#条件宏","children":[]},{"level":2,"title":"def – 检查单行宏的定义","slug":"def-–-检查单行宏的定义","link":"#def-–-检查单行宏的定义","children":[]},{"level":2,"title":"检查多行定义的宏","slug":"检查多行定义的宏","link":"#检查多行定义的宏","children":[]},{"level":2,"title":"数值表达式","slug":"数值表达式","link":"#数值表达式","children":[]},{"level":2,"title":"idn – 文本比较","slug":"idn-–-文本比较","link":"#idn-–-文本比较","children":[]},{"level":2,"title":"重复宏","slug":"重复宏","link":"#重复宏","children":[]},{"level":2,"title":"上下文堆栈","slug":"上下文堆栈","link":"#上下文堆栈","children":[]},{"level":2,"title":"上下文本地标签","slug":"上下文本地标签","link":"#上下文本地标签","children":[]},{"level":2,"title":"示例：块 IF 语句","slug":"示例-块-if-语句","link":"#示例-块-if-语句","children":[]}],"git":{"createdTime":1709629879000,"updatedTime":1710297773000,"contributors":[{"name":"zgjsxx","email":"119160524@qq.com","commits":3}]},"readingTime":{"minutes":14.13,"words":4240},"filePathRelative":"posts/Program_language/Assembly_language/fullerton_CSci241/Lecture19-macros.md","localizedDate":"2024年3月5日","excerpt":"<h1> 第十九讲： 宏定义</h1>\\n<p>就像 C/C++ 一样，YASM 有一个预处理器，它在实际进行汇编之前对汇编程序的文本进行操作。因为它在汇编时运行，所以它实际上可以是比汇编本身更丰富的“语言”。另一方面，因为它在汇编时运行，所以它不能引用任何运行时信息（寄存器或内存的内容）。基于文本的宏定义语言实际上在计算机科学中相当常见，因此值得深入了解至少一种（如果您还没有研究过 C/C++ 预处理器）。</p>\\n<h2> 错误</h2>\\n<p>我们可以使用 <code>%error</code> 宏停止汇编并打印消息：</p>\\n<div class=\\"language-x86asm line-numbers-mode\\" data-ext=\\"x86asm\\"><pre class=\\"language-x86asm\\"><code>%error Something went wrong.\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{e as data};
