import{_ as i,V as c,W as s,X as e,Y as d,$ as o,a0 as a,F as n}from"./framework-9a29aaa0.js";const r={},t=a(`<ul><li><a href="#%E7%AC%AC%E5%8D%81%E4%B8%83%E8%AE%B2z80%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%BB%BB%E5%A4%A9%E5%A0%82%E6%B8%B8%E6%88%8F%E6%9C%BA%E5%92%8C%E5%BE%B7%E5%B7%9E%E4%BB%AA%E5%99%A8%E8%AE%A1%E7%AE%97%E5%99%A8">第十七讲：Z80汇编语言(任天堂游戏机和德州仪器计算器)</a><ul><li><a href="#z80">Z80</a><ul><li><a href="#%E5%AF%84%E5%AD%98%E5%99%A8">寄存器</a></li><li><a href="#%E6%8C%87%E4%BB%A4%E9%9B%86">指令集</a></li><li><a href="#%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC">条件跳转</a></li><li><a href="#%E5%87%BD%E6%95%B0">函数</a></li><li><a href="#%E5%9D%97%E4%BC%A0%E8%BE%93">块传输</a></li></ul></li><li><a href="#rgbds-%E6%B1%87%E7%BC%96%E5%99%A8%E5%B7%A5%E5%85%B7">RGBDS 汇编器工具</a></li><li><a href="#gameboy%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%9A%84helloworld%E7%A8%8B%E5%BA%8F">GameBoy模拟器的HelloWorld程序</a></li><li><a href="#ti-83-%E5%9B%BE%E5%BD%A2%E8%AE%A1%E7%AE%97%E5%99%A8%E6%A8%A1%E6%8B%9F%E5%99%A8%E4%B8%8A%E7%9A%84-hello-world">TI-83 图形计算器模拟器上的 Hello World</a></li><li><a href="#%E9%99%84%E5%BD%95">附录</a></li></ul></li></ul><h1 id="第十七讲-z80汇编语言-任天堂游戏机和德州仪器计算器" tabindex="-1"><a class="header-anchor" href="#第十七讲-z80汇编语言-任天堂游戏机和德州仪器计算器" aria-hidden="true">#</a> 第十七讲：Z80汇编语言(任天堂游戏机和德州仪器计算器)</h1><p>本节我们将学习另外一个系列的CPU，Z80。Z80 CPU起源于8080CPU， 8080CPU是现在Intel CPU的鼻祖。</p><p>Z80 CPU最著名的用途就是任天堂Gameboy和TI图形计算器。 Z80的目的是与Intel 8080二进制兼容，即操作码相同。这意味着为Intel 8080编写的软件可以在Z80上运行而无需重新编译），但由于版权问题，寄存器和指令名称不同。</p><h2 id="z80" tabindex="-1"><a class="header-anchor" href="#z80" aria-hidden="true">#</a> Z80</h2><h3 id="寄存器" tabindex="-1"><a class="header-anchor" href="#寄存器" aria-hidden="true">#</a> 寄存器</h3><p>Z80 有 8 个或 5 个通用寄存器，具体取决于您如何看待事物：</p><ul><li>寄存器 <code>A</code>、<code>F</code>、<code>B</code>、<code>C</code>、<code>D</code>、<code>E</code>、<code>H</code> 和 <code>L</code> 可以单独用作 8 位寄存器</li><li>寄存器对<code>BC</code>、<code>DE</code>和<code>HL</code>可用作16位寄存器，其中<code>B</code>是 <code>BC</code> 的高字节，而 <code>C</code> 是低字节。</li><li>有点奇怪的是，<code>A</code> 寄存器可以与标志寄存器 <code>F</code> 组合起来作为 16 位寄存器 <code>AF</code>。</li><li>寄存器 <code>IX</code> 和 <code>IY</code> 是 16 位索引寄存器，与内存操作数一起使用。 <code>HL</code> 类似地用于内存操作数。</li></ul><p>与 <code>x86</code> 一样，<code>SP</code> 寄存器指向堆栈顶部，<code>PC</code> 寄存器指向当前指令（请注意，这与 x86 的 IP 寄存器指向下一条指令不同）。<code>F</code>寄存器包含标志：符号、零、奇偶校验/溢出、满进位。<code>A</code> 和 <code>F</code> 寄存器可以通过几条指令组合成一个 16 位寄存器 <code>AF</code>。</p><p>Z80有一个中断向量寄存器I，其中包含中断向量表的地址，这个设计很有先见之明；在这个时代的Intel CPU中，中断向量的地址是固定在内存中的。</p><p>与 x86 不同，Z80 有一组影子寄存器；这是一组附加寄存器 <code>A&#39;</code>、<code>F&#39;</code>、<code>B&#39;</code>、<code>C&#39;</code>、<code>D&#39;</code>、<code>E&#39;</code>、<code>H&#39;</code> 和 <code>L&#39;</code>。</p><p>您无法直接访问这些寄存器，但可以使用一条指令交换主寄存器组和影子寄存器组。</p><p>这提供了一种简单但有限的方法来保存所有寄存器的值，然后在以后恢复它们（但是，与堆栈不同，您只能保存一组寄存器值）。</p><h3 id="指令集" tabindex="-1"><a class="header-anchor" href="#指令集" aria-hidden="true">#</a> 指令集</h3><p>大多数 Z80 汇编器使用的语法更像 AT&amp;T 语法而不是 Intel 语法。这意味着指令具有以下形式</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>   INSTRUCTION DESTINATION, SOURCE
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>内存的操作写在括号中。</p>`,17),h={href:"https://www.ticalc.org/pub/text/z80/z80_reference.txt",target:"_blank",rel:"noopener noreferrer"},p=a(`<p><code>mov</code> 已重命名为 <code>ld</code>（&quot;加载&quot;），但它可用于将值写入寄存器或内存。例如:</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>    ld  a, 5             ; Set register A = 5
    ld  b, 7             ; Set register B = 7
    add a, b             ; Set A = A + B
    ld [Output], a       ; Write A into address Output
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（一些 Z80 汇编器将内存操作数写在括号 () 中，而其他汇编器（例如我们将要使用的汇编器）则使用更熟悉的 [])。</p><p><code>add</code> 指令只能使用 <code>a</code>、<code>hl</code>、<code>ix</code> 或 <code>iy</code> 作为其目标。内存操作数可以使用立即地址，或者您可以执行类似的操作</p><div class="language-X86asm line-numbers-mode" data-ext="X86asm"><pre class="language-X86asm"><code>ld [hl], a ; Write A into the address contained in HL
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果要在内存操作数中使用立即地址加寄存器，则寄存器必须是 <code>IX</code> 或 <code>IY</code>：</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>ld [Array + ix], a   ; Write A into Array[ix]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>与 x86 一样，<code>ld</code> 的两个操作数必须具有相同的大小：均为 8 位或均为 16 位。根据需要，立即操作数将提升为 16 位。</p><p>Z80 指令的大小为 1 到 3 个字节。</p><h3 id="条件跳转" tabindex="-1"><a class="header-anchor" href="#条件跳转" aria-hidden="true">#</a> 条件跳转</h3><p>有两种条件跳转指令：</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>    jp CC, Target           ; 条件绝对跳转

    jr CC, Target           ; 条件相对跳转
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中 CC 是条件代码。两者的主要区别是<code>jp</code>更灵活（可以使用更多条件，速度更快），而<code>jr</code>更有限（条件更少，速度更慢，只能在程序内跳转±128字节）但只占用2个字节程序而不是 <code>jp</code> 的 3 个字节。</p><p>更专门的条件跳转指令是 <code>djnz</code>，类似于 x86 中的<code>loop</code>，它代表&quot;递减，如果非零则跳转&quot;</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code> djnz Target          ; Decrement B, jump to Target if B ≠ 0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="函数" tabindex="-1"><a class="header-anchor" href="#函数" aria-hidden="true">#</a> 函数</h3><p><code>call</code>与 x86 一样，用于调用函数，它压入 <code>PC+3</code>，然后跳转到函数地址。 （请记住，<code>PC</code> 包含当前指令的地址；即 <code>call</code> 指令本身。<code>call</code> 指令占用 3 个字节，因此下一条指令是 <code>PC+3</code>。）类似地，<code>ret</code> 通过弹出 <code>PC</code> 和跳向它。</p><p>与 x86 不同，Z80 有条件返回指令：</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>ret p               ; Return if positive (sign flag = 0)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可用条件有 C/NC（进位设置/未设置）、M/P（符号 = 1/0）、Z/NZ（零 = 1/0）、PE/PO（奇偶校验 = 1/2）。这些与条件跳转指令 jp CC 所使用的条件相同.</p><p><code>push</code> 和 <code>pop</code> 可用于将寄存器压入堆栈或从堆栈中弹出。只有16位寄存器可以压入/弹出，所以如果你想压入A，你必须结合标志寄存器来压入它：</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code> push af
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="块传输" tabindex="-1"><a class="header-anchor" href="#块传输" aria-hidden="true">#</a> 块传输</h3><p>Intel的处理还没有字符串的指令，也没有字符串重复前缀。但Z80在器块传输操作码中确实有这些指令的最小形式。这些允许将数据块从 I/O 端口或内存复制到 I/O 端口或内存（允许内存到内存传输）。</p><p>块传输函数使用 HL 作为要读/写的内存地址，使用 B 作为计数。 INI 指令（输入和增量）从给定的 I/O 端口读取 16 位，将其复制到 HL 指向的地址，递增 HL，并递减 B。所有块传输指令都遵循以下模式：</p><h2 id="rgbds-汇编器工具" tabindex="-1"><a class="header-anchor" href="#rgbds-汇编器工具" aria-hidden="true">#</a> RGBDS 汇编器工具</h2>`,26),u={href:"https://github.com/gbdev/rgbds",target:"_blank",rel:"noopener noreferrer"},m=e("p",null,"虽然架构不同，但 RGBASM 支持的汇编语法与我们熟悉的 YASM/Intel 语法非常相似。主要区别是：",-1),b=a(`<li>十六进制值以<code>$</code>开头，而不是<code>0x</code></li><li>二进制值以<code>％</code>开头，而不是<code>0b</code></li><li>GameBoy图形化可以直接使用符号嵌入<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>\`0123
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>由于GameBoy上的每个像素都可以是四种灰度之一，因此使用值0到3。每个值都被编码为位对 (00, 01, 10, 11)，然后打包成一个字节。因此，上面对应于字节<code>%00011011</code>或<code>$0f55</code>。</li><li>与YASM一样，RGBASM允许对涉及常量和算术运算符的表达式进行汇编时计算。</li><li><code>SECTION</code>伪指令存在，但唯一有效的部分是<code>ROM0</code>（盒式 ROM 组 0）和 ROMx（盒式 ROM 组 x）。如果您需要更多控制，SECTION 指令支持用于指定节地址的附加选项。</li><li>与 YASM 中一样，标签从行首开始，以 : 结束。局部标签以 . 开头。标签必须以一行的第一个字符开始。</li><li>由于标签必须从一行的第一列开始，因此指令必须缩进至少一个空格或制表符。</li><li>与 YASM 中一样，equ 可用于定义常量。但是，符号名称后面不能跟 : （在 YASM 中， : 是可选的）：<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>Addr       equ         0xff40
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li>Z80 汇编传统上在 () 中写入内存操作数，而 RGBASM 使用 Intel 风格的 []。</li>`,9),v=a(`<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>ldi     <span class="token punctuation">[</span>hl<span class="token punctuation">]</span>, <span class="token number">0</span>            <span class="token punctuation">;</span> Write <span class="token number">0</span> into address hl, increment hl
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,1),E=e("div",{class:"language-text line-numbers-mode","data-ext":"text"},[e("pre",{class:"language-text"},[e("code",null,`ld      [hli], 0           ; Write 0 into address hl, increment hl
`)]),e("div",{class:"line-numbers","aria-hidden":"true"},[e("div",{class:"line-number"})])],-1),g={href:"https://rgbds.gbdev.io/docs/v0.4.1/rgbasm.5",target:"_blank",rel:"noopener noreferrer"},A=a(`<h2 id="gameboy模拟器的helloworld程序" tabindex="-1"><a class="header-anchor" href="#gameboy模拟器的helloworld程序" aria-hidden="true">#</a> GameBoy模拟器的HelloWorld程序</h2><p>GameBoy 硬件缺乏任何类型的文本输出到屏幕，因此我们实际上无法打印“Hello, world!”。此外，它甚至不允许直接访问屏幕上的各个像素；相反，它使用平铺屏幕模式：屏幕分为多个图块，每个图块为 8x8 像素。图块集存储在内存中，屏幕上的每个图块都映射到该集合中的一个图块。这比存储屏幕的整个（像素）内容节省了大量的内存：</p><p>160 × 144 × 2 = 46080 bits = 5760 bytes</p><p>(160/8) × (14‌4/8) × 8 = 2880 bits = 360 bytes</p><h2 id="ti-83-图形计算器模拟器上的-hello-world" tabindex="-1"><a class="header-anchor" href="#ti-83-图形计算器模拟器上的-hello-world" aria-hidden="true">#</a> TI-83 图形计算器模拟器上的 Hello World</h2><p>许多 TI 图形计算器运行 Z80 处理器，因此我们可以为它们编写 Z80 程序集。与 GameBoy 不同，TI 计算器运行的是原厂Z80，没有任何修改。</p><p>我们将使用 Pasmo 汇编器和 Oysterpac 工具将原始二进制数据“打包”到 TI 计算器可执行文件中。两步过程只是首先将我们的源代码组装成二进制文件：</p><pre><code>pasmo file.asm file.bin
</code></pre><p>然后在其上运行 Oysterpac 以生成打包的可执行文件： oysterpac file.bin file.83p</p><h2 id="附录" tabindex="-1"><a class="header-anchor" href="#附录" aria-hidden="true">#</a> 附录</h2><p>原文链接：</p>`,11),B={href:"https://staffwww.fullcoll.edu/aclifton/cs241/lecture-z80-assembly.html",target:"_blank",rel:"noopener noreferrer"};function x(f,C){const l=n("ExternalLinkIcon");return c(),s("div",null,[t,e("p",null,[d("你可以在这里查找到完整的Z80指令集： "),e("a",h,[d("Z80指令集"),o(l)])]),p,e("p",null,[d("我们将使用"),e("a",u,[d("RGBDS"),o(l)]),d(" 工具来为GameBoy汇编代码。")]),m,e("ul",null,[b,e("li",null,[d("对于 ldi 系列指令（加载和增量），RGBASM 支持两种语法。通常的方式："),v,d("和替代语法"),E,d("您可以在"),e("a",g,[d("此处"),o(l)]),d("找到有关 RGBASM 语法的完整文档")])]),A,e("p",null,[e("a",B,[d("https://staffwww.fullcoll.edu/aclifton/cs241/lecture-z80-assembly.html"),o(l)])])])}const I=i(r,[["render",x],["__file","Lecture17-assembly-on-the-Z80.html.vue"]]);export{I as default};
