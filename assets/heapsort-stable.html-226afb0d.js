import{_ as t,V as a,W as e,a0 as i}from"./framework-9a29aaa0.js";const r={},o=i('<h1 id="堆排序算法及其稳定性分析" tabindex="-1"><a class="header-anchor" href="#堆排序算法及其稳定性分析" aria-hidden="true">#</a> 堆排序算法及其稳定性分析？</h1><h2 id="什么是堆排序" tabindex="-1"><a class="header-anchor" href="#什么是堆排序" aria-hidden="true">#</a> 什么是堆排序？</h2><p>堆排序是利用数据结构堆而设计的一种排序算法。</p><p>堆分为两种，<strong>大顶堆</strong>和<strong>小顶堆</strong>。</p><p>所谓大顶堆就是每个节点的值都大于或者等于其左右孩子节点的值。</p><p>小顶堆则是相反的，每个节点的值都小于或者等于其左右孩子节点的值。</p><p>下面是一个大顶堆的示例，其拥有下面的性质:</p><p><code>arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</code></p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort1.png" alt="heapsort1" tabindex="0" loading="lazy"><figcaption>heapsort1</figcaption></figure><p>下面是一个小顶堆的实例，其拥有下面的性质：</p><p><code>arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</code></p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort2.png" alt="heapsort2" tabindex="0" loading="lazy"><figcaption>heapsort2</figcaption></figure><p>大顶堆和小顶堆数据结构是堆排序的基础，下面就看堆排序是如何利用堆来进行排序的。</p><p>堆排序的步骤如下：</p><ul><li>1.将原始数组转换成一个大顶堆(如果要求升序)或者小顶堆(如果要求降序)。</li><li>2.将大顶堆或者小顶堆的首元素与最后一个元素交换</li><li>3.剔除尾部元素，将剩下的元素重新构成一个大顶堆或者小顶堆，重复2。</li></ul><p>以一个例子来看一下上述过程是怎样的。</p><p>原始数组<code>arr = [3,1,4,5,2]</code>， 对其进行升序。</p><p>步骤1：首先将原数组构建成一个大顶堆。首先从叶子节点开始，将1和5进行对调。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort-demo1.png" alt="heapsort-demo" tabindex="0" loading="lazy"><figcaption>heapsort-demo</figcaption></figure><p>步骤2：继续进行调整，将5和3进行对调，此时已经成为了一个大顶堆。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort-demo2.png" alt="heapsort-demo" tabindex="0" loading="lazy"><figcaption>heapsort-demo</figcaption></figure><p>步骤3：将堆顶元素和尾部元素进行对调。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort-demo3.png" alt="heapsort-demo" tabindex="0" loading="lazy"><figcaption>heapsort-demo</figcaption></figure><p>步骤4：重新构建一个大顶堆。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort-demo4.png" alt="heapsort-demo" tabindex="0" loading="lazy"><figcaption>heapsort-demo</figcaption></figure><p>步骤5：将堆顶元素和尾部元素进行对调。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort-demo5.png" alt="heapsort-demo" tabindex="0" loading="lazy"><figcaption>heapsort-demo</figcaption></figure><p>步骤6：重新构建一个大顶堆。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort-demo6.png" alt="heapsort-demo" tabindex="0" loading="lazy"><figcaption>heapsort-demo</figcaption></figure><p>步骤7：将堆顶元素和尾部元素进行对调。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort-demo7.png" alt="heapsort-demo" tabindex="0" loading="lazy"><figcaption>heapsort-demo</figcaption></figure><p>步骤8：将堆顶元素和尾部元素进行对调。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort-demo8.png" alt="heapsort-demo" tabindex="0" loading="lazy"><figcaption>heapsort-demo</figcaption></figure><p>复杂度：</p><p>时间复杂度：O(nlogn)</p><h2 id="稳定性分析" tabindex="-1"><a class="header-anchor" href="#稳定性分析" aria-hidden="true">#</a> 稳定性分析</h2><p><strong>稳定性</strong>就是指对于两个关键字相等的记录，它们在序列中的相对位置，在排序之前和排序之后没有发生改变。通俗地讲就是有两个关键字相等的数据A、B，排序前，A的位置是 i ，B的位置是 j，此时 i &lt; j，则如果在排序后A的位置还是在B之前，那么称它是稳定的。</p><p>那么堆排序是一个稳定排序吗？</p><h3 id="堆排序的稳定性分析" tabindex="-1"><a class="header-anchor" href="#堆排序的稳定性分析" aria-hidden="true">#</a> 堆排序的稳定性分析</h3><p>直接上答案堆排序并不是一个稳定排序。</p><p>堆排序的会将原始的数组转化成一个大顶堆或一个小顶堆，在输出堆顶后，此时需要维护堆，操作如下：</p><p>（1）堆顶与堆尾交换并删除堆尾，被删除的堆尾的元素就是输出过的元素</p><p>（2）把当前堆顶向下调整，直到满足构成堆的条件，重复（1）步骤</p><p>在堆顶与堆尾交换的时候两个相等的记录在序列中的相对位置就可能发生改变，这就影响其稳定性了。</p><p>下面看一个实际的例子， [5A,6,5B,7,8] ，A和B用于区分相同元素。</p><p>数组的原始的状态如下所示：</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort-stable1.png" alt="heapsort-stable1" tabindex="0" loading="lazy"><figcaption>heapsort-stable1</figcaption></figure><p>首先调整下方的子树[6，7，8]，将8和6的位置调换。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort-stable2.png" alt="heapsort-stable2" tabindex="0" loading="lazy"><figcaption>heapsort-stable2</figcaption></figure><p>接着调整下方的子树[5A，8，5B]，将8和5A的位置调换。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort-stable3.png" alt="heapsort-stable3" tabindex="0" loading="lazy"><figcaption>heapsort-stable3</figcaption></figure><p>由于5A和8位置的调换，需要重新调整下方的子树[5A，7，6]，将5A和7的位置调换。这个时候5A和5B的顺序就出现了一次乱序。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort-stable4.png" alt="heapsort-stable4" tabindex="0" loading="lazy"><figcaption>heapsort-stable4</figcaption></figure><p>至此，第一轮排序完毕，将8和数组尾部元素6交换。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort-stable5.png" alt="heapsort-stable5" tabindex="0" loading="lazy"><figcaption>heapsort-stable5</figcaption></figure><p>接着调整顶部的子树[6，7，5B]，将7和6的位置调换。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort-stable6.png" alt="heapsort-stable6" tabindex="0" loading="lazy"><figcaption>heapsort-stable6</figcaption></figure><p>这个时候第二轮排序已经结束，此时可以将7和数组尾部元素5A进行调整。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort-stable7.png" alt="heapsort-stable7" tabindex="0" loading="lazy"><figcaption>heapsort-stable7</figcaption></figure><p>接着调整顶部的子树[5A，6，5B]，将6和5A的位置调换。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort-stable8.png" alt="heapsort-stable8" tabindex="0" loading="lazy"><figcaption>heapsort-stable8</figcaption></figure><p>这个时候第三轮排序已经结束，此时可以将6和数组尾部元素5B进行调整。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort-stable9.png" alt="heapsort-stable9" tabindex="0" loading="lazy"><figcaption>heapsort-stable9</figcaption></figure><p>剩下的元素已经满足了排序的要求，于是直接输出结果。</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/datastructure_algorithm/heapsort-stable/heapsort-stable10.png" alt="heapsort-stable10" tabindex="0" loading="lazy"><figcaption>heapsort-stable10</figcaption></figure><p>至此[5A,6,5B,7,8] 排序为 [5B,5A,6,7,8]。可以看到5A和5B的关系发生了变化。</p><p>通过这个例子也证明了堆排序不是一个稳定排序。</p>',67),s=[o];function p(g,n){return a(),e("div",null,s)}const h=t(r,[["render",p],["__file","heapsort-stable.html.vue"]]);export{h as default};
