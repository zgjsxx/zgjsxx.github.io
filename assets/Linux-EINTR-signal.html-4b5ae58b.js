import{_ as n,V as s,W as a,a0 as t}from"./framework-9a29aaa0.js";const e={},p=t(`<h1 id="socket编程中的eintr是什么" tabindex="-1"><a class="header-anchor" href="#socket编程中的eintr是什么" aria-hidden="true">#</a> socket编程中的EINTR是什么?</h1><p>在socket编程中，我们时常在accept/read/write等接口调用的异常处理的部分看到对于EINTR的处理，例如下面这样的语句：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>repeat<span class="token operator">:</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buff<span class="token punctuation">,</span> size<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>errno <span class="token operator">==</span> EINTR<span class="token punctuation">)</span>
        <span class="token keyword">goto</span> repeat<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;read failed&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么EINTR是什么呢？为什么要对它进行处理呢？ 本文将对EINTR做一些讨论。</p><h2 id="慢系统调用" tabindex="-1"><a class="header-anchor" href="#慢系统调用" aria-hidden="true">#</a> 慢系统调用</h2><p>如果想要解释<strong>EINTR</strong>，首先得对<strong>慢系统调用</strong>有个了解。</p><p><strong>慢系统调用</strong>(slow system call)指不会立即返回的系统调用, 可能<strong>永远阻塞</strong>而无法返回。 例如支持网络的调用, 包括read/write, connect, accept等, 都属于这一类。</p><p>慢系统调用, 主要分为以下类别:</p><ul><li>读写&quot;慢&quot;设备。 包括pipe, fifo, 终端设备, 网络连接等. 读时, 数据不存在, 需要等待缓冲区有数据输入; 写时, 缓冲区满, 需要等待缓冲区有空闲位置。注意: 读写磁盘文件一般不会阻塞， 网络磁盘除外。</li><li>打开某些特殊文件时, 需要等待某些条件才能打开。如打开终端设备, 需要等待连接设备的modern响应, 才能打开</li><li>pause和wait系统调用。 <ul><li>pause阻塞进程, 直到收到信号唤醒;</li><li>wait等待任意子进程终止;</li></ul></li><li>某些ioctl操作</li><li>某些IPC操作。如pipe, fifo, 没有指定NON_BLOCKING选项时的写操作, 如果管道缓冲区满, write阻塞;互斥锁, 条件变量, 信号量, 记录锁等等.</li></ul><h2 id="慢系统调用与eintr" tabindex="-1"><a class="header-anchor" href="#慢系统调用与eintr" aria-hidden="true">#</a> 慢系统调用与EINTR</h2><p>如果进程在一个<strong>慢系统调用</strong>(slow system call)中阻塞时，当捕获到某个信号且相应信号处理函数返回时，这个系统调用被中断，调用返回错误，设置errno为EINTR（相应的错误描述为&quot;Interrupted system call&quot;）。</p><p>因此EINTR错误的产生是<strong>慢系统调用</strong>和<strong>信号处理函数</strong>组合使用会产生的问题。</p><p>回过头来再看开头所提到的这一段的代码，其含义是当程序通过read读取数据，当目前fd对应的缓冲区没有数据可读时，进程将被阻塞。此时如果向该进程发送了信号，那么read函数将会返回-1，并且此时errno为EINTR，代表read方法被中断了。对于这样的情况，我们就需要人为的对read进行&quot;重启&quot;， 即重新的进行read。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>repeat<span class="token operator">:</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buff<span class="token punctuation">,</span> size<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>errno <span class="token operator">==</span> EINTR<span class="token punctuation">)</span>
        <span class="token keyword">goto</span> repeat<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;read failed&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到此，我们了解到了EINTR的产生原因，下面将介绍如何处理EINTR，以避免一些不必要的系统问题。</p><h2 id="如何避免eintr带来的问题。" tabindex="-1"><a class="header-anchor" href="#如何避免eintr带来的问题。" aria-hidden="true">#</a> 如何避免EINTR带来的问题。</h2><p>既然系统调用会被中断，那么就需要处理被中断的系统调用。</p><ul><li>人为重启被中断的系统调用</li><li>安装信号时设置 SA_RESTART属性（该方法对有的系统调用无效）</li></ul><p>其实人为重启被中断的系统调用，上面已经提到过了</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>repeat<span class="token operator">:</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buff<span class="token punctuation">,</span> size<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>errno <span class="token operator">==</span> EINTR<span class="token punctuation">)</span>
        <span class="token keyword">goto</span> repeat<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;read failed&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里着重来看一下第二种方法，为信号处理函数设置<code>SA_RESTART</code>。</p><p>下面是一个使用socket编程所建立的一个TCP server，进程在没有连接进入的时候将会卡在accept调用上。 同时，对于该进程，安装了SIGINT的信号处理函数，并且为该信号设置了SA_RESTART的属性。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">//g++ main.cpp -o main</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netinet/in.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PORT</span> <span class="token expression"><span class="token number">8080</span></span></span>
<span class="token keyword">void</span>  <span class="token function">handler_func</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;test\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token keyword">const</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> server_fd<span class="token punctuation">,</span> new_socket<span class="token punctuation">;</span>
    ssize_t valread<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> address<span class="token punctuation">;</span>
    <span class="token keyword">int</span> opt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    socklen_t addrlen <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span><span class="token operator">*</span> hello <span class="token operator">=</span> <span class="token string">&quot;Hello from server&quot;</span><span class="token punctuation">;</span>

    <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> action<span class="token punctuation">;</span>

    action<span class="token punctuation">.</span>sa_handler <span class="token operator">=</span> handler_func<span class="token punctuation">;</span>
    <span class="token function">sigemptyset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>action<span class="token punctuation">.</span>sa_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
    action<span class="token punctuation">.</span>sa_flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">/* 设置SA_RESTART属性 */</span>
    action<span class="token punctuation">.</span>sa_flags <span class="token operator">|=</span> SA_RESTART<span class="token punctuation">;</span>
    <span class="token function">sigaction</span><span class="token punctuation">(</span>SIGINT<span class="token punctuation">,</span> <span class="token operator">&amp;</span>action<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Creating socket file descriptor</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>server_fd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">&quot;socket failed&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Forcefully attaching socket to the port 8080</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">setsockopt</span><span class="token punctuation">(</span>server_fd<span class="token punctuation">,</span> SOL_SOCKET<span class="token punctuation">,</span>
                            SO_REUSEADDR <span class="token operator">|</span> SO_REUSEPORT<span class="token punctuation">,</span> <span class="token operator">&amp;</span>opt<span class="token punctuation">,</span>
                            <span class="token keyword">sizeof</span><span class="token punctuation">(</span>opt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">&quot;setsockopt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    address<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>
    address<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> INADDR_ANY<span class="token punctuation">;</span>
    address<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>PORT<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Forcefully attaching socket to the port 8080</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">bind</span><span class="token punctuation">(</span>server_fd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span>
                    <span class="token keyword">sizeof</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">&quot;bind failed&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">listen</span><span class="token punctuation">(</span>server_fd<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">&quot;listen&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>new_socket
            <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>server_fd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span>
                            <span class="token operator">&amp;</span>addrlen<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">&quot;accept&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    valread <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>new_socket<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span>
                            <span class="token number">1024</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// subtract 1 for the null</span>
                                                    <span class="token comment">// terminator at the end</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s\\n&quot;</span><span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">send</span><span class="token punctuation">(</span>new_socket<span class="token punctuation">,</span> hello<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Hello message sent\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// closing the connected socket</span>
    <span class="token function">close</span><span class="token punctuation">(</span>new_socket<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// closing the listening socket</span>
    <span class="token function">close</span><span class="token punctuation">(</span>server_fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>程序运行后，使用ctrl+c 向进程发送SIGINT信号，可以看到程序输出了test的打印，但是程序仍然阻塞在了accept的系统调用上，等待客户端连接。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost test1<span class="token punctuation">]</span><span class="token comment"># ./main</span>
^Ctest
^Ctest
^Ctest
^Ctest
^Ctest
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果没有添加SA_RESTART这样的flag， 那么发送SIGINT给进程的话，accept就会报这样的错误，就需要手动进行处理。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost test1<span class="token punctuation">]</span><span class="token comment"># ./main</span>
^Ctest
accept: Interrupted system call
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是要注意的是SA_RESTART并不能解决所有的问题。</p><p>下面的这些场景当设置了SA_RESTART后，如果信号处理函数返回之后，系统调用可以自行恢复：</p><ul><li>read/readv/write/writev/ioctl在&quot;慢设备&quot;上的调用。所谓慢设备，就是在该设备上执行I/O调用时可能会造成无限时间的阻塞的一类设备， 例如管道，socket,终端。 需要注意的是，本地磁盘不属于慢设备，但是网络磁盘属于慢设备。</li><li>open， 例如open一个FIFO。</li><li>wait系列的方法，例如：wait(2), wait3(2), wait4(2), waitid(2), and waitpid(2).</li><li>没有设置超时参数的socket的操作接口。 accept(2), connect(2), recv(2), recvfrom(2), recvmmsg(2), recvmsg(2), send(2), sendto(2), and sendmsg(2).</li><li>文件锁接口： flock(2)， fcntl(2)进行F_OFD_SETLKW F_SETLKW操作。</li><li>POSIX消息队列: mq_receive(3), mq_timedreceive(3), mq_send(3), mq_timedsend(3).</li><li>futex(2) FUTEX_WAIT。 2.6.22版本之前， 信号处理函数返回时，futex总是返回EINTR，SA_RESTART无效。</li><li>getrandom(2).</li><li>pthread_mutex_lock(3), pthread_cond_wait(3)</li><li>futex(2) FUTEX_WAIT_BITSET.</li><li>POSIX 信号量的接口 sem_wait(3) and sem_timedwait(3)。 2.6.22版本之前， 信号处理函数返回时，信号量的接口总是返回EINTR，SA_RESTART无效。</li><li>read(2) 方法操作由 inotify(7)方法返回的文件描述符 (3.8版本之前， 信号处理函数返回时，总是返回EINTR，SA_RESTART无效。).</li></ul><p>下面这些场景，即使使用了SA_RESTART，当系统调用被信号处理函数中断后，仍然会返回EINTR：</p><ul><li>设置了超过时间的socket的输入接口。使用setsockopt方法的SO_RCVTIMEO参数可以设置timeout时间。accept(2), recv(2), recvfrom(2)，recvmmsg(2) recvmsg(2).</li><li>设置了超过时间的socket的输出接口。使用setsockopt方法的SO_SNDTIMEO参数可以设置timeout时间。connect(2), send(2), sendto(2), sendmsg(2).</li><li>等待信号的接口，例如: pause(2), sigsuspend(2), sigtimedwait(2), and sigwaitinfo(2).</li><li>多路复用的接口，例如： epoll_wait(2), epoll_pwait(2), poll(2), ppoll(2), select(2), and pselect(2).</li><li>System V的IPC interface， 例如：msgrcv(2), msgsnd(2), semop(2), 和semtimedop(2).</li><li>sleep的接口， 例如: clock_nanosleep(2), nanosleep(2), and usleep(3).</li><li>io_getevents(2).</li></ul><p>还有一个比较特殊的是sleep(3)方法，其被信号处理函数打断后并不会返回返回EINTR， 而是将剩下需要sleep的时间作为返回值返回。</p><p>在整理资料时，我发现Linux man的界面还存在一个描述问题：</p><figure><img src="https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/Linux/application-dev/EINTR/EINTR.png" alt="EINTR" tabindex="0" loading="lazy"><figcaption>EINTR</figcaption></figure><p>对于Output socket接口的描述中， <strong>when a timeout (SO_RCVTIMEO) has been set on the socket</strong> 描述并不正确。此时描述的是output相关的接口，因此应该是<strong>when a timeout (SO_SNDTIMEO) has been set on the socket</strong>。 下面的<strong>if a send timeout (SO_SNDTIMEO) has been set</strong>描述正确了，但是感觉又有点重复。</p><p>从上面的描述中我们知道， <strong>SO_RESTART</strong>并不是万能的，对于一些接口而言，仍然需要添加对EINTR的处理。 因此对于EINTR的处理需要组合上面两种方法。</p><h1 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h1><ul><li>EINTR错误的产生是<strong>慢系统调用</strong>和<strong>信号处理函数</strong>组合使用会产生的问题。</li><li>对于EINTR错误，安装信号处理函数时设置SA_RESTART可以解决很多系统调用被终端的问题。但是对于一些可以设置超时参数的API，即使设置SA_RESTART，仍然有可能收到EINTR错误。因此组合使用SA_RESTART和人为重启系统调用。</li></ul>`,39),o=[p];function c(i,l){return s(),a("div",null,o)}const r=n(e,[["render",c],["__file","Linux-EINTR-signal.html.vue"]]);export{r as default};
