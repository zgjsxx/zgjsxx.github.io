const e=JSON.parse('{"key":"v-00db6e7c","path":"/posts/Program_language/cpp/effective-cpp/effective-cpp-24.html","title":"effective c++ 24 若所有参数皆需要类型转换，请为此采用non-member函数","lang":"zh-CN","frontmatter":{"category":["C++"],"tag":["C++","effective c++读书笔记"],"description":"effective c++ 24 若所有参数皆需要类型转换，请为此采用non-member函数 本节所讲解的点是一个比较细节的点，本文所focus的点和隐式转换强相关，实际工作中并不会经常用到，因为我们并不推荐使用隐式类型转换。因此，本章节直接通过例子理解作者所要表达的观点即可。 分析 现在有一个Rational类，这个类重载了operator*运算符。Rational的构造函数并不是explicit的，它允许隐式转化。 因此，下面的表达式中，前三个表达式将可以成功通过编译， 然而最后一个将不能成功通过编译。因为没有一个 operator*(int ，Rational)的运算符。","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/Program_language/cpp/effective-cpp/effective-cpp-24.html"}],["meta",{"property":"og:site_name","content":"Code Building"}],["meta",{"property":"og:title","content":"effective c++ 24 若所有参数皆需要类型转换，请为此采用non-member函数"}],["meta",{"property":"og:description","content":"effective c++ 24 若所有参数皆需要类型转换，请为此采用non-member函数 本节所讲解的点是一个比较细节的点，本文所focus的点和隐式转换强相关，实际工作中并不会经常用到，因为我们并不推荐使用隐式类型转换。因此，本章节直接通过例子理解作者所要表达的观点即可。 分析 现在有一个Rational类，这个类重载了operator*运算符。Rational的构造函数并不是explicit的，它允许隐式转化。 因此，下面的表达式中，前三个表达式将可以成功通过编译， 然而最后一个将不能成功通过编译。因为没有一个 operator*(int ，Rational)的运算符。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-05-15T03:06:00.000Z"}],["meta",{"property":"article:tag","content":"C++"}],["meta",{"property":"article:tag","content":"effective c++读书笔记"}],["meta",{"property":"article:modified_time","content":"2023-05-15T03:06:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"effective c++ 24 若所有参数皆需要类型转换，请为此采用non-member函数\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-05-15T03:06:00.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"分析","slug":"分析","link":"#分析","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1683788312000,"updatedTime":1684119960000,"contributors":[{"name":"zgjsxx","email":"119160524@qq.com","commits":2}]},"readingTime":{"minutes":1.6,"words":480},"filePathRelative":"posts/Program_language/cpp/effective-cpp/effective-cpp-24.md","localizedDate":"2023年5月11日","excerpt":"<h1> effective c++ 24 若所有参数皆需要类型转换，请为此采用non-member函数</h1>\\n<p>本节所讲解的点是一个比较细节的点，本文所focus的点和隐式转换强相关，实际工作中并不会经常用到，因为我们并不推荐使用隐式类型转换。因此，本章节直接通过例子理解作者所要表达的观点即可。</p>\\n<h2> 分析</h2>\\n<p>现在有一个Rational类，这个类重载了<code>operator*</code>运算符。Rational的构造函数并不是explicit的，它允许隐式转化。</p>\\n<p>因此，下面的表达式中，前三个表达式将可以成功通过编译， 然而最后一个将不能成功通过编译。因为没有一个\\n<code>operator*(int ，Rational)</code>的运算符。</p>","autoDesc":true}');export{e as data};
