import{_ as e,V as i,W as n,a0 as l}from"./framework-9a29aaa0.js";const a={},c=l('<h1 id="effective-c-30-彻底了解inline的里里外外" tabindex="-1"><a class="header-anchor" href="#effective-c-30-彻底了解inline的里里外外" aria-hidden="true">#</a> effective c++ 30 彻底了解inline的里里外外</h1><p>本节主要介绍inline的条条框框。</p><h2 id="分析" tabindex="-1"><a class="header-anchor" href="#分析" aria-hidden="true">#</a> 分析</h2><p>我们首先讨论inline的好处。</p><ul><li>inline函数相当于将代码copy到调用的地方，可以减少函数调用的额外开销。</li><li>可以替代define的宏函数却又比宏函数安全。</li></ul><p>但是天下没有免费的午餐。</p><p>inline的坏处也很明显：</p><ul><li>inline可能造成程序体积膨胀</li><li>可能造成额外的换页行为，降低指令高速缓存命中率</li></ul><p>因此我们就要趋利弊害，在适合inline的地方使用inline。至于什么场景适合，直接看总结，inline适合于小型被频繁调用的函数身上，通常在10行以下。</p><p>文中，作者也提到构造函数和析构函数通常也不要定义为inline的。</p><p>另外一点，对于一些header-only的c++ library，inline会大量的使用，因此对于这类c++ library就需要对其体积膨胀的不利影响进行评估。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><ul><li>将大多数inline限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。</li><li>不要只因为function templates出现在头文件，就将它们声明为inline。</li></ul>',13),t=[c];function r(d,h){return i(),n("div",null,t)}const f=e(a,[["render",r],["__file","effective-cpp-30.html.vue"]]);export{f as default};
