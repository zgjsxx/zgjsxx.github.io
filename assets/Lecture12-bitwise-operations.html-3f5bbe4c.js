import{_ as a,V as s,W as r,X as e,Y as d,$ as n,a0 as i,F as o}from"./framework-9a29aaa0.js";const l={},c=i(`<h1 id="第十二讲-按位运算" tabindex="-1"><a class="header-anchor" href="#第十二讲-按位运算" aria-hidden="true">#</a> 第十二讲：按位运算</h1><h2 id="按位运算" tabindex="-1"><a class="header-anchor" href="#按位运算" aria-hidden="true">#</a> 按位运算</h2><p>位运算在汇编语言中很重要。我们已经学习了<code>xor</code>（异或），这里我们将学习其他操作<code>or</code>、<code>and</code>、<code>not</code>、<code>andn</code>（与非），以及<strong>移位</strong>和<strong>旋转</strong>操作。除了这些在 C/C++ 也有的位运算之外，汇编语言还支持 C/C++ 语言没有的一些位运算。<code>test</code>操作是按位进行比较的运算符，在条件跳转时可能会用它来构建跳转的状态位。</p><h3 id="and-or-not-and-not位运算" tabindex="-1"><a class="header-anchor" href="#and-or-not-and-not位运算" aria-hidden="true">#</a> AND，OR，NOT，AND-NOT位运算</h3><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>not  dest         ; dest = ~dest
and  dest, src    ; dest = dest &amp; src
or   dest, src    ; dest = dest | src
andn dest, src    ; dest = dest &amp; ~src
xor  dest, src    ; dest = dest ^ src
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的指令通常的限制如下：</p><ul><li>两个操作数必须具有相同的大小，<code>dest</code>和<code>src</code>不能都在内存中，并且只有源操作数(<code>src</code>)可以是立即数。</li><li><code>not</code> 可以与寄存器或内存位置一起使用。</li></ul><p>这些操作的真值表如下所示：</p><ul><li><p>如果 a 为 0，则 ~a 为 1；如果 a 为 1，则 ~a 为 0：</p><table><thead><tr><th>a</th><th>~a</th></tr></thead><tbody><tr><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td></tr></tbody></table></li><li><p>只有当a和b都为1时a和b才为1，否则为0。</p><table><thead><tr><th>a</th><th>b</th><th>a &amp; b</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table></li><li><p>如果 a 或 b 为 1，则 a | b 为 1；只有当 a 或 b 均为 0 时，a | b 才为 0。</p><table><thead><tr><th>a</th><th>b</th><th>a or b</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table></li><li><p><code>a&amp;~b</code>，只有当a = 1且b = 0时， 结果才为1。</p><table><thead><tr><th>a</th><th>b</th><th>a &amp; ~b</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table></li><li><p><code>a^b</code>，当a和b有一个值为1时，结果为1。</p><table><thead><tr><th>a</th><th>b</th><th>a ^ b</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table></li></ul><p>真值表反应的是单个比特位运算的计算方法。当应用于二进制数字，则将每个比特位执行相应的运算。例如：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>   01101101
 <span class="token operator">&amp;</span> <span class="token number">11101110</span>
------------ 
   01101100
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="设置-取消比特位-翻转比特位" tabindex="-1"><a class="header-anchor" href="#设置-取消比特位-翻转比特位" aria-hidden="true">#</a> 设置/取消比特位， 翻转比特位</h3><p>对一个比特位的常见操作有三种:</p><ul><li>设置比特位(设置值为1)</li><li>取消比特位(设置值为0)</li><li>翻转比特位(原值为0，设置为1，原值为1，设置为0)</li></ul><p>这些操作的第一个步骤是构造一个位掩码，我们希望操作的位的值为 1，其他位置的值为 0。</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>bitmask:   EQU   10000000b    ; Manipulate bit 7
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果位置不是恒定的，那么我们可以使用移位（见下文）来动态构造掩码。</p><p>要设置一个位，同时保持所有其他位不变，我们使用<code>or</code>。 <code>x or 0 == x</code>，因此掩码中未设置的位将保持不变，但 <code>x or 1 == 1</code>，因此掩码中已设置的位将被强制为 1。</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>or  rax, bitmask 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>为了取消比特位，我们需要一个按位运算 OP，它满足 <code>x OP 0 == x</code> 和 <code>x OP 1 == 0</code>。查看上面的真值表，我们发现与非运算就是我们想要的。</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>andn rax, bitmask
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>为了翻转一个比特位，我们需要一个操作 <code>OP</code>，其中 <code>x OP 0 == x</code> 但 <code>x OP 1 == ~x</code>。同样，从表中我们可以看到 <code>xor</code> 就是我们想要的：</p><div class="language-x868asm line-numbers-mode" data-ext="x868asm"><pre class="language-x868asm"><code>xor rax, bitmask
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果需要一次性操作多个比特位，则需要一个设置了多个位的掩码，这样就可以一次性设置/清除/翻转多个位。</p><h2 id="符号位的延伸" tabindex="-1"><a class="header-anchor" href="#符号位的延伸" aria-hidden="true">#</a> 符号位的延伸</h2><p>上面，汇编器负责将位掩码的值扩展为 64 位（<code>rax</code> 的大小），以便大小匹配。实际上，位运算可以用在长度小于目标的立即数与目标数上。我们可以通过为立即数掩码显式指定大小来强制执行此行为：</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>mov rax, 0
or  rax, byte bitmask ; What bit(s) does this set?
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>当立即数的值（显式）小于目标值时，将符号扩展为目标值的大小。</p><p>现在我们想将其扩展到 16 位。如果我们简单地添加 0，那么我们有</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>0000000011111111b <span class="token operator">=</span> <span class="token number">127</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>请记住，如果未设置高位，则该值为正！相反，我们将 11111111b 的最高位复制到我们添加的新位中：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>1111111111111111b <span class="token operator">=</span> <span class="token parameter variable">-1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>每当我们扩展一个有符号值时，我们都需要执行符号扩展。相反，如果我们扩展一个无符号值，那么我们一定不能执行符号扩展，因为它会给出错误的结果。为了扩展无符号值，我们执行零扩展，用零填充高位。</p><p>这两种转换的区别就是 <code>movsx</code> 和 <code>movzx</code> 操作的区别：</p><div class="language-x86asm line-numbers-mode" data-ext="x86asm"><pre class="language-x86asm"><code>movsx dest, src      ; Sign-extend src into dest
movzx dest, src      ; Zero-extent src into dest
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="移位和旋转" tabindex="-1"><a class="header-anchor" href="#移位和旋转" aria-hidden="true">#</a> 移位和旋转</h2><p>在 C/C++ 中，我们有 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 运算符，它们执行<strong>左移位</strong>和<strong>右移位</strong>。它们通常用作乘/除2的便捷方式。要了解其原理，请考虑二进制值 3：</p><h2 id="附录" tabindex="-1"><a class="header-anchor" href="#附录" aria-hidden="true">#</a> 附录</h2>`,38),p={href:"https://staffwww.fullcoll.edu/aclifton/cs241/lecture-bitwise-operations.html",target:"_blank",rel:"noopener noreferrer"};function h(b,u){const t=o("ExternalLinkIcon");return s(),r("div",null,[c,e("p",null,[d("原文连接："),e("a",p,[d("https://staffwww.fullcoll.edu/aclifton/cs241/lecture-bitwise-operations.html"),n(t)])])])}const v=a(l,[["render",h],["__file","Lecture12-bitwise-operations.html.vue"]]);export{v as default};
