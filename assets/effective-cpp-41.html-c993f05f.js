import{_ as n,V as s,W as a,a0 as p}from"./framework-9a29aaa0.js";const t={},e=p(`<h1 id="effective-c-41-隐式接口和编译器多态" tabindex="-1"><a class="header-anchor" href="#effective-c-41-隐式接口和编译器多态" aria-hidden="true">#</a> effective c++ 41 隐式接口和编译器多态</h1><h2 id="分析" tabindex="-1"><a class="header-anchor" href="#分析" aria-hidden="true">#</a> 分析</h2><p>面向对象编程总是以显式接口和运行期多态解决问题。举个例子，给定这样“无意义”的类</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Widget</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">virtual</span> std<span class="token double-colon punctuation">::</span>size_t <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">normalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;</span> other<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>和这样“无意义”的函数：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">doProcessing</span><span class="token punctuation">(</span>Widget <span class="token operator">&amp;</span> w<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>w<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">10</span> <span class="token operator">&amp;</span> w <span class="token operator">!=</span> someNestyWidget<span class="token punctuation">)</span><span class="token punctuation">{</span>
		Widget <span class="token function">temp</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
		temp<span class="token punctuation">.</span><span class="token function">normaliza</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		temp<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以这样说doProcessing内的w：</p><ul><li>由于w的类型被声明为Widget，所以w必须支持Widget接口。我们可以在widget.h中找出这个接口，看看它是什么样子，所以我们称之为一个显式接口，也就是它在源码中明确可见</li><li>由于Widget的某些成员函数是virtual，w对那些函数的调用将表现出运行期多态，也就是将于运行期根据w的动态类型决定究竟调用哪一个函数。</li></ul><p>模板以及泛型编程世界，与面向对象有根本的不同。在此世界中显式接口和运行期多态依旧存在，但重要性降低。隐式接口和编译期多态更重要：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">doProcessing</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span> w<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>w<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">10</span> <span class="token operator">&amp;</span> w <span class="token operator">!=</span> someNestyWidget<span class="token punctuation">)</span><span class="token punctuation">{</span>
		Widget <span class="token function">temp</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
		temp<span class="token punctuation">.</span><span class="token function">normaliza</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		temp<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以这样说doProcessing内的w：</p><ul><li>w必须支持哪一种接口，是由模板中执行在w身上的操作来决定。上面w的类型T必须支持size、不等比较、拷贝构造、normalize、swap这几种函数。这些就是T必须支持的一组隐式接口</li><li>凡涉及到w的任何函数调用，比如operator!=，有可能造成模板具现化。这样的具现行为发生在编译期，“以不同的模板参数具现化函数模板”会导致调用不同的函数，这就是编译期多态</li></ul><p>编译期多态 VS 运行期多态</p><p>编译期多态：哪一个重载函数被调用 运行期多态：哪一个虚函数被绑定</p><p>显式接口 VS 隐式接口</p><p>通常显式接口有函数的签名(也就是函数名称、参数类型、返回类型)构成。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Widget</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">virtual</span> std<span class="token double-colon punctuation">::</span>size_t <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">normalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;</span> other<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>比如Widget类中public接口由构造函数、析构函数、函数size，normalize，swap及其参数类型、返回值类型、常量性组成，当然也包括编译期产生的拷贝构造函数和拷贝运算符。另外也可以包括typedef、成员变量(不建议成员变量声明为public)</p><p>隐式接口：它并不基于函数签名式，而是由有效表达式组成。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">doProcessing</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span> w<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>w<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">10</span> <span class="token operator">&amp;</span> w <span class="token operator">!=</span> someNestyWidget<span class="token punctuation">)</span><span class="token punctuation">{</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看起来T的隐式接口必须由这些约束</p><ul><li>它必须提供一个叫做size()的成员函数，该函数返回一个整数值</li><li>它必须支持一个叫做operator!=的函数，用来比较两个对象</li></ul><p>实际上这个两个约束都不需要满足</p><ul><li><p>T必须支持成员函数，但是这个函数也可以从基类继承。这个函数不一定返回int，它唯一要做的是返回一个类型为X的对象，而X对象加上一个int(10的类型)必须能够调用一个operator&gt;</p></li><li><p>同理，T并不需要支持operator!=</p></li></ul><p>可以看出，隐式接口仅仅是由一组有效表达式组成</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><ul><li>classes和template都支持接口和多态。</li><li>对classes而言接口时显示的explicit， 以函数签名为中心。多态则是通过虚函数发生于运行期。</li><li>对template参数而言，接口时隐式的，奠基于有效表达式。多态则是通过template具现化和函数重载解析发生于编译期。</li></ul>`,27),o=[e];function c(i,l){return s(),a("div",null,o)}const d=n(t,[["render",c],["__file","effective-cpp-41.html.vue"]]);export{d as default};
