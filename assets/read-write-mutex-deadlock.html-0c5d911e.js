const t=JSON.parse('{"key":"v-d6087b44","path":"/posts/Linux/application-dev/read-write-mutex-deadlock.html","title":"Linux读写锁的容易犯的问题","lang":"zh-CN","frontmatter":{"category":["Linux"],"tags":["操作系统面试题"],"description":"Linux读写锁的容易犯的问题 读写锁是互斥锁之外的另一种用于多线程之间同步的一种方式。 多线程对于一个共享变量的读操作是安全的， 而写操作是不安全的。如果在一个读很多而写很少的场景之下，那么使用互斥锁将会阻碍大量的线程安全的读操作的进行。在这种场景下，读写锁这样一种设计便诞生了。 读写锁的特性如下表所示， 总结起来就是读读不互斥， 读写互斥， 写写互斥。","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/Linux/application-dev/read-write-mutex-deadlock.html"}],["meta",{"property":"og:site_name","content":"Code Building"}],["meta",{"property":"og:title","content":"Linux读写锁的容易犯的问题"}],["meta",{"property":"og:description","content":"Linux读写锁的容易犯的问题 读写锁是互斥锁之外的另一种用于多线程之间同步的一种方式。 多线程对于一个共享变量的读操作是安全的， 而写操作是不安全的。如果在一个读很多而写很少的场景之下，那么使用互斥锁将会阻碍大量的线程安全的读操作的进行。在这种场景下，读写锁这样一种设计便诞生了。 读写锁的特性如下表所示， 总结起来就是读读不互斥， 读写互斥， 写写互斥。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-10-07T06:54:47.000Z"}],["meta",{"property":"article:tag","content":"操作系统面试题"}],["meta",{"property":"article:modified_time","content":"2023-10-07T06:54:47.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Linux读写锁的容易犯的问题\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-10-07T06:54:47.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"读写锁使用的正确性","slug":"读写锁使用的正确性","link":"#读写锁使用的正确性","children":[]},{"level":2,"title":"读写锁性能上的开销","slug":"读写锁性能上的开销","link":"#读写锁性能上的开销","children":[]},{"level":2,"title":"读写锁容易造成死锁","slug":"读写锁容易造成死锁","link":"#读写锁容易造成死锁","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1696652347000,"updatedTime":1696661687000,"contributors":[{"name":"zgjsxx","email":"119160524@qq.com","commits":2}]},"readingTime":{"minutes":7.07,"words":2122},"filePathRelative":"posts/Linux/application-dev/read-write-mutex-deadlock.md","localizedDate":"2023年10月7日","excerpt":"<h1> Linux读写锁的容易犯的问题</h1>\\n<p><strong>读写锁</strong>是互斥锁之外的另一种用于多线程之间同步的一种方式。</p>\\n<p>多线程对于一个共享变量的<strong>读操作</strong>是安全的， 而<strong>写操作</strong>是不安全的。如果在一个读很多而写很少的场景之下，那么使用互斥锁将会阻碍大量的线程安全的读操作的进行。在这种场景下，读写锁这样一种设计便诞生了。</p>\\n<p>读写锁的特性如下表所示， 总结起来就是<strong>读读不互斥</strong>， <strong>读写互斥</strong>， <strong>写写互斥</strong>。</p>","autoDesc":true}');export{t as data};
