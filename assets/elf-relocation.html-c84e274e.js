import{_ as d,V as l,W as i,X as n,Y as s,$ as t,a0 as e,F as r}from"./framework-9a29aaa0.js";const p={},c=e(`<h1 id="链接-重定位" tabindex="-1"><a class="header-anchor" href="#链接-重定位" aria-hidden="true">#</a> 链接 - 重定位</h1><p>重定位的条目(Entries)的定义如下所示，英文中使用entries来表示表中的一行记录。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    Elf32_Addr   r_offset<span class="token punctuation">;</span>
    ELF32_Word   r_info<span class="token punctuation">;</span>
<span class="token punctuation">}</span> Elf32_Rel<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    Elf32_Addr   r_offset<span class="token punctuation">;</span>
    ELF32_Word   r_info<span class="token punctuation">;</span>
    Elf32_Sword  r_addend<span class="token punctuation">;</span>
<span class="token punctuation">}</span> Elf32_Rela<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每个成员的含义如下：</p><ul><li>r_offset：给出了需要进行重定位的元素的位置。</li><li>r_info：</li><li>r_addend: 给出了一个数字，用于计算重定位后的位置是加上该数字</li></ul><table><thead><tr><th>名称</th><th>值</th><th>域</th><th>计算方式</th></tr></thead><tbody><tr><td>R_386_NONE</td><td>0</td><td>none</td><td>none</td></tr></tbody></table><p>R_386_GOT32: 该重定位类型计算符号的全局偏移表的条目到全局偏移表(GOT)的其实位置的距离。它会提示链接器构建全局偏移表(GOT)。个人理解这里指的就是动态链接的全局变量的重定位。</p><p>R_386_PLT32: 该重定位类型计算了符号的过程链接表(PLT)条目的地址，它指示链接器构建过程链接表(PLT)。个人理解这里指的就是动态链接的函数的重定位。</p><p>R_386_COPY：</p>`,9),o={href:"https://gitlab.com/x86-psABIs/x86-64-ABI/-/jobs/artifacts/master/raw/x86-64-ABI/abi.pdf?job=build",target:"_blank",rel:"noopener noreferrer"},u=e(`<p>A： 代表用于计算relocation 位置的加数 L： 代表PLT表中条目的位置 P： 代表被重定位的元素的位置(使用r_offset进行计算)</p><table><thead><tr><th>Name</th><th>Value</th><th>Field</th><th>Calculation</th></tr></thead><tbody><tr><td>R_X86_64_NONE</td><td>0</td><td>none</td><td>none</td></tr><tr><td>R_X86_64_64</td><td>1</td><td>word64</td><td>S + A</td></tr><tr><td>R_X86_64_PC32</td><td>2</td><td>word32</td><td>S + A -P</td></tr><tr><td>R_X86_64_PLT32</td><td>4</td><td>word32</td><td>L + A - P</td></tr><tr><td>R_X86_64_32</td><td>10</td><td>word32</td><td>S + A</td></tr><tr><td>R_X86_64_16</td><td>12</td><td>word16</td><td>S + A</td></tr><tr><td>R_X86_64_PC16</td><td>13</td><td>word32</td><td>S + A -P</td></tr><tr><td>R_X86_64_8</td><td>14</td><td>word8</td><td>S + A</td></tr><tr><td>R_X86_64_PC8</td><td>15</td><td>word8</td><td>S + A -P</td></tr><tr><td>R_X86_64_PC64</td><td>24</td><td>word64</td><td>S + A -P</td></tr></tbody></table><p>|R_X86_64_REX_GOTPCRELX||||</p><p>R_X86_64_* 系列代表使用绝对位置进行地址修正 R_X86_64_PC* 系列用于表示依照相对于PC指针的偏移进行地址修正 R_X86_64_PLT32 代表使用PLT表中的位置进行地址修正</p><p>理解这里需要了解x86-64的RIP-relative寻址。</p><p>x86-64的rip相对数据寻址之前系统不支持数据的相对寻址,不能像指令寻址的方式一样,获取变量i= 1只需要一个偏移量然后赋值就可以了,获取数据地址需要call拿到指令地址，再加上偏移地址来获得变量的地址代码举例</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">static</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
     i<span class="token operator">=</span><span class="token number">110</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接着进行编译：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>gcc <span class="token parameter variable">-fPIC</span> <span class="token parameter variable">-shared</span> <span class="token parameter variable">-m32</span> hello.c  <span class="token parameter variable">-o</span>  test32.so
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>反汇编可以看出,先call 3e6 &lt;__i686.get_pc_thunk.cx&gt;,再添加偏移量,最后再加上0x1c然后将110给这个地址(变量i)</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>000003cc <span class="token operator">&lt;</span>test<span class="token operator">&gt;</span>:
 3cc:	<span class="token number">55</span>                   	push   %ebp
 3cd:	<span class="token number">89</span> e5                	mov    %esp,%ebp
 3cf:	e8 <span class="token number">12</span> 00 00 00       	call   3e6 <span class="token operator">&lt;</span>__i686.get_pc_thunk.cx<span class="token operator">&gt;</span>//获取pc地址
 3d4:	<span class="token number">81</span> c1 <span class="token number">58</span> <span class="token number">11</span> 00 00    	<span class="token function">add</span>    <span class="token variable">$0x1158</span>,%ecx //添加偏移量
 3da:	c7 <span class="token number">81</span> 1c 00 00 00 6e 	movl   <span class="token variable">$0x6e</span>,0x1c<span class="token punctuation">(</span>%ecx<span class="token punctuation">)</span>//在加0x1c偏移量,最后拿到1这个值
 3e1:	00 00 00 
 3e4:	5d                   	pop    %ebp
 3e5:	c3                   	ret    
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,11),v={href:"http://test64.so",target:"_blank",rel:"noopener noreferrer"},_=e(`<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>000000000000052c <span class="token operator">&lt;</span>test<span class="token operator">&gt;</span>:
 52c:	<span class="token number">55</span>                   	push   %rbp
 52d:	<span class="token number">48</span> <span class="token number">89</span> e5             	mov    %rsp,%rbp
 <span class="token number">530</span>:	c7 05 9e 02 <span class="token number">20</span> 00 6e 	movl   <span class="token variable">$0x6e</span>,0x20029e<span class="token punctuation">(</span>%rip<span class="token punctuation">)</span>        <span class="token comment"># 2007d8 &lt;i&gt;</span>
 <span class="token number">537</span>:	00 00 00 
 53a:	c9                   	leaveq 
 53b:	c3                   	retq   
 53c:	<span class="token number">90</span>                   	nop
 53d:	<span class="token number">90</span>                   	nop
 53e:	<span class="token number">90</span>                   	nop
 53f:	<span class="token number">90</span>                   	nop
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="参考文献" tabindex="-1"><a class="header-anchor" href="#参考文献" aria-hidden="true">#</a> 参考文献</h1>`,2),b={href:"https://www.zhihu.com/question/270485830",target:"_blank",rel:"noopener noreferrer"};function m(k,h){const a=r("ExternalLinkIcon");return l(),i("div",null,[c,n("p",null,[s("关于relocation的类型，可以在"),n("a",o,[s("amd64 ABI"),t(a)]),s("中找到所有的定义。")]),u,n("p",null,[s("现在x86-64有rip了就直接可以通过偏移得到数据地址,由代码看出movl $0x6e,0x20029e(%rip) 就可以将110送入变量i的地址了,少了一次call跟偏移相加gcc -fPIC -shared hello.c -o "),n("a",v,[s("test64.so"),t(a)])]),_,n("ul",null,[n("li",null,[s("RIP相对寻址 "),n("a",b,[s("https://www.zhihu.com/question/270485830"),t(a)])])])])}const g=d(p,[["render",m],["__file","elf-relocation.html.vue"]]);export{g as default};
