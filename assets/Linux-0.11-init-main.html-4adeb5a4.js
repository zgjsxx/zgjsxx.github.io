import{_ as s,V as a,W as t,a0 as n,X as p}from"./framework-9a29aaa0.js";const e={},o=n(`<h1 id="linux-0-11-入口函数main-c详解" tabindex="-1"><a class="header-anchor" href="#linux-0-11-入口函数main-c详解" aria-hidden="true">#</a> Linux-0.11 入口函数main.c详解</h1><h2 id="模块简介" tabindex="-1"><a class="header-anchor" href="#模块简介" aria-hidden="true">#</a> 模块简介</h2><p>main.c大部分代码主要是对内核进行初始化，而main.c开始，就都是c语言编写的内核了。</p><h2 id="函数详解" tabindex="-1"><a class="header-anchor" href="#函数详解" aria-hidden="true">#</a> 函数详解</h2><h3 id="main" tabindex="-1"><a class="header-anchor" href="#main" aria-hidden="true">#</a> main</h3><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>	
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在head.s中会跳转main函数中进行执行。</p><p>main函数的开始定义了一些数据，包含了根设备的设备号，硬盘参数表信息，最大内存地址。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EXT_MEM_K</span> <span class="token expression"><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x90002</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DRIVE_INFO</span> <span class="token expression"><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">drive_info</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x90080</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ORIG_ROOT_DEV</span> <span class="token expression"><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x901FC</span><span class="token punctuation">)</span></span></span>

 	ROOT_DEV <span class="token operator">=</span> ORIG_ROOT_DEV<span class="token punctuation">;</span>
 	drive_info <span class="token operator">=</span> DRIVE_INFO<span class="token punctuation">;</span>        <span class="token comment">// 复制0x90080处的硬盘参数</span>
	memory_end <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>EXT_MEM_K<span class="token operator">&lt;&lt;</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 内存大小=1Mb + 扩展内存(k)*1024 byte</span>
	memory_end <span class="token operator">&amp;=</span> <span class="token number">0xfffff000</span><span class="token punctuation">;</span>                   <span class="token comment">// 忽略不到4kb(1页)的内存数</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里需要回忆一下，setup.s中所建立的一些数据：</p><table><thead><tr><th>内存地址</th><th>长度(字节)</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>0x90002</td><td>2</td><td>扩展内存数</td><td>系统从1MB开始的扩展内存数值</td></tr><tr><td>0x90080</td><td>16</td><td>硬盘参数表</td><td>第1个硬盘的参数表</td></tr><tr><td>0x90090</td><td>16</td><td>硬盘参数表</td><td>第2个硬盘的参数表</td></tr><tr><td>0x901FC</td><td>2</td><td>根设备号</td><td>根文件系统所在的设备号(bootsect.s设置)</td></tr></tbody></table><p>根设备信息号从<code>0x901fc</code>处获取，第一块硬盘的信息从<code>0x90080</code>处获取，扩展内存的数量从<code>0x90002</code>处获取。</p><p>这里根据设备总内存的大小决定高速缓存的位置。此外如果定义了虚拟盘<code>RAMDISK</code>，还需要预留一块内存。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>memory_end <span class="token operator">&gt;</span> <span class="token number">16</span><span class="token operator">*</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">)</span>
    memory_end <span class="token operator">=</span> <span class="token number">16</span><span class="token operator">*</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>memory_end <span class="token operator">&gt;</span> <span class="token number">12</span><span class="token operator">*</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">)</span> 
    buffer_memory_end <span class="token operator">=</span> <span class="token number">4</span><span class="token operator">*</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">;</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>memory_end <span class="token operator">&gt;</span> <span class="token number">6</span><span class="token operator">*</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">)</span>
    buffer_memory_end <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">;</span>
<span class="token keyword">else</span>
    buffer_memory_end <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">*</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">RAMDISK</span></span>
	main_memory_start <span class="token operator">+=</span> <span class="token function">rd_init</span><span class="token punctuation">(</span>main_memory_start<span class="token punctuation">,</span> RAMDISK<span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样定义好的内存各个模块的作用如下图所示：</p><figure><img src="https://github.com/zgjsxx/static-img-repo/raw/main/blog/Linux/kernel/Linux-0.11/Linux-0.11-init/memory-area.png" alt="memory-area" tabindex="0" loading="lazy"><figcaption>memory-area</figcaption></figure><p>接下来就是对各个模块进行初始化。其内容在具体的模块都有讲解，这里不再赘述。</p><p>各个模块的初始化完毕之后，就可以重新打开中断了。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>	<span class="token function">mem_init</span><span class="token punctuation">(</span>main_memory_start<span class="token punctuation">,</span>memory_end<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">trap_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">blk_dev_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">chr_dev_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">tty_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">time_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">sched_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">buffer_init</span><span class="token punctuation">(</span>buffer_memory_end<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">hd_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">floppy_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">sti</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来，将切换到用户态去执行进程0。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>	<span class="token function">move_to_user_mode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>		<span class="token comment">/* we count on this going ok */</span>
		<span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在分析<code>move_to_user_mode</code>之前，我们需要看一下<code>sched_init</code>函数中和进程0相关的部分。</p><p>由于后面的0号进程是用户态进程，因此<code>sched_init</code>中设置了LDTR寄存器的值。 LDTR寄存器的高13位代表位于GDTR中的索引。进程0的LDT位于GDT表中的第5项，因此索引为LDTR=(5&lt;&lt;3)。进程n的LDTR的位置是(5&lt;&lt;3) + (2n &lt;&lt; 3)， 因为LDT和TSS是交替存放的，所以需要n需要乘以2。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FIRST_TSS_ENTRY</span> <span class="token expression"><span class="token number">4</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FIRST_LDT_ENTRY</span> <span class="token expression"><span class="token punctuation">(</span>FIRST_TSS_ENTRY<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">_LDT</span><span class="token expression"><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> n<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">(</span>FIRST_LDT_ENTRY<span class="token operator">&lt;&lt;</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">lldt</span><span class="token expression"><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token function">__asm__</span><span class="token punctuation">(</span></span><span class="token string">&quot;lldt %%ax&quot;</span><span class="token expression"><span class="token operator">::</span></span><span class="token string">&quot;a&quot;</span> <span class="token expression"><span class="token punctuation">(</span><span class="token function">_LDT</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>

<span class="token function">sched_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token function">lldt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>设置完LDTR寄存器之后，下面要设置的就是LDT项的内容。</p><p>在<code>sched_init</code>函数中设置了进程0的<code>ldt</code>和<code>tss</code>。其中<code>ldt</code>部分的定义如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>    <span class="token comment">//ldt</span>
	<span class="token punctuation">{</span> \\
        <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span> \\
        <span class="token punctuation">{</span><span class="token number">0x9f</span><span class="token punctuation">,</span><span class="token number">0xc0fa00</span><span class="token punctuation">}</span><span class="token punctuation">,</span> \\
		<span class="token punctuation">{</span><span class="token number">0x9f</span><span class="token punctuation">,</span><span class="token number">0xc0f200</span><span class="token punctuation">}</span><span class="token punctuation">,</span> \\
	<span class="token punctuation">}</span><span class="token punctuation">,</span> \\
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,27),c=p("p",{"0x0000009f,0x00c0f200":""},"其中代码段为{0x0000009f,0x00c0fa00}， 数据段为",-1),i=n(`<p>接下来我们依次分析。</p><p>首先是代码段，{0x0000009f,0x00c0fa00}， 翻译成二进制,注意是按照小端序列，如下所示：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token number">63</span>-48:00000000 <span class="token number">11000000</span>
<span class="token number">47</span>-32:11111010 00000000
<span class="token number">31</span>-16:00000000 00000000
<span class="token number">15</span>-00:00000000 <span class="token number">10011111</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>按照段描述符的定义，代码段的分析结果如下:</p><p>段基址:00000000 00000000 00000000 00000000 段限长:0x009f * 4k</p><p>接下来是数据段，{0x0000009f,0x00c0f200}， 翻译成二进制,注意是按照小端序列，如下所示：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token number">63</span><span class="token operator">-</span><span class="token number">48</span><span class="token operator">:</span><span class="token number">00000000</span> <span class="token number">11000000</span>
<span class="token number">47</span><span class="token operator">-</span><span class="token number">32</span><span class="token operator">:</span><span class="token number">11110010</span> <span class="token number">00000000</span>
<span class="token number">31</span><span class="token operator">-</span><span class="token number">16</span><span class="token operator">:</span><span class="token number">00000000</span> <span class="token number">00000000</span>
<span class="token number">15</span><span class="token operator">-</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00000000</span> <span class="token number">10011111</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>按照段描述符的定义，数据段的分析结果如下</p><p>段基址:00000000 00000000 00000000 00000000 段限长:0x009f * 4k</p><p>由此可以看出，进程0的代码段和数据段都映射到线性地址为0处。</p><p>数据段和代码段唯一不同的是TYPE字段不同，代码段是1010，代表是代码段，其可读可执行。数据段是0010，代表数据段，且可读可写。</p><p>有了这些铺垫之后，下面就可以通过<code>move_to_user_mode</code>切换到用户态了，其定义如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">move_to_user_mode</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> </span><span class="token punctuation">\\</span>
<span class="token expression"><span class="token function">__asm__</span> <span class="token punctuation">(</span></span><span class="token string">&quot;movl %%esp,%%eax\\n\\t&quot;</span> <span class="token punctuation">\\</span>
	<span class="token string">&quot;pushl $0x17\\n\\t&quot;</span> <span class="token punctuation">\\</span>
	<span class="token string">&quot;pushl %%eax\\n\\t&quot;</span> <span class="token punctuation">\\</span>
	<span class="token string">&quot;pushfl\\n\\t&quot;</span> <span class="token punctuation">\\</span>
	<span class="token string">&quot;pushl $0x0f\\n\\t&quot;</span> <span class="token punctuation">\\</span>
	<span class="token string">&quot;pushl $1f\\n\\t&quot;</span> <span class="token punctuation">\\</span>
	<span class="token string">&quot;iret\\n&quot;</span> <span class="token punctuation">\\</span>
	<span class="token string">&quot;1:\\tmovl $0x17,%%eax\\n\\t&quot;</span> <span class="token punctuation">\\</span>
	<span class="token string">&quot;movw %%ax,%%ds\\n\\t&quot;</span> <span class="token punctuation">\\</span>
	<span class="token string">&quot;movw %%ax,%%es\\n\\t&quot;</span> <span class="token punctuation">\\</span>
	<span class="token string">&quot;movw %%ax,%%fs\\n\\t&quot;</span> <span class="token punctuation">\\</span>
	<span class="token string">&quot;movw %%ax,%%gs&quot;</span> <span class="token punctuation">\\</span>
	<span class="token expression"><span class="token operator">::</span><span class="token operator">:</span></span><span class="token string">&quot;ax&quot;</span><span class="token expression"><span class="token punctuation">)</span></span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看到其中使用了<code>iret</code>指令，因此这里其实是模拟了一个中断的压栈情况。其效果就是在<code>iret</code>返回时，使得<code>ss=0x17,cs=0x0f</code></p><figure><img src="https://github.com/zgjsxx/static-img-repo/raw/main/blog/Linux/kernel/Linux-0.11/Linux-0.11-init/move_to_user_mode.png" alt="move_to_user_mode" tabindex="0" loading="lazy"><figcaption>move_to_user_mode</figcaption></figure><p>接着通过<code>movw</code>指令，将<code>ds</code>、<code>es</code>、<code>fs</code>、<code>gs</code>都设置为<code>0x17</code>。</p><p>这里解释一下<code>0x17</code>和<code>0x0f</code>, 这两个段描述符的共性是都代码用户态，且位于LDT表中。 区别是0x17位于LDT表的第2项，即数据段，0x0f位于LDT表的第1项，即代码段。(此前<code>cs = 0x08</code>, <code>ss = 0x10</code>,代表内核态)。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>0x17 <span class="token operator">=</span> 00010_1_11
0x0f <span class="token operator">=</span> 00001_1_11
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>通过这一番操作，这些寄存器中的DPL都是3了，也就是用户态了。因此，可以这样总结，<code>move_to_user_mode</code>实际就是将<code>cs/ds/es/fs/gs/ss</code> 都设置为用户态的值。</p><p>在这最后，进程0开始fork出进程1(init进程)， 而自己则进入pause，因此进程0又被称为idle进程。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>		<span class="token comment">/* we count on this going ok */</span>
		<span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token function">pause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于init进程所做的事情，可以参考下文。</p><h3 id="init" tabindex="-1"><a class="header-anchor" href="#init" aria-hidden="true">#</a> init</h3><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>init进程是系统中真正的第一个进程。</p><p>setup()是一个系统调用。用于读取硬盘参数包括分区表信息并加载虚拟盘(若存在的话)和安装根文件系统设备。该函数用25行上的宏定义，对应函数是sys_setup()，在块设备子目录kernel/blk_drv/hd.c中。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>	<span class="token keyword">int</span> pid<span class="token punctuation">,</span>i<span class="token punctuation">;</span>
	<span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>drive_info<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>下面以读写访问方式打开设备<code>/dev/tty0</code>,它对应终端控制台。由于这是第一次打开文件操作，因此产生的文件句柄号(文件描述符)肯定是0。该句柄是UNIX类操作系统默认的控制台标准输入句柄stdin。这里再把它以读和写的方式别人打开是为了复制产生标准输出(写)句柄stdout和标准出错输出句柄stderr。函数前面的&quot;(void)&quot;前缀用于表示强制函数无需返回值。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>	<span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">&quot;/dev/tty0&quot;</span><span class="token punctuation">,</span>O_RDWR<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token function">dup</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token function">dup</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d buffers = %d bytes buffer space\\n\\r&quot;</span><span class="token punctuation">,</span>NR_BUFFERS<span class="token punctuation">,</span>
		NR_BUFFERS<span class="token operator">*</span>BLOCK_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Free mem: %d bytes\\n\\r&quot;</span><span class="token punctuation">,</span>memory_end<span class="token operator">-</span>main_memory_start<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>创建子进程并执行 <code>/etc/rc</code> 脚本，以初始化系统。如果子进程创建或执行失败，则打印错误信息并退出。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>pid<span class="token operator">=</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">close</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">&quot;/etc/rc&quot;</span><span class="token punctuation">,</span>O_RDONLY<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token function">_exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">execve</span><span class="token punctuation">(</span><span class="token string">&quot;/bin/sh&quot;</span><span class="token punctuation">,</span>argv_rc<span class="token punctuation">,</span>envp_rc<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">_exit</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面还是父进程(1)执行语句。wait()等待子进程停止或终止，返回值应是子进程的进程号(pid)。这三句的作用是父进程等待子进程的结束。&amp;i是存放返回状态信息的位置。如果wait()返回值不等于子进程号，则继续等待。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>	<span class="token keyword">if</span> <span class="token punctuation">(</span>pid<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>pid <span class="token operator">!=</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token comment">/* nothing */</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果执行到这里，说明刚创建的子进程的执行已停止或终止了。下面循环中首先再创建一个子进程，如果出错，则显示“初始化程序创建子进程失败”信息并继续执行。对于所创建的子进程将关闭所有以前还遗留的句柄(stdin, stdout, stderr),新创建一个会话并设置进程组号，然后重新打开/dev/tty0作为stdin,并复制成stdout和sdterr.再次执行系统解释程序/bin/sh。但这次执行所选用的参数和环境数组另选了一套。然后父进程再次运行wait()等待。如果子进程又停止了执行，则在标准输出上显示出错信息“子进程pid挺直了运行，返回码是i”,然后继续重试下去....，形成一个“大”循环。此外，wait()的另外一个功能是处理孤儿进程。如果一个进程的父进程先终止了，那么这个进程的父进程就会被设置为这里的init进程(进程1)，并由init进程负责释放一个已终止进程的任务数据结构等资源。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid<span class="token operator">=</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Fork failed in init\\r\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">continue</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token function">close</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">setsid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">&quot;/dev/tty0&quot;</span><span class="token punctuation">,</span>O_RDWR<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token function">dup</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token function">dup</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">_exit</span><span class="token punctuation">(</span><span class="token function">execve</span><span class="token punctuation">(</span><span class="token string">&quot;/bin/sh&quot;</span><span class="token punctuation">,</span>argv<span class="token punctuation">,</span>envp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;\\n\\rchild %d died with code %04x\\n\\r&quot;</span><span class="token punctuation">,</span>pid<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">_exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">/* NOTE! _exit, not exit() */</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>得注意的是，这段代码在退出时使用 _exit(0) 而不是 exit()。这是因为 _exit() 是一个系统调用，直接终止进程，而 exit() 则是一个库函数，会执行一系列清理操作后再调用 _exit() 终止进程。</p><h3 id="time-init" tabindex="-1"><a class="header-anchor" href="#time-init" aria-hidden="true">#</a> time_init</h3><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">time_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>该函数读取CMOS时钟信息作为系统的开机时间。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>	<span class="token keyword">struct</span> <span class="token class-name">tm</span> time<span class="token punctuation">;</span>

	<span class="token keyword">do</span> <span class="token punctuation">{</span>
		time<span class="token punctuation">.</span>tm_sec <span class="token operator">=</span> <span class="token function">CMOS_READ</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//当前的秒数</span>
		time<span class="token punctuation">.</span>tm_min <span class="token operator">=</span> <span class="token function">CMOS_READ</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//当前分钟值</span>
		time<span class="token punctuation">.</span>tm_hour <span class="token operator">=</span> <span class="token function">CMOS_READ</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//当前小时数</span>
		time<span class="token punctuation">.</span>tm_mday <span class="token operator">=</span> <span class="token function">CMOS_READ</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//当前的天数</span>
		time<span class="token punctuation">.</span>tm_mon <span class="token operator">=</span> <span class="token function">CMOS_READ</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//当前的月份</span>
		time<span class="token punctuation">.</span>tm_year <span class="token operator">=</span> <span class="token function">CMOS_READ</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//当前的年份</span>
	<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>time<span class="token punctuation">.</span>tm_sec <span class="token operator">!=</span> <span class="token function">CMOS_READ</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">BCD_TO_BIN</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>tm_sec<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//转换成二进制数值</span>
	<span class="token function">BCD_TO_BIN</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>tm_min<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">BCD_TO_BIN</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>tm_hour<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">BCD_TO_BIN</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>tm_mday<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">BCD_TO_BIN</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>tm_mon<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">BCD_TO_BIN</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>tm_year<span class="token punctuation">)</span><span class="token punctuation">;</span>
	time<span class="token punctuation">.</span>tm_mon<span class="token operator">--</span><span class="token punctuation">;</span>
	startup_time <span class="token operator">=</span> <span class="token function">kernel_mktime</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>time<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用kernel_mktime构建时间，详情参考Linux-0.11 kernel目录mktime.c详解</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从 CMOS 中读取秒、分、时、日、月、年等时间信息。由于 CMOS 读取速度较慢，为了减少时间误差，在读取所有时间值后，如果此时 CMOS 中秒值发生了变化，就重新读取所有值，以确保时间的准确性。</p><p>随后将读取的时间值从BCD码转换为二进制。调整月份的值，因为在结构体中月份的范围通常是 0 到 11。使用 kernel_mktime 函数计算开机时间，并将结果存储在 startup_time 变量中。这样，系统就能够根据 CMOS 中的时间信息初始化系统时间。</p><p>在读取时间时，使用到了<code>CMOS_READ</code>方法。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">CMOS_READ</span><span class="token expression"><span class="token punctuation">(</span>addr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> </span><span class="token punctuation">\\</span>
	<span class="token expression"><span class="token function">outb_p</span><span class="token punctuation">(</span><span class="token number">0x80</span><span class="token operator">|</span>addr<span class="token punctuation">,</span><span class="token number">0x70</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </span><span class="token punctuation">\\</span>
	<span class="token expression"><span class="token function">inb_p</span><span class="token punctuation">(</span><span class="token number">0x71</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </span><span class="token punctuation">\\</span>
<span class="token expression"><span class="token punctuation">}</span><span class="token punctuation">)</span></span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码是一个宏定义，用于读取 CMOS 芯片中的数据。让我们来解释一下这个宏的具体作用：</p><ul><li>CMOS_READ(addr) 宏接受一个参数 addr，代表要读取的 CMOS 地址。</li><li>宏定义的主体部分包含了两条指令： <ul><li>outb_p(0x80|addr, 0x70);：向端口 0x70 中写入一个值，该值是地址 addr 的基础上加上 0x80。这告诉 CMOS 芯片我们要读取的地址。</li><li>inb_p(0x71);：从端口 0x71 中读取一个字节的数据，该数据就是 CMOS 芯片中指定地址的内容。</li></ul></li><li>大括号 {} 中的内容表示这个宏的返回值，即执行完以上两条指令后，会返回从 CMOS 芯片中读取的数据。</li></ul><p>0x70和0x71是用于访问CMOS寄存器的两个I/O端口。通常情况下，向0x70端口写入要访问的CMOS寄存器地址，然后从0x71端口读取或写入数据。而0x80是CMOS芯片中的寄存器地址的基地址偏移，通过将其与要读取或写入的寄存器地址相加，可以将读取或写入的地址传递给CMOS芯片。</p><p>程序中还是用了<code>BCD_TO_BIN</code>将 BCD（Binary-Coded Decimal）码表示的数字转换为二进制表示的数字。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">BCD_TO_BIN</span><span class="token expression"><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">15</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span></span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在BCD码中，一个字节中的高四位表示十进制数的十位，低四位表示个位。因此，需要将这个BCD码转换为对应的十进制数。</p><p>这个宏定义中的操作如下：</p><ul><li><code>((val) &amp; 15)</code>：通过与操作符 &amp; 和掩码 15（二进制表示为00001111）获取BCD码的低四位（个位）所对应的值。</li><li><code>((val) &gt;&gt; 4) * 10</code>：通过右移操作符 &gt;&gt; 将BCD码的高四位（十位）移到低四位，然后乘以10，得到十进制数的十位所对应的值。</li><li><code>((val) &amp; 15) + ((val) &gt;&gt; 4) * 10</code>：将个位和十位的值相加，得到十进制数的整体值。</li></ul><p>最终，将这个计算结果赋值给 val，从而完成了BCD码到二进制数的转换。关于BCD码可以Q&amp;A。</p><h2 id="q-a" tabindex="-1"><a class="header-anchor" href="#q-a" aria-hidden="true">#</a> Q &amp; A</h2><ol><li>什么是BCD码？</li></ol><p>BCD（Binary-Coded Decimal）码是一种数字编码系统，用于将十进制数字表示为二进制形式。在BCD码中，每个十进制数位用四位二进制数来表示，通常每个十进制数位的取值范围为0到9。</p><p>举例来说，十进制数 73 的BCD码表示为 0111 0011，其中高四位（0111）表示十位数 7，低四位（0011）表示个位数 3。</p><p>BCD码与二进制码不同之处在于，BCD码是直接对十进制数位进行编码，而不像纯粹的二进制码一样对整数进行编码。这种编码方式使得BCD码在数字处理中更易于理解和处理，特别是在需要进行精确计算或与人类数学习惯相匹配的应用中。</p>`,58),l=[o,c,i];function u(k,r){return a(),t("div",null,l)}const m=s(e,[["render",u],["__file","Linux-0.11-init-main.html.vue"]]);export{m as default};
