const e=JSON.parse('{"key":"v-46f00b58","path":"/posts/Program_language/Assembly_language/fullerton_CSci241/Lecture24-OS-part1.html","title":"操作系统1","lang":"zh-CN","frontmatter":{"category":["汇编语言"],"description":"操作系统1 构建操作系统的基础知识 课程的最后，我们将在原始虚拟机上启动我们自己的\\"操作系统\\"(原始的)。我们将使用 QEMU 作为虚拟机（它安装在服务器上，如果我们需要调试代码，它可以与 GDB 通信）。 开机流程 系统启动有两个过程（即，将控制从系统芯片上的硬编码功能转移到某些存储介质上定义的代码），这两个过程都涉及在存储设备上运行某些代码（硬编码功能）。驱动器、闪存驱动器、DVD 等）： MBR：传统方式，引导存储设备的前 512 字节专用于主引导记录，其中应包含用于查找和运行操作系统其余部分的代码。该系统非常有限：每个驱动器只能有四个分区，并且引导记录的 512 字节大小限制意味着引导代码必须尽可能简单。另一方面，因为系统实际上只是直接从磁盘加载一些代码并开始运行它，所以这对我们来说是最容易编写的。","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/Program_language/Assembly_language/fullerton_CSci241/Lecture24-OS-part1.html"}],["meta",{"property":"og:site_name","content":"Code Building"}],["meta",{"property":"og:title","content":"操作系统1"}],["meta",{"property":"og:description","content":"操作系统1 构建操作系统的基础知识 课程的最后，我们将在原始虚拟机上启动我们自己的\\"操作系统\\"(原始的)。我们将使用 QEMU 作为虚拟机（它安装在服务器上，如果我们需要调试代码，它可以与 GDB 通信）。 开机流程 系统启动有两个过程（即，将控制从系统芯片上的硬编码功能转移到某些存储介质上定义的代码），这两个过程都涉及在存储设备上运行某些代码（硬编码功能）。驱动器、闪存驱动器、DVD 等）： MBR：传统方式，引导存储设备的前 512 字节专用于主引导记录，其中应包含用于查找和运行操作系统其余部分的代码。该系统非常有限：每个驱动器只能有四个分区，并且引导记录的 512 字节大小限制意味着引导代码必须尽可能简单。另一方面，因为系统实际上只是直接从磁盘加载一些代码并开始运行它，所以这对我们来说是最容易编写的。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-13T08:38:15.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-13T08:38:15.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"操作系统1\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-03-13T08:38:15.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"构建操作系统的基础知识","slug":"构建操作系统的基础知识","link":"#构建操作系统的基础知识","children":[]},{"level":2,"title":"MBR","slug":"mbr","link":"#mbr","children":[]},{"level":2,"title":"16位实模式","slug":"_16位实模式","link":"#_16位实模式","children":[]},{"level":2,"title":"段寄存器","slug":"段寄存器","link":"#段寄存器","children":[]},{"level":2,"title":"32位模式","slug":"_32位模式","link":"#_32位模式","children":[]},{"level":2,"title":"内存视图","slug":"内存视图","link":"#内存视图","children":[]}],"git":{"createdTime":1709629879000,"updatedTime":1710319095000,"contributors":[{"name":"zgjsxx","email":"119160524@qq.com","commits":3}]},"readingTime":{"minutes":7.44,"words":2231},"filePathRelative":"posts/Program_language/Assembly_language/fullerton_CSci241/Lecture24-OS-part1.md","localizedDate":"2024年3月5日","excerpt":"<h1> 操作系统1</h1>\\n<h2> 构建操作系统的基础知识</h2>\\n<p>课程的最后，我们将在原始虚拟机上启动我们自己的\\"操作系统\\"(原始的)。我们将使用 QEMU 作为虚拟机（它安装在服务器上，如果我们需要调试代码，它可以与 GDB 通信）。</p>\\n<p><strong>开机流程</strong></p>\\n<p>系统启动有两个过程（即，将控制从系统芯片上的硬编码功能转移到某些存储介质上定义的代码），这两个过程都涉及在存储设备上运行某些代码（硬编码功能）。驱动器、闪存驱动器、DVD 等）：</p>\\n<ul>\\n<li><strong>MBR</strong>：传统方式，引导存储设备的前 512 字节专用于主引导记录，其中应包含用于查找和运行操作系统其余部分的代码。该系统非常有限：每个驱动器只能有四个分区，并且引导记录的 512 字节大小限制意味着引导代码必须尽可能简单。另一方面，因为系统实际上只是直接从磁盘加载一些代码并开始运行它，所以这对我们来说是最容易编写的。</li>\\n</ul>","autoDesc":true}');export{e as data};
